<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="format-detection" content="telephone=no">
    <meta name="format-detection" content="email=no">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi">

    <link rel="stylesheet" type="text/css" href="css/main.css">

    <style shim-shadowdom="">
        /*******************************
          Flex Layout
*******************************/
        html /deep/[layout][horizontal],
        html /deep/[layout][vertical] {
            display: -ms-flexbox;
            display: -webkit-flex;
            display: flex;
        }
        html /deep/[layout][horizontal][inline],
        html /deep/[layout][vertical][inline] {
            display: -ms-inline-flexbox;
            display: -webkit-inline-flex;
            display: inline-flex;
        }
        html /deep/[layout][horizontal] {
            -ms-flex-direction: row;
            -webkit-flex-direction: row;
            flex-direction: row;
        }
        html /deep/[layout][horizontal][reverse] {
            -ms-flex-direction: row-reverse;
            -webkit-flex-direction: row-reverse;
            flex-direction: row-reverse;
        }
        html /deep/[layout][vertical] {
            -ms-flex-direction: column;
            -webkit-flex-direction: column;
            flex-direction: column;
        }
        html /deep/[layout][vertical][reverse] {
            -ms-flex-direction: column-reverse;
            -webkit-flex-direction: column-reverse;
            flex-direction: column-reverse;
        }
        html /deep/[layout][wrap] {
            -ms-flex-wrap: wrap;
            -webkit-flex-wrap: wrap;
            flex-wrap: wrap;
        }
        html /deep/[layout][wrap-reverse] {
            -ms-flex-wrap: wrap-reverse;
            -webkit-flex-wrap: wrap-reverse;
            flex-wrap: wrap-reverse;
        }
        html /deep/[flex] {
            -ms-flex: 1 1 0.000000001px;
            -webkit-flex: 1;
            flex: 1;
            -webkit-flex-basis: 0.000000001px;
            flex-basis: 0.000000001px;
        }
        html /deep/[vertical][layout] >[flex][auto-vertical],
        html /deep/[vertical][layout]::shadow[flex][auto-vertical] {
            -ms-flex: 1 1 auto;
            -webkit-flex-basis: auto;
            flex-basis: auto;
        }
        html /deep/[flex][auto] {
            -ms-flex: 1 1 auto;
            -webkit-flex-basis: auto;
            flex-basis: auto;
        }
        html /deep/[flex][none] {
            -ms-flex: none;
            -webkit-flex: none;
            flex: none;
        }
        html /deep/[flex][one] {
            -ms-flex: 1;
            -webkit-flex: 1;
            flex: 1;
        }
        html /deep/[flex][two] {
            -ms-flex: 2;
            -webkit-flex: 2;
            flex: 2;
        }
        html /deep/[flex][three] {
            -ms-flex: 3;
            -webkit-flex: 3;
            flex: 3;
        }
        html /deep/[flex][four] {
            -ms-flex: 4;
            -webkit-flex: 4;
            flex: 4;
        }
        html /deep/[flex][five] {
            -ms-flex: 5;
            -webkit-flex: 5;
            flex: 5;
        }
        html /deep/[flex][six] {
            -ms-flex: 6;
            -webkit-flex: 6;
            flex: 6;
        }
        html /deep/[flex][seven] {
            -ms-flex: 7;
            -webkit-flex: 7;
            flex: 7;
        }
        html /deep/[flex][eight] {
            -ms-flex: 8;
            -webkit-flex: 8;
            flex: 8;
        }
        html /deep/[flex][nine] {
            -ms-flex: 9;
            -webkit-flex: 9;
            flex: 9;
        }
        html /deep/[flex][ten] {
            -ms-flex: 10;
            -webkit-flex: 10;
            flex: 10;
        }
        html /deep/[flex][eleven] {
            -ms-flex: 11;
            -webkit-flex: 11;
            flex: 11;
        }
        html /deep/[flex][twelve] {
            -ms-flex: 12;
            -webkit-flex: 12;
            flex: 12;
        }
        /* alignment in cross axis */
        html /deep/[layout][start] {
            -ms-flex-align: start;
            -webkit-align-items: flex-start;
            align-items: flex-start;
        }
        html /deep/[layout][center],
        html /deep/[layout][center-center] {
            -ms-flex-align: center;
            -webkit-align-items: center;
            align-items: center;
        }
        html /deep/[layout][end] {
            -ms-flex-align: end;
            -webkit-align-items: flex-end;
            align-items: flex-end;
        }
        /* alignment in main axis */
        html /deep/[layout][start-justified] {
            -ms-flex-pack: start;
            -webkit-justify-content: flex-start;
            justify-content: flex-start;
        }
        html /deep/[layout][center-justified],
        html /deep/[layout][center-center] {
            -ms-flex-pack: center;
            -webkit-justify-content: center;
            justify-content: center;
        }
        html /deep/[layout][end-justified] {
            -ms-flex-pack: end;
            -webkit-justify-content: flex-end;
            justify-content: flex-end;
        }
        html /deep/[layout][around-justified] {
            -ms-flex-pack: distribute;
            -webkit-justify-content: space-around;
            justify-content: space-around;
        }
        html /deep/[layout][justified] {
            -ms-flex-pack: justify;
            -webkit-justify-content: space-between;
            justify-content: space-between;
        }
        /* self alignment */
        html /deep/[self-start] {
            -ms-align-self: flex-start;
            -webkit-align-self: flex-start;
            align-self: flex-start;
        }
        html /deep/[self-center] {
            -ms-align-self: center;
            -webkit-align-self: center;
            align-self: center;
        }
        html /deep/[self-end] {
            -ms-align-self: flex-end;
            -webkit-align-self: flex-end;
            align-self: flex-end;
        }
        html /deep/[self-stretch] {
            -ms-align-self: stretch;
            -webkit-align-self: stretch;
            align-self: stretch;
        }
        /*******************************
          Other Layout
*******************************/
        html /deep/[block] {
            display: block;
        }
        /* ie support for hidden */
        html /deep/[hidden] {
            display: none !important;
        }
        html /deep/[relative] {
            position: relative;
        }
        html /deep/[fit] {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        body[fullbleed] {
            margin: 0;
            height: 100vh;
        }
        /*******************************
            Other
*******************************/
        html /deep/[segment],
        html /deep/ segment {
            display: block;
            position: relative;
            -webkit-box-sizing: border-box;
            -ms-box-sizing: border-box;
            box-sizing: border-box;
            margin: 1em 0.5em;
            padding: 1em;
            background-color: white;
            -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
            box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
            border-radius: 5px 5px 5px 5px;
        }
    </style>

    <script src="bower_components/polymer/polymer.js"></script>
    <!--<link rel="import" href="../polymer-dev/polymer.html">-->







    <style shim-shadowdom="">
        /* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */
        html /deep/ core-icon {
            display: inline-block;
            vertical-align: middle;
            background-repeat: no-repeat;
            fill: currentcolor;
            position: relative;
            height: 24px;
            width: 24px;
        }
    </style>










    <style shim-shadowdom="">
        html /deep/ core-a11y-keys {
            display: none;
        }
    </style>










    <!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The
`target` property may be set to another element to cause that element to
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which
causes the overlay to fade in when displayed. See
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@homepage github.io
-->
    <!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
    <!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
    <!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
    <!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->
    <style>
        .core-overlay-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: black;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .core-overlay-backdrop.core-opened {
            opacity: 0.6;
        }
    </style>










    <!--

`core-dropdown-overlay` is a helper class to position an overlay relative to another
element within the same offsetParent.

@group Polymer Core Elements
@element core-dropdown-overlay
@extends core-overlay
@homepage github.io
-->










    <style shim-shadowdom="">
        /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
        html /deep/ paper-item {
            display: block;
            position: relative;
            font-size: 16px;
            -webkit-user-select: none;
            user-select: none;
            cursor: pointer;
            box-sizing: border-box;
            height: 48px;
            padding: 0 16px;
            white-space: nowrap;
        }
        html /deep/ paper-item::shadow #ripple {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            pointer-events: none;
        }
        html /deep/ paper-item::shadow #icon {
            margin-right: 8px;
        }
        html /deep/ paper-item::shadow::content > a {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>










    <script src="bower_components/web-animations-js/web-animations.js"></script>










    <!--

`core-transition-pages` represents a page transition, which may include CSS and/or
script. It will look for a `core-style` element with the same `id` to install in the
scope of the `core-animated-pages` that's using the transition.

Example:

    <core-style id="fooTransition">
        // some CSS here
    </core-style>
    <core-transition-pages id="fooTransition"></core-transition-pages>

There are three stages to a page transition:

1. `prepare`: Called to set up the incoming and outgoing pages to the "before" state,
  e.g. setting the incoming page to `opacity: 0` for `cross-fade` or find and
  measure hero elements for `hero-transition`.

2. `go`: Called to run the transition. For CSS-based transitions, this generally
  applies a CSS `transition` property.

3. `complete`: Called when the elements are finished transitioning.

See the individual transition documentation for specific details.

@element core-transition-pages
@extends core-transition
@status beta
@homepage github.io
-->
    <!--
Fired when the transition completes.

@event core-transitionend
-->







    <!--

`core-animated-pages` selects one of its children "pages" to show and runs a transition
when switching between them. The transitions are designed to be pluggable, and can
accept any object that is an instance of a `core-transition-pages`. Transitions to run
are specified in the `transitions` attribute as a space-delimited string of `id`s of
transition elements. Several transitions are available with `core-animated-pages` by
default, including `hero-transition`, `cross-fade`, and `tile-cascade`.

Example:

    <style>
      #hero1 {
        position: absolute;
        top: 0;
        left: 0;
        width: 300px;
        height: 300px;
        background-color: orange;
      }
      #hero2 {
        position: absolute;
        top: 200px;
        left: 300px;
        width: 300px;
        height: 300px;
        background-color: orange;
      }
      #bottom1, #bottom2 {
        position: absolute;
        bottom: 0;
        top: 0;
        left: 0;
        height: 50px;
      }
      #bottom1 {
        background-color: blue;
      }
      #bottom2 {
        background-color: green;
      }
    </style>
    // hero-transition and cross-fade are declared elsewhere
    <core-animated-pages transitions="hero-transition cross-fade">
      <section id="page1">
        <div id="hero1" hero-id="hero" hero></div>
        <div id="bottom1" cross-fade></div>
      </section>
      <section id="page2">
        <div id="hero2" hero-id="hero" hero></div>
        <div id="bottom2" cross-fade></div>
      </section>
    </core-animated-pages>

In the above example, two transitions (`hero-transition` and `cross-fade`) are run when switching
between `page1` and `page2`. `hero-transition` transforms elements with the same `hero-id` such
that they appear to be shared across different pages. `cross-fade` fades out the elements marked
`cross-fade` in the outgoing page, and fades in those in the incoming page. See the individual
transition's documentation for specific details.

Finding elements to transition
------------------------------

In general, a transition is applied to elements marked with a certain attribute. For example,
`hero-transition` applies the transition on elements with the `hero` and `hero-id` attribute.
Among the transitions included with `core-animated-pages`, script-based transitions such as
`hero-transition` generally look for elements up to one level of shadowRoot from the
`core-animated-pages` element, and CSS-based transitions such as `cross-fade` look for elements
within any shadowRoot within the `core-animated-pages` element. This means you can use
custom elements as pages and mark elements in their shadowRoots as heroes, or mark
elements in deeper shadowRoots with other transitions.

Example:

    <polymer-element name="x-el" noscript>
    <template>
      <style>
        #hero {
          position: absolute;
          top: 0;
          right: 0;
          width: 50px;
          height: 300px;
          background-color: blue;
        }
      </style>
      <div id="hero" hero-id="bar" hero></div>
    </template>
    </polymer-element>

    <polymer-element name="x-page-1" noscript>
    <template>
      <style>
        #hero1 {
          position: absolute;
          top: 0;
          left: 0;
          width: 300px;
          height: 300px;
          background-color: orange;
        }
      </style>
      <div id="hero1" hero-id="foo" hero></div>
      <div id="hero2" hero-id="bar" hero></div>
    </template>
    </polymer-element>

    <polymer-element name="x-page-2" noscript>
    <template>
      <style>
        #hero1 {
          position: absolute;
          top: 200px;
          left: 300px;
          width: 300px;
          height: 300px;
          background-color: orange;
        }
        #hero2 {
          background-color: blue;
          height: 150px;
          width: 400px;
        }
      </style>
      // The below element is one level of shadow from the core-animated-pages and will
      // be transitioned.
      <div id="hero1" hero-id="foo" hero></div>
      // The below element contains a hero inside its shadowRoot making it two levels away
      // from the core-animated-pages, and will not be transitioned.
      <x-el></x-el>
    </template>
    </polymer-element>

    <core-animated-pages transitions="hero-transition">
      <x-page-1></x-page-1>
      <x-page-2></x-page-2>
    </core-animated-pages>

Note that the container element of the page does not participate in the transition.

    // This does not work
    <core-animated-pages transitions="cross-fade">
      <section cross-fade></section>
      <section cross-fade></section>
    </core-animated-pages>

    // This works
    <core-animated-pages transitions="cross-fade">
      <section>
        <div cross-fade></div>
      </section>
      <section>
        <div cross-fade></div>
      </section>
    </core-animated-pages>

Dynamically setting up transitions
----------------------------------

An easy way to set up transitions dynamically is to use property binding on
the transition attributes.

Example:

    <core-animated-pages selected="{{selected}}">
      <section id="page1">
        <div hero-id="hero" hero></div>
      </section>
      <section id="page2">
        <div id="foo" hero-id="hero" hero?="{{selected === 1 || selected === 0}}" cross-fade="{{selected === 2}}"></div>
      </section>
      <section id="page3">
      </section>
    </core-animated-pages>

In the above example, the "foo" element only behaves as a hero element if transitioning between
`#page1` and `#page2`. It gets cross-faded when transition to or from `#page3`.

Nesting pages
-------------

It is possible to nest core-animated-pages elements for organization. Excessive nesting is
not encouraged, however, since it makes setting up the transition more complex.

To nest core-animated-pages, the page containing the nested core-animated-pages element should
have a `selectedItem` property bound to the `selectedItem` property of the nested element. This
will allow the outer core-animated-pages to know which nested page it is actually transitioning
to.

Example:

    <polymer-element name="nested-page" attributes="selectedItem">
    <template>
      <core-animated-pages selectedItem="{{selectedItem}}">
        ...
      </core-animated-pages>
    </template>
    </polymer-element>

    <core-animated-pages>
      <section id="page1"></section>
      <nested-page id="page2"></nested-page>
    </core-animated-pages>

@element core-animated-pages
@extends core-selector
@status beta
@homepage github.io
-->
    <!--
Fired before a page transition occurs. Both pages involved in the transition are visible when
this event fires. This is useful if there is something the client needs to do when a page becomes
visible.

@event core-animated-pages-transition-prepare
-->
    <!--
Fired when a page transition completes.

@event core-animated-pages-transition-end
-->



    <style shim-shadowdom="">
        /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
        html /deep/ core-collapse {
            display: block;
        }
        html /deep/ .core-collapse-closed {
            display: none;
        }
    </style>










    <script src="bower_components/marked/lib/marked.js"></script>


    <!--
Element wrapper for the `marked` (http://marked.org/) library.

@class marked-element
@blurb Element wrapper for the marked library.
@status alpha
@snap snap.png
-->

    <script src="bower_components/google-code-prettify/src/prettify.js"></script>

    <script src="bower_components/context-free-parser/context-free-parser.js"></script>


    <!--
Scrapes source documentation data from input text or url.

@class context-free-parser
-->


    <!--

Displays formatted source documentation scraped from input urls.

@element core-doc-page
-->










    <!--
@class core-doc-toc
-->




    <!--
Displays formatted source documentation scraped from input urls.

Documentation can be encoded into html comments (&lt;!-- ... --&gt;) or using JsDoc notation (/&#42;&#42; ... &#42;/).

When using JsDoc notation, remember that the left-margin includes an asterisk and a single space.
This is important for markdown constructs that count spaces. Code blocks for example, must be
five spaces from the first asterisk.

## Markdown

Markdown format is supported.

### Links

Arbitrary links can be encoded using [standard markdown format](http://daringfireball.net/projects/markdown/syntax).
[GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown) is also supported.

Links to other topics can be made with hash-links [core-doc-viewer](#core-doc-viewer).

### Code

Example

    Four space indents indicate code blocks.

    <code>blocks are syntax highlighted</code>

    <script>
      while(true) {
        javascript('is highlighted also');
      }
    </script>

### Blockquote

 > Blockquote is supported for long text that needs to wrap with a common left side indent.
 > Blockquote is supported for long text that needs to wrap with a common left side indent.

### Lists

1.  enumerated
1.  lists

Use - or + for bullet points:

- bullet
- lists

### Tables

| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |

### HTML

Arbitrary HTML is also supported

<input><button>Button</button><hr/>

@class core-doc-viewer
@homepage github.io
-->




    <style>
        core-drag-avatar {
            position: fixed;
            left: 0;
            top: 0;
            display: block;
            pointer-events: none;
        }
    </style>

    <!--
@group Polymer Core Elements
@element core-drag-drop
@homepage github.io
-->










    <!--
The `core-field` supplies a horizontal layout, anticipating an input.

Example:

    <core-field>
      <core-icon icon="menu"></core-icon>
      <label>I'm a label!</label>
      <input placeholder="I have a label" flex>
    </core-field>

@group Polymer Core Elements
@element core-field
@homepage github.io
-->










    <!--
Supports sharing a JSONP-based JavaScript library.

    <core-shared-lib on-core-shared-lib-load="{{load}}" url="https://apis.google.com/js/plusone.js?onload=%%callback%%">

Multiple components can request a library using a `core-shared-lib` component and only one copy of that library will
loaded from the network.

Currently, the library must support JSONP to work as a shared-lib.

Some libraries require a specific global function be defined. If this is the case, specify the `callbackName` property.

Where possible, you should use an HTML Import to load library dependencies. Rather than using this element,
create an import (`<link rel="import" href="lib.html">`) that wraps loading the .js file:

lib.html:

    <script src="lib.js"></script>

@group Polymer Core Elements
@element core-shared-lib
-->



    <!--
`core-signals` provides basic publish-subscribe functionality.

Note: avoid using `core-signals` whenever you can use
a controller (parent element) to mediate communication
instead.

To send a signal, fire a custom event of type `core-signal`, with
a detail object containing `name` and `data` fields.

    this.fire('core-signal', {name: 'hello', data: null});

To receive a signal, listen for `core-signal-<name>` event on a
`core-signal` element.

  <core-signal on-core-signal-hello="{{helloSignal}}">

You can fire a signal event from anywhere, and all
`core-signal` elements will receive the event, regardless
of where they are in DOM.

@group Polymer Core Elements
@element core-signals
@status stable
@homepage github.io
-->









    <!-- TODO: would be nice to inherit from label to get .htmlFor, and .control,
           but the latter is readonly. -->
    <!-- TODO: support off center arrows. -->
    <!-- TODO: detect mobile and apply the .large class, instead of manual
           control. -->
    <!-- TODO: possibly reuse core-overlay. -->




    <title>Deal Me Local</title>
    <style>
    </style>

    <style shim-shadowdom="">
        body {
            font-family: RobotoDraft, 'Helvetica Neue', Helvetica, Arial;
            font-size: 1em;
            margin: 0;
            padding: 0;
            color: #333;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            -webkit-touch-callout: none;
        }
        paper-tabs,
        core-toolbar {
            background-color: #00aeef;
            font-size: 1.2em;
            color: #fff;
            box-shadow: 0px 3px 2px rgba(0, 0, 0, 0.2);
        }
        core-toolbar paper-tabs {
            box-shadow: none;
        }
        h3 {
            font-size: 1em;
            font-weight: 400;
        }
        core-scroll-header-panel {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        /* background for toolbar when it is at its full size */
        core-scroll-header-panel::shadow #headerBg {
            background-image: url("img/bridge.jpg");
        }
        /* background for toolbar when it is condensed */
        core-scroll-header-panel::shadow #condensedHeaderBg {
            background-color: #2980b9;
        }
        core-toolbar {
            color: #f1f1f1;
            fill: #f1f1f1;
            background-color: transparent;
        }
        .title {
            -webkit-transform-origin: 0;
            transform-origin: 0;
            font-size: 40px;
        }
        #container {
            overflow: auto;
        }
        #map {
            position: fixed;
            left: 0px;
            top: 0px;
            right: 0px;
            bottom: 0px;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .ui-button {
            display: block;
            position: fixed;
            bottom: 10%px;
            right: 10%;
            width: 160px;
            margin: -20px 0 0 -80px;
            z-index: 100;
            text-align: center;
            margin: 8px;
            background-color: tomato;
            color: #eee;
            border-radius: 4px;
            cursor: default;
        }
        .view {
            font-size: 250px;
            background-color: tomato;
        }
        .venue-blocks {
            text-align: center;
            top: 0px;
            bottom: 0px;
            left: 0px;
            right: 0px;
        }
    </style>
</head>

<body fullbleed="" layout="" vertical="" unresovled="">
    <div hidden="">
        <polymer-element name="core-meta" attributes="label type" hidden="" assetpath="bower_components/core-meta/">
            <script>
                (function () {

                    var SKIP_ID = 'meta';
                    var metaData = {},
                        metaArray = {};

                    Polymer('core-meta', {

                        /**
                         * The type of meta-data.  All meta-data with the same type with be
                         * stored together.
                         *
                         * @attribute type
                         * @type string
                         * @default 'default'
                         */
                        type: 'default',

                        alwaysPrepare: true,

                        ready: function () {
                            this.register(this.id);
                        },

                        get metaArray() {
                            var t = this.type;
                            if (!metaArray[t]) {
                                metaArray[t] = [];
                            }
                            return metaArray[t];
                        },

                        get metaData() {
                            var t = this.type;
                            if (!metaData[t]) {
                                metaData[t] = {};
                            }
                            return metaData[t];
                        },

                        register: function (id, old) {
                            if (id && id !== SKIP_ID) {
                                this.unregister(this, old);
                                this.metaData[id] = this;
                                this.metaArray.push(this);
                            }
                        },

                        unregister: function (meta, id) {
                            delete this.metaData[id || meta.id];
                            var i = this.metaArray.indexOf(meta);
                            if (i >= 0) {
                                this.metaArray.splice(i, 1);
                            }
                        },

                        /**
                         * Returns a list of all meta-data elements with the same type.
                         *
                         * @property list
                         * @type array
                         * @default []
                         */
                        get list() {
                            return this.metaArray;
                        },

                        /**
                         * Retrieves meta-data by ID.
                         *
                         * @method byId
                         * @param {String} id The ID of the meta-data to be returned.
                         * @returns Returns meta-data.
                         */
                        byId: function (id) {
                            return this.metaData[id];
                        }

                    });

                })();
            </script>
        </polymer-element>
        <polymer-element name="core-iconset" extends="core-meta" attributes="src width icons iconSize" assetpath="bower_components/core-iconset/">

            <script>
                Polymer('core-iconset', {

                    /**
                     * The URL of the iconset image.
                     *
                     * @attribute src
                     * @type string
                     * @default ''
                     */
                    src: '',

                    /**
                     * The width of the iconset image. This must only be specified if the
                     * icons are arranged into separate rows inside the image.
                     *
                     * @attribute width
                     * @type number
                     * @default 0
                     */
                    width: 0,

                    /**
                     * A space separated list of names corresponding to icons in the iconset
                     * image file. This list must be ordered the same as the icon images
                     * in the image file.
                     *
                     * @attribute icons
                     * @type string
                     * @default ''
                     */
                    icons: '',

                    /**
                     * The size of an individual icon. Note that icons must be square.
                     *
                     * @attribute iconSize
                     * @type number
                     * @default 24
                     */
                    iconSize: 24,

                    /**
                     * The horizontal offset of the icon images in the inconset src image.
                     * This is typically used if the image resource contains additional images
                     * beside those intended for the iconset.
                     *
                     * @attribute offsetX
                     * @type number
                     * @default 0
                     */
                    offsetX: 0,
                    /**
                     * The vertical offset of the icon images in the inconset src image.
                     * This is typically used if the image resource contains additional images
                     * beside those intended for the iconset.
                     *
                     * @attribute offsetY
                     * @type number
                     * @default 0
                     */
                    offsetY: 0,
                    type: 'iconset',

                    created: function () {
                        this.iconMap = {};
                        this.iconNames = [];
                        this.themes = {};
                    },

                    ready: function () {
                        // TODO(sorvell): ensure iconset's src is always relative to the main
                        // document
                        if (this.src && (this.ownerDocument !== document)) {
                            this.src = this.resolvePath(this.src, this.ownerDocument.baseURI);
                        }
                        this.super();
                        this.updateThemes();
                    },

                    iconsChanged: function () {
                        var ox = this.offsetX;
                        var oy = this.offsetY;
                        this.icons && this.icons.split(/\s+/g).forEach(function (name, i) {
                            this.iconNames.push(name);
                            this.iconMap[name] = {
                                offsetX: ox,
                                offsetY: oy
                            }
                            if (ox + this.iconSize < this.width) {
                                ox += this.iconSize;
                            } else {
                                ox = this.offsetX;
                                oy += this.iconSize;
                            }
                        }, this);
                    },

                    updateThemes: function () {
                        var ts = this.querySelectorAll('property[theme]');
                        ts && ts.array().forEach(function (t) {
                            this.themes[t.getAttribute('theme')] = {
                                offsetX: parseInt(t.getAttribute('offsetX')) || 0,
                                offsetY: parseInt(t.getAttribute('offsetY')) || 0
                            };
                        }, this);
                    },

                    // TODO(ffu): support retrived by index e.g. getOffset(10);
                    /**
                     * Returns an object containing `offsetX` and `offsetY` properties which
                     * specify the pixel locaion in the iconset's src file for the given
                     * `icon` and `theme`. It's uncommon to call this method. It is useful,
                     * for example, to manually position a css backgroundImage to the proper
                     * offset. It's more common to use the `applyIcon` method.
                     *
                     * @method getOffset
                     * @param {String|Number} icon The name of the icon or the index of the
                     * icon within in the icon image.
                     * @param {String} theme The name of the theme.
                     * @returns {Object} An object specifying the offset of the given icon
                     * within the icon resource file; `offsetX` is the horizontal offset and
                     * `offsetY` is the vertical offset. Both values are in pixel units.
                     */
                    getOffset: function (icon, theme) {
                        var i = this.iconMap[icon];
                        if (!i) {
                            var n = this.iconNames[Number(icon)];
                            i = this.iconMap[n];
                        }
                        var t = this.themes[theme];
                        if (i && t) {
                            return {
                                offsetX: i.offsetX + t.offsetX,
                                offsetY: i.offsetY + t.offsetY
                            }
                        }
                        return i;
                    },

                    /**
                     * Applies an icon to the given element as a css background image. This
                     * method does not size the element, and it's often necessary to set
                     * the element's height and width so that the background image is visible.
                     *
                     * @method applyIcon
                     * @param {Element} element The element to which the background is
                     * applied.
                     * @param {String|Number} icon The name or index of the icon to apply.
                     * @param {Number} scale (optional, defaults to 1) A scaling factor
                     * with which the icon can be magnified.
                     * @return {Element} The icon element.
                     */
                    applyIcon: function (element, icon, scale) {
                        var offset = this.getOffset(icon);
                        scale = scale || 1;
                        if (element && offset) {
                            var icon = element._icon || document.createElement('div');
                            var style = icon.style;
                            style.backgroundImage = 'url(' + this.src + ')';
                            style.backgroundPosition = (-offset.offsetX * scale + 'px') +
                                ' ' + (-offset.offsetY * scale + 'px');
                            style.backgroundSize = scale === 1 ? 'auto' :
                                this.width * scale + 'px';
                            if (icon.parentNode !== element) {
                                element.appendChild(icon);
                            }
                            return icon;
                        }
                    }

                });
            </script>

        </polymer-element>
        <polymer-element name="core-icon" attributes="src icon alt" assetpath="bower_components/core-icon/">
            <script>
                (function () {

                    // mono-state
                    var meta;

                    Polymer('core-icon', {

                        /**
                         * The URL of an image for the icon. If the src property is specified,
                         * the icon property should not be.
                         *
                         * @attribute src
                         * @type string
                         * @default ''
                         */
                        src: '',

                        /**
                         * Specifies the icon name or index in the set of icons available in
                         * the icon's icon set. If the icon property is specified,
                         * the src property should not be.
                         *
                         * @attribute icon
                         * @type string
                         * @default ''
                         */
                        icon: '',

                        /**
                         * Alternative text content for accessibility support.
                         * If alt is present and not empty, it will set the element's role to img and add an aria-label whose content matches alt.
                         * If alt is present and is an empty string, '', it will hide the element from the accessibility layer
                         * If alt is not present, it will set the element's role to img and the element will fallback to using the icon attribute for its aria-label.
                         *
                         * @attribute alt
                         * @type string
                         * @default ''
                         */
                        alt: null,

                        observe: {
                            'icon': 'updateIcon',
                            'alt': 'updateAlt'
                        },

                        defaultIconset: 'icons',

                        ready: function () {
                            if (!meta) {
                                meta = document.createElement('core-iconset');
                            }

                            // Allow user-provided `aria-label` in preference to any other text alternative.
                            if (this.hasAttribute('aria-label')) {
                                // Set `role` if it has not been overridden.
                                if (!this.hasAttribute('role')) {
                                    this.setAttribute('role', 'img');
                                }
                                return;
                            }
                            this.updateAlt();
                        },

                        srcChanged: function () {
                            var icon = this._icon || document.createElement('div');
                            icon.textContent = '';
                            icon.setAttribute('fit', '');
                            icon.style.backgroundImage = 'url(' + this.src + ')';
                            icon.style.backgroundPosition = 'center';
                            icon.style.backgroundSize = '100%';
                            if (!icon.parentNode) {
                                this.appendChild(icon);
                            }
                            this._icon = icon;
                        },

                        getIconset: function (name) {
                            return meta.byId(name || this.defaultIconset);
                        },

                        updateIcon: function (oldVal, newVal) {
                            if (!this.icon) {
                                this.updateAlt();
                                return;
                            }
                            var parts = String(this.icon).split(':');
                            var icon = parts.pop();
                            if (icon) {
                                var set = this.getIconset(parts.pop());
                                if (set) {
                                    this._icon = set.applyIcon(this, icon);
                                    if (this._icon) {
                                        this._icon.setAttribute('fit', '');
                                    }
                                }
                            }
                            // Check to see if we're using the old icon's name for our a11y fallback
                            if (oldVal) {
                                if (oldVal.split(':').pop() == this.getAttribute('aria-label')) {
                                    this.updateAlt();
                                }
                            }
                        },

                        updateAlt: function () {
                            // Respect the user's decision to remove this element from
                            // the a11y tree
                            if (this.getAttribute('aria-hidden')) {
                                return;
                            }

                            // Remove element from a11y tree if `alt` is empty, otherwise
                            // use `alt` as `aria-label`.
                            if (this.alt === '') {
                                this.setAttribute('aria-hidden', 'true');
                                if (this.hasAttribute('role')) {
                                    this.removeAttribute('role');
                                }
                                if (this.hasAttribute('aria-label')) {
                                    this.removeAttribute('aria-label');
                                }
                            } else {
                                this.setAttribute('aria-label', this.alt ||
                                    this.icon.split(':').pop());
                                if (!this.hasAttribute('role')) {
                                    this.setAttribute('role', 'img');
                                }
                                if (this.hasAttribute('aria-hidden')) {
                                    this.removeAttribute('aria-hidden');
                                }
                            }
                        }

                    });

                })();
            </script>

        </polymer-element>

        <polymer-element name="paper-ripple" attributes="initialOpacity opacityDecayVelocity" assetpath="bower_components/paper-ripple/">
            <template>

                <style>
                    :host {
                        display: block;
                        position: relative;
                        border-radius: inherit;
                        overflow: hidden;
                    }
                    :host-context([noink]) {
                        pointer-events: none;
                    }
                    #bg,
                    #waves,
                    .wave-container,
                    .wave {
                        pointer-events: none;
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                    }
                    #bg,
                    .wave {
                        opacity: 0;
                    }
                    #waves,
                    .wave {
                        overflow: hidden;
                    }
                    .wave-container,
                    .wave {
                        border-radius: 50%;
                    }
                    :host(.circle) #bg,
                    :host(.circle) #waves {
                        border-radius: 50%;
                    }
                    :host(.circle) .wave-container {
                        overflow: hidden;
                    }
                </style>

                <div id="bg"></div>
                <div id="waves">
                </div>

            </template>
            <script>
                (function () {

                    var waveMaxRadius = 150;
                    //
                    // INK EQUATIONS
                    //
                    function waveRadiusFn(touchDownMs, touchUpMs, anim) {
                        // Convert from ms to s.
                        var touchDown = touchDownMs / 1000;
                        var touchUp = touchUpMs / 1000;
                        var totalElapsed = touchDown + touchUp;
                        var ww = anim.width,
                            hh = anim.height;
                        // use diagonal size of container to avoid floating point math sadness
                        var waveRadius = Math.min(Math.sqrt(ww * ww + hh * hh), waveMaxRadius) * 1.1 + 5;
                        var duration = 1.1 - .2 * (waveRadius / waveMaxRadius);
                        var tt = (totalElapsed / duration);

                        var size = waveRadius * (1 - Math.pow(80, -tt));
                        return Math.abs(size);
                    }

                    function waveOpacityFn(td, tu, anim) {
                        // Convert from ms to s.
                        var touchDown = td / 1000;
                        var touchUp = tu / 1000;
                        var totalElapsed = touchDown + touchUp;

                        if (tu <= 0) { // before touch up
                            return anim.initialOpacity;
                        }
                        return Math.max(0, anim.initialOpacity - touchUp * anim.opacityDecayVelocity);
                    }

                    function waveOuterOpacityFn(td, tu, anim) {
                        // Convert from ms to s.
                        var touchDown = td / 1000;
                        var touchUp = tu / 1000;

                        // Linear increase in background opacity, capped at the opacity
                        // of the wavefront (waveOpacity).
                        var outerOpacity = touchDown * 0.3;
                        var waveOpacity = waveOpacityFn(td, tu, anim);
                        return Math.max(0, Math.min(outerOpacity, waveOpacity));
                    }

                    // Determines whether the wave should be completely removed.
                    function waveDidFinish(wave, radius, anim) {
                        var waveOpacity = waveOpacityFn(wave.tDown, wave.tUp, anim);

                        // If the wave opacity is 0 and the radius exceeds the bounds
                        // of the element, then this is finished.
                        return waveOpacity < 0.01 && radius >= Math.min(wave.maxRadius, waveMaxRadius);
                    };

                    function waveAtMaximum(wave, radius, anim) {
                        var waveOpacity = waveOpacityFn(wave.tDown, wave.tUp, anim);

                        return waveOpacity >= anim.initialOpacity && radius >= Math.min(wave.maxRadius, waveMaxRadius);
                    }

                    //
                    // DRAWING
                    //
                    function drawRipple(ctx, x, y, radius, innerAlpha, outerAlpha) {
                        // Only animate opacity and transform
                        if (outerAlpha !== undefined) {
                            ctx.bg.style.opacity = outerAlpha;
                        }
                        ctx.wave.style.opacity = innerAlpha;

                        var s = radius / (ctx.containerSize / 2);
                        var dx = x - (ctx.containerWidth / 2);
                        var dy = y - (ctx.containerHeight / 2);

                        ctx.wc.style.webkitTransform = 'translate3d(' + dx + 'px,' + dy + 'px,0)';
                        ctx.wc.style.transform = 'translate3d(' + dx + 'px,' + dy + 'px,0)';

                        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
                        // https://bugs.webkit.org/show_bug.cgi?id=98538
                        ctx.wave.style.webkitTransform = 'scale(' + s + ',' + s + ')';
                        ctx.wave.style.transform = 'scale3d(' + s + ',' + s + ',1)';
                    }

                    //
                    // SETUP
                    //
                    function createWave(elem) {
                        var elementStyle = window.getComputedStyle(elem);
                        var fgColor = elementStyle.color;

                        var inner = document.createElement('div');
                        inner.style.backgroundColor = fgColor;
                        inner.classList.add('wave');

                        var outer = document.createElement('div');
                        outer.classList.add('wave-container');
                        outer.appendChild(inner);

                        var container = elem.$.waves;
                        container.appendChild(outer);

                        elem.$.bg.style.backgroundColor = fgColor;

                        var wave = {
                            bg: elem.$.bg,
                            wc: outer,
                            wave: inner,
                            waveColor: fgColor,
                            maxRadius: 0,
                            isMouseDown: false,
                            mouseDownStart: 0.0,
                            mouseUpStart: 0.0,
                            tDown: 0,
                            tUp: 0
                        };
                        return wave;
                    }

                    function removeWaveFromScope(scope, wave) {
                        if (scope.waves) {
                            var pos = scope.waves.indexOf(wave);
                            scope.waves.splice(pos, 1);
                            // FIXME cache nodes
                            wave.wc.remove();
                        }
                    };

                    // Shortcuts.
                    var pow = Math.pow;
                    var now = Date.now;
                    if (window.performance && performance.now) {
                        now = performance.now.bind(performance);
                    }

                    function cssColorWithAlpha(cssColor, alpha) {
                        var parts = cssColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                        if (typeof alpha == 'undefined') {
                            alpha = 1;
                        }
                        if (!parts) {
                            return 'rgba(255, 255, 255, ' + alpha + ')';
                        }
                        return 'rgba(' + parts[1] + ', ' + parts[2] + ', ' + parts[3] + ', ' + alpha + ')';
                    }

                    function dist(p1, p2) {
                        return Math.sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
                    }

                    function distanceFromPointToFurthestCorner(point, size) {
                        var tl_d = dist(point, {
                            x: 0,
                            y: 0
                        });
                        var tr_d = dist(point, {
                            x: size.w,
                            y: 0
                        });
                        var bl_d = dist(point, {
                            x: 0,
                            y: size.h
                        });
                        var br_d = dist(point, {
                            x: size.w,
                            y: size.h
                        });
                        return Math.max(tl_d, tr_d, bl_d, br_d);
                    }

                    Polymer('paper-ripple', {

                        /**
                         * The initial opacity set on the wave.
                         *
                         * @attribute initialOpacity
                         * @type number
                         * @default 0.25
                         */
                        initialOpacity: 0.25,

                        /**
                         * How fast (opacity per second) the wave fades out.
                         *
                         * @attribute opacityDecayVelocity
                         * @type number
                         * @default 0.8
                         */
                        opacityDecayVelocity: 0.8,

                        backgroundFill: true,
                        pixelDensity: 2,

                        eventDelegates: {
                            down: 'downAction',
                            up: 'upAction'
                        },

                        ready: function () {
                            this.waves = [];
                        },

                        downAction: function (e) {
                            var wave = createWave(this);

                            this.cancelled = false;
                            wave.isMouseDown = true;
                            wave.tDown = 0.0;
                            wave.tUp = 0.0;
                            wave.mouseUpStart = 0.0;
                            wave.mouseDownStart = now();

                            var rect = this.getBoundingClientRect();
                            var width = rect.width;
                            var height = rect.height;
                            var touchX = e.x - rect.left;
                            var touchY = e.y - rect.top;

                            wave.startPosition = {
                                x: touchX,
                                y: touchY
                            };

                            if (this.classList.contains("recenteringTouch")) {
                                wave.endPosition = {
                                    x: width / 2,
                                    y: height / 2
                                };
                                wave.slideDistance = dist(wave.startPosition, wave.endPosition);
                            }
                            wave.containerSize = Math.max(width, height);
                            wave.containerWidth = width;
                            wave.containerHeight = height;
                            wave.maxRadius = distanceFromPointToFurthestCorner(wave.startPosition, {
                                w: width,
                                h: height
                            });

                            // The wave is circular so constrain its container to 1:1
                            wave.wc.style.top = (wave.containerHeight - wave.containerSize) / 2 + 'px';
                            wave.wc.style.left = (wave.containerWidth - wave.containerSize) / 2 + 'px';
                            wave.wc.style.width = wave.containerSize + 'px';
                            wave.wc.style.height = wave.containerSize + 'px';

                            this.waves.push(wave);

                            if (!this._loop) {
                                this._loop = this.animate.bind(this, {
                                    width: width,
                                    height: height
                                });
                                requestAnimationFrame(this._loop);
                            }
                            // else there is already a rAF
                        },

                        upAction: function () {
                            for (var i = 0; i < this.waves.length; i++) {
                                // Declare the next wave that has mouse down to be mouse'ed up.
                                var wave = this.waves[i];
                                if (wave.isMouseDown) {
                                    wave.isMouseDown = false
                                    wave.mouseUpStart = now();
                                    wave.mouseDownStart = 0;
                                    wave.tUp = 0.0;
                                    break;
                                }
                            }
                            this._loop && requestAnimationFrame(this._loop);
                        },

                        cancel: function () {
                            this.cancelled = true;
                        },

                        animate: function (ctx) {
                            var shouldRenderNextFrame = false;

                            var deleteTheseWaves = [];
                            // The oldest wave's touch down duration
                            var longestTouchDownDuration = 0;
                            var longestTouchUpDuration = 0;
                            // Save the last known wave color
                            var lastWaveColor = null;
                            // wave animation values
                            var anim = {
                                initialOpacity: this.initialOpacity,
                                opacityDecayVelocity: this.opacityDecayVelocity,
                                height: ctx.height,
                                width: ctx.width
                            }

                            for (var i = 0; i < this.waves.length; i++) {
                                var wave = this.waves[i];

                                if (wave.mouseDownStart > 0) {
                                    wave.tDown = now() - wave.mouseDownStart;
                                }
                                if (wave.mouseUpStart > 0) {
                                    wave.tUp = now() - wave.mouseUpStart;
                                }

                                // Determine how long the touch has been up or down.
                                var tUp = wave.tUp;
                                var tDown = wave.tDown;
                                longestTouchDownDuration = Math.max(longestTouchDownDuration, tDown);
                                longestTouchUpDuration = Math.max(longestTouchUpDuration, tUp);

                                // Obtain the instantenous size and alpha of the ripple.
                                var radius = waveRadiusFn(tDown, tUp, anim);
                                var waveAlpha = waveOpacityFn(tDown, tUp, anim);
                                var waveColor = cssColorWithAlpha(wave.waveColor, waveAlpha);
                                lastWaveColor = wave.waveColor;

                                // Position of the ripple.
                                var x = wave.startPosition.x;
                                var y = wave.startPosition.y;

                                // Ripple gravitational pull to the center of the canvas.
                                if (wave.endPosition) {

                                    // This translates from the origin to the center of the view  based on the max dimension of
                                    var translateFraction = Math.min(1, radius / wave.containerSize * 2 / Math.sqrt(2));

                                    x += translateFraction * (wave.endPosition.x - wave.startPosition.x);
                                    y += translateFraction * (wave.endPosition.y - wave.startPosition.y);
                                }

                                // If we do a background fill fade too, work out the correct color.
                                var bgFillColor = null;
                                if (this.backgroundFill) {
                                    var bgFillAlpha = waveOuterOpacityFn(tDown, tUp, anim);
                                    bgFillColor = cssColorWithAlpha(wave.waveColor, bgFillAlpha);
                                }

                                // Draw the ripple.
                                drawRipple(wave, x, y, radius, waveAlpha, bgFillAlpha);

                                // Determine whether there is any more rendering to be done.
                                var maximumWave = waveAtMaximum(wave, radius, anim);
                                var waveDissipated = waveDidFinish(wave, radius, anim);
                                var shouldKeepWave = !waveDissipated || maximumWave;
                                // keep rendering dissipating wave when at maximum radius on upAction
                                var shouldRenderWaveAgain = wave.mouseUpStart ? !waveDissipated : !maximumWave;
                                shouldRenderNextFrame = shouldRenderNextFrame || shouldRenderWaveAgain;
                                if (!shouldKeepWave || this.cancelled) {
                                    deleteTheseWaves.push(wave);
                                }
                            }

                            if (shouldRenderNextFrame) {
                                requestAnimationFrame(this._loop);
                            }

                            for (var i = 0; i < deleteTheseWaves.length; ++i) {
                                var wave = deleteTheseWaves[i];
                                removeWaveFromScope(this, wave);
                            }

                            if (!this.waves.length && this._loop) {
                                // clear the background color
                                this.$.bg.style.backgroundColor = null;
                                this._loop = null;
                                this.fire('core-transitionend');
                            }
                        }

                    });

                })();
            </script>
        </polymer-element>

        <polymer-element name="paper-shadow" assetpath="bower_components/paper-shadow/">

            <template>

                <style no-shim="">
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    .paper-shadow {
                        position: absolute;
                        top: 0;
                        left: 0;
                        bottom: 0;
                        right: 0;
                        border-radius: inherit;
                        pointer-events: none;
                    }
                    .paper-shadow-animated.paper-shadow {
                        transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    .paper-shadow-top-z-1 {
                        box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.16);
                    }
                    .paper-shadow-bottom-z-1 {
                        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
                    }
                    .paper-shadow-top-z-2 {
                        box-shadow: 0 6px 20px 0 rgba(0, 0, 0, 0.19);
                    }
                    .paper-shadow-bottom-z-2 {
                        box-shadow: 0 8px 17px 0 rgba(0, 0, 0, 0.2);
                    }
                    .paper-shadow-top-z-3 {
                        box-shadow: 0 17px 50px 0 rgba(0, 0, 0, 0.19);
                    }
                    .paper-shadow-bottom-z-3 {
                        box-shadow: 0 12px 15px 0 rgba(0, 0, 0, 0.24);
                    }
                    .paper-shadow-top-z-4 {
                        box-shadow: 0 25px 55px 0 rgba(0, 0, 0, 0.21);
                    }
                    .paper-shadow-bottom-z-4 {
                        box-shadow: 0 16px 28px 0 rgba(0, 0, 0, 0.22);
                    }
                    .paper-shadow-top-z-5 {
                        box-shadow: 0 40px 77px 0 rgba(0, 0, 0, 0.22);
                    }
                    .paper-shadow-bottom-z-5 {
                        box-shadow: 0 27px 24px 0 rgba(0, 0, 0, 0.2);
                    }
                    .paper-shadow-animate-z-1-z-2.paper-shadow-top {
                        -webkit-transition: none;
                        -webkit-animation: animate-shadow-top-z-1-z-2 0.7s infinite alternate;
                    }
                    .paper-shadow-animate-z-1-z-2 .paper-shadow-bottom {
                        -webkit-transition: none;
                        -webkit-animation: animate-shadow-bottom-z-1-z-2 0.7s infinite alternate;
                    }
                    @-webkit-keyframes animate-shadow-top-z-1-z-2 {
                        0% {
                            box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.16);
                        }
                        100% {
                            box-shadow: 0 6px 20px 0 rgba(0, 0, 0, 0.19);
                        }
                    }
                    @-webkit-keyframes animate-shadow-bottom-z-1-z-2 {
                        0% {
                            box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
                        }
                        100% {
                            box-shadow: 0 8px 17px 0 rgba(0, 0, 0, 0.2);
                        }
                    }
                </style>

            </template>

            <script>
                Polymer('paper-shadow', {

                    publish: {
                        /**
                         * If set, the shadow is applied to this node.
                         *
                         * @attribute target
                         * @type Element
                         * @default null
                         */
                        target: {
                            value: null,
                            reflect: true
                        },

                        /**
                         * The z-depth of this shadow, from 0-5.
                         *
                         * @attribute z
                         * @type number
                         * @default 1
                         */
                        z: {
                            value: 1,
                            reflect: true
                        },

                        /**
                         * If true, the shadow animates between z-depth changes.
                         *
                         * @attribute animated
                         * @type boolean
                         * @default false
                         */
                        animated: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * Workaround: getComputedStyle is wrong sometimes so `paper-shadow`
                         * may overwrite the `position` CSS property. Set this property to
                         * true to prevent this.
                         *
                         * @attribute hasPosition
                         * @type boolean
                         * @default false
                         */
                        hasPosition: false
                    },

                    // NOTE: include template so that styles are loaded, but remove
                    // so that we can decide dynamically what part to include
                    registerCallback: function (polymerElement) {
                        var template = polymerElement.querySelector('template');
                        this._style = template.content.querySelector('style');
                        this._style.removeAttribute('no-shim');
                    },

                    fetchTemplate: function () {
                        return null;
                    },

                    attached: function () {
                        // If no target is bound at attach, default the target to the parent
                        // element or shadow host.
                        if (!this.target) {
                            if (!this.parentElement && this.parentNode.host) {
                                this.target = this.parentNode.host;
                            } else if (this.parentElement && (window.ShadowDOMPolyfill ? this.parentElement !== wrap(document.body) : this.parentElement !== document.body)) {
                                this.target = this.parentElement;
                            }
                        }
                    },

                    targetChanged: function (old) {
                        if (old) {
                            this.removeShadow(old);
                        }
                        if (this.target) {
                            this.addShadow(this.target);
                        }
                    },

                    zChanged: function (old) {
                        if (this.target && this.target._paperShadow) {
                            var shadow = this.target._paperShadow;
          ['top', 'bottom'].forEach(function (s) {
                                shadow[s].classList.remove('paper-shadow-' + s + '-z-' + old);
                                shadow[s].classList.add('paper-shadow-' + s + '-z-' + this.z);
                            }.bind(this));
                        }
                    },

                    animatedChanged: function () {
                        if (this.target && this.target._paperShadow) {
                            var shadow = this.target._paperShadow;
          ['top', 'bottom'].forEach(function (s) {
                                if (this.animated) {
                                    shadow[s].classList.add('paper-shadow-animated');
                                } else {
                                    shadow[s].classList.remove('paper-shadow-animated');
                                }
                            }.bind(this));
                        }
                    },

                    addShadow: function (node) {
                        if (node._paperShadow) {
                            return;
                        }

                        if (!node._hasShadowStyle) {
                            if (!node.shadowRoot) {
                                node.createShadowRoot().innerHTML = '<content></content>';
                            }
                            this.installScopeStyle(this._style, 'shadow', node.shadowRoot);
                            node._hasShadowStyle = true;
                        }

                        var computed = getComputedStyle(node);
                        if (!this.hasPosition && computed.position === 'static') {
                            node.style.position = 'relative';
                        }
                        node.style.overflow = 'visible';

                        // Both the top and bottom shadows are children of the target, so
                        // it does not affect the classes and CSS properties of the target.
        ['top', 'bottom'].forEach(function (s) {
                            var inner = (node._paperShadow && node._paperShadow[s]) || document.createElement('div');
                            inner.classList.add('paper-shadow');
                            inner.classList.add('paper-shadow-' + s + '-z-' + this.z);
                            if (this.animated) {
                                inner.classList.add('paper-shadow-animated');
                            }

                            if (node.shadowRoot) {
                                node.shadowRoot.insertBefore(inner, node.shadowRoot.firstChild);
                            } else {
                                node.insertBefore(inner, node.firstChild);
                            }

                            node._paperShadow = node._paperShadow || {};
                            node._paperShadow[s] = inner;
                        }.bind(this));

                    },

                    removeShadow: function (node) {
                        if (!node._paperShadow) {
                            return;
                        }

        ['top', 'bottom'].forEach(function (s) {
                            node._paperShadow[s].remove();
                        });
                        node._paperShadow = null;

                        node.style.position = null;
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="paper-focusable" attributes="active focused disabled isToggle" tabindex="0" on-down="{{downAction}}" on-up="{{upAction}}" on-focus="{{focusAction}}" on-blur="{{blurAction}}" on-contextmenu="{{contextMenuAction}}" assetpath="bower_components/paper-focusable/">

            <template>
                <style>
                    :host([disabled]) {
                        pointer-events: none;
                    }
                </style>
                <content></content>
            </template>

            <script>
                Polymer('paper-focusable', {

                    publish: {

                        /**
                         * If true, the button is currently active either because the
                         * user is holding down the button, or the button is a toggle
                         * and is currently in the active state.
                         *
                         * @attribute active
                         * @type boolean
                         * @default false
                         */
                        active: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * If true, the element currently has focus due to keyboard
                         * navigation.
                         *
                         * @attribute focused
                         * @type boolean
                         * @default false
                         */
                        focused: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * If true, the user is currently holding down the button.
                         *
                         * @attribute pressed
                         * @type boolean
                         * @default false
                         */
                        pressed: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * If true, the user cannot interact with this element.
                         *
                         * @attribute disabled
                         * @type boolean
                         * @default false
                         */
                        disabled: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * If true, the button toggles the active state with each tap.
                         * Otherwise, the button becomes active when the user is holding
                         * it down.
                         *
                         * @attribute isToggle
                         * @type boolean
                         * @default false
                         */
                        isToggle: {
                            value: false,
                            reflect: false
                        }

                    },

                    disabledChanged: function () {
                        if (this.disabled) {
                            this.removeAttribute('tabindex');
                        } else {
                            this.setAttribute('tabindex', 0);
                        }
                    },

                    downAction: function () {
                        this.pressed = true;

                        if (this.isToggle) {
                            this.active = !this.active;
                        } else {
                            this.active = true;
                        }
                    },

                    // Pulling up the context menu for an item should focus it; but we need to
                    // be careful about how we deal with down/up events surrounding context
                    // menus. The up event typically does not fire until the context menu
                    // closes: so we focus immediately.
                    //
                    // This fires _after_ downAction.
                    contextMenuAction: function (e) {
                        // Note that upAction may fire _again_ on the actual up event.
                        this.upAction(e);
                        this.focusAction();
                    },

                    upAction: function () {
                        this.pressed = false;

                        if (!this.isToggle) {
                            this.active = false;
                        }
                    },

                    focusAction: function () {
                        if (!this.pressed) {
                            // Only render the "focused" state if the element gains focus due to
                            // keyboard navigation.
                            this.focused = true;
                        }
                    },

                    blurAction: function () {
                        this.focused = false;
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-button-base" extends="paper-focusable" assetpath="bower_components/paper-button/">

            <script>
                Polymer('paper-button-base', {

                    z: 1,

                    activeChanged: function () {
                        this.super();

                        if (this.active) {
                            // FIXME: remove when paper-ripple can have a default 'down' state.
                            if (!this.lastEvent) {
                                var rect = this.getBoundingClientRect();
                                this.lastEvent = {
                                    x: rect.left + rect.width / 2,
                                    y: rect.top + rect.height / 2
                                }
                            }
                            this.$.ripple.downAction(this.lastEvent);
                        } else {
                            this.$.ripple.upAction();
                        }
                        this.adjustZ();
                    },

                    disabledChanged: function () {
                        this.super();
                        if (this.disabled) {
                            this.setAttribute('aria-disabled', '');
                        } else {
                            this.removeAttribute('aria-disabled');
                        }
                        this.adjustZ();
                    },

                    recenteringTouchChanged: function () {
                        if (this.$.ripple) {
                            this.$.ripple.classList.toggle('recenteringTouch', this.recenteringTouch);
                        }
                    },

                    fillChanged: function () {
                        if (this.$.ripple) {
                            this.$.ripple.classList.toggle('fill', this.fill);
                        }
                    },

                    adjustZ: function () {
                        if (this.active) {
                            this.z = 2;
                        } else if (this.disabled) {
                            this.z = 0;
                        } else {
                            this.z = 1;
                        }
                    },

                    downAction: function (e) {
                        this.super(e);
                        this.lastEvent = e;
                        if (!this.$.ripple) {
                            var ripple = document.createElement('paper-ripple');
                            ripple.setAttribute('id', 'ripple');
                            ripple.setAttribute('fit', '');
                            if (this.recenteringTouch) {
                                ripple.classList.add('recenteringTouch');
                            }
                            if (!this.fill) {
                                ripple.classList.add('circle');
                            }
                            this.$.ripple = ripple;
                            this.shadowRoot.insertBefore(ripple, this.shadowRoot.firstChild);
                            // No need to forward the event to the ripple because the ripple
                            // is triggered in activeChanged
                        }
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-button" extends="paper-button-base" attributes="raised recenteringTouch fill" role="button" assetpath="bower_components/paper-button/">

            <template>

                <style>
                    :host {
                        display: inline-block;
                        position: relative;
                        box-sizing: border-box;
                        min-width: 5.14em;
                        padding: 0.7em 0.57em;
                        margin: 0 0.29em;
                        background: transparent;
                        text-align: center;
                        font: inherit;
                        text-transform: uppercase;
                        outline: none;
                        border-radius: 3px;
                        -webkit-user-select: none;
                        user-select: none;
                        cursor: pointer;
                        z-index: 0;
                    }
                    :host([disabled]) {
                        background: #eaeaea !important;
                        color: #a8a8a8 !important;
                        cursor: auto;
                        pointer-events: none;
                    }
                    ::content * {
                        text-transform: inherit;
                    }
                    #ripple {
                        pointer-events: none;
                        z-index: -1;
                    }
                </style>

                <template if="{{raisedButton || raised}}">
                    <paper-shadow id="shadow" z="{{z}}" animated=""></paper-shadow>
                </template>

                <!-- this div is needed to position the ripple behind text content -->
                <div relative="">
                    <content></content>
                    {{label}}
                </div>

            </template>

            <script>
                Polymer('paper-button', {

                    publish: {

                        label: '',

                        /**
                         * If true, the button will be styled with a shadow.
                         *
                         * @attribute raised
                         * @type boolean
                         * @default false
                         */
                        raised: false,
                        raisedButton: false,

                        /**
                         * By default the ripple emanates from where the user touched the button.
                         * Set this to true to always center the ripple.
                         *
                         * @attribute recenteringTouch
                         * @type boolean
                         * @default false
                         */
                        recenteringTouch: false,

                        /**
                         * By default the ripple expands to fill the button. Set this to true to
                         * constrain the ripple to a circle within the button.
                         *
                         * @attribute fill
                         * @type boolean
                         * @default true
                         */
                        fill: true

                    },

                    labelChanged: function () {
                        if (this.label) {
                            console.warn('The "label" property is deprecated.');
                        }
                    },

                    raisedButtonChanged: function () {
                        if (this.raisedButton) {
                            console.warn('The "raisedButton" property is deprecated.');
                        }
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-a11y-keys" assetpath="bower_components/core-a11y-keys/">
            <script>
                (function () {
                    /*
                     * Chrome uses an older version of DOM Level 3 Keyboard Events
                     *
                     * Most keys are labeled as text, but some are Unicode codepoints.
                     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
                     */
                    var KEY_IDENTIFIER = {
                        'U+0009': 'tab',
                        'U+001B': 'esc',
                        'U+0020': 'space',
                        'U+002A': '*',
                        'U+0030': '0',
                        'U+0031': '1',
                        'U+0032': '2',
                        'U+0033': '3',
                        'U+0034': '4',
                        'U+0035': '5',
                        'U+0036': '6',
                        'U+0037': '7',
                        'U+0038': '8',
                        'U+0039': '9',
                        'U+0041': 'a',
                        'U+0042': 'b',
                        'U+0043': 'c',
                        'U+0044': 'd',
                        'U+0045': 'e',
                        'U+0046': 'f',
                        'U+0047': 'g',
                        'U+0048': 'h',
                        'U+0049': 'i',
                        'U+004A': 'j',
                        'U+004B': 'k',
                        'U+004C': 'l',
                        'U+004D': 'm',
                        'U+004E': 'n',
                        'U+004F': 'o',
                        'U+0050': 'p',
                        'U+0051': 'q',
                        'U+0052': 'r',
                        'U+0053': 's',
                        'U+0054': 't',
                        'U+0055': 'u',
                        'U+0056': 'v',
                        'U+0057': 'w',
                        'U+0058': 'x',
                        'U+0059': 'y',
                        'U+005A': 'z',
                        'U+007F': 'del'
                    };

                    /*
                     * Special table for KeyboardEvent.keyCode.
                     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better than that
                     *
                     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
                     */
                    var KEY_CODE = {
                        13: 'enter',
                        27: 'esc',
                        33: 'pageup',
                        34: 'pagedown',
                        35: 'end',
                        36: 'home',
                        32: 'space',
                        37: 'left',
                        38: 'up',
                        39: 'right',
                        40: 'down',
                        46: 'del',
                        106: '*'
                    };

                    /*
                     * KeyboardEvent.key is mostly represented by printable character made by the keyboard, with unprintable keys labeled
                     * nicely.
                     *
                     * However, on OS X, Alt+char can make a Unicode character that follows an Apple-specific mapping. In this case, we
                     * fall back to .keyCode.
                     */
                    var KEY_CHAR = /[a-z0-9*]/;

                    function transformKey(key) {
                        var validKey = '';
                        if (key) {
                            var lKey = key.toLowerCase();
                            if (lKey.length == 1) {
                                if (KEY_CHAR.test(lKey)) {
                                    validKey = lKey;
                                }
                            } else if (lKey == 'multiply') {
                                // numpad '*' can map to Multiply on IE/Windows
                                validKey = '*';
                            } else {
                                validKey = lKey;
                            }
                        }
                        return validKey;
                    }

                    var IDENT_CHAR = /U\+/;

                    function transformKeyIdentifier(keyIdent) {
                        var validKey = '';
                        if (keyIdent) {
                            if (IDENT_CHAR.test(keyIdent)) {
                                validKey = KEY_IDENTIFIER[keyIdent];
                            } else {
                                validKey = keyIdent.toLowerCase();
                            }
                        }
                        return validKey;
                    }

                    function transformKeyCode(keyCode) {
                        var validKey = '';
                        if (Number(keyCode)) {
                            if (keyCode >= 65 && keyCode <= 90) {
                                // ascii a-z
                                // lowercase is 32 offset from uppercase
                                validKey = String.fromCharCode(32 + keyCode);
                            } else if (keyCode >= 112 && keyCode <= 123) {
                                // function keys f1-f12
                                validKey = 'f' + (keyCode - 112);
                            } else if (keyCode >= 48 && keyCode <= 57) {
                                // top 0-9 keys
                                validKey = String(48 - keyCode);
                            } else if (keyCode >= 96 && keyCode <= 105) {
                                // num pad 0-9
                                validKey = String(96 - keyCode);
                            } else {
                                validKey = KEY_CODE[keyCode];
                            }
                        }
                        return validKey;
                    }

                    function keyboardEventToKey(ev) {
                        // fall back from .key, to .keyIdentifier, and then to .keyCode
                        var normalizedKey = transformKey(ev.key) || transformKeyIdentifier(ev.keyIdentifier) || transformKeyCode(ev.keyCode) || '';
                        return {
                            shift: ev.shiftKey,
                            ctrl: ev.ctrlKey,
                            meta: ev.metaKey,
                            alt: ev.altKey,
                            key: normalizedKey
                        };
                    }

                    /*
                     * Input: ctrl+shift+f7 => {ctrl: true, shift: true, key: 'f7'}
                     * ctrl/space => {ctrl: true} || {key: space}
                     */
                    function stringToKey(keyCombo) {
                        var keys = keyCombo.split('+');
                        var keyObj = Object.create(null);
                        keys.forEach(function (key) {
                            if (key == 'shift') {
                                keyObj.shift = true;
                            } else if (key == 'ctrl') {
                                keyObj.ctrl = true;
                            } else if (key == 'alt') {
                                keyObj.alt = true;
                            } else {
                                keyObj.key = key;
                            }
                        });
                        return keyObj;
                    }

                    function keyMatches(a, b) {
                        return Boolean(a.alt) == Boolean(b.alt) && Boolean(a.ctrl) == Boolean(b.ctrl) && Boolean(a.shift) == Boolean(b.shift) && a.key === b.key;
                    }

                    /**
                     * Fired when a keycombo in `keys` is pressed.
                     *
                     * @event keys-pressed
                     */
                    function processKeys(ev) {
                        var current = keyboardEventToKey(ev);
                        for (var i = 0, dk; i < this._desiredKeys.length; i++) {
                            dk = this._desiredKeys[i];
                            if (keyMatches(dk, current)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.fire('keys-pressed', current, this, false);
                                break;
                            }
                        }
                    }

                    function listen(node, handler) {
                        if (node && node.addEventListener) {
                            node.addEventListener('keydown', handler);
                        }
                    }

                    function unlisten(node, handler) {
                        if (node && node.removeEventListener) {
                            node.removeEventListener('keydown', handler);
                        }
                    }

                    Polymer('core-a11y-keys', {
                        created: function () {
                            this._keyHandler = processKeys.bind(this);
                        },
                        attached: function () {
                            listen(this.target, this._keyHandler);
                        },
                        detached: function () {
                            unlisten(this.target, this._keyHandler);
                        },
                        publish: {
                            /**
                             * The set of key combinations to listen for.
                             *
                             * @attribute keys
                             * @type string (keys syntax)
                             * @default ''
                             */
                            keys: '',
                            /**
                             * The node that will fire keyboard events.
                             *
                             * @attribute target
                             * @type Node
                             * @default null
                             */
                            target: null
                        },
                        keysChanged: function () {
                            // * can have multiple mappings: shift+8, * on numpad or Multiply on numpad
                            var normalized = this.keys.replace('*', '* shift+*');
                            this._desiredKeys = normalized.toLowerCase().split(' ').map(stringToKey);
                        },
                        targetChanged: function (oldTarget) {
                            unlisten(oldTarget, this._keyHandler);
                            listen(this.target, this._keyHandler);
                        }
                    });
                })();
            </script>
        </polymer-element>
        <polymer-element name="paper-radio-button" role="radio" tabindex="0" aria-checked="false" assetpath="bower_components/paper-radio-button/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                        white-space: nowrap;
                    }
                    :host(:focus) {
                        outline: none;
                    }
                    #radioContainer {
                        position: relative;
                        width: 16px;
                        height: 16px;
                        cursor: pointer;
                    }
                    #radioContainer.labeled {
                        display: inline-block;
                        vertical-align: middle;
                    }
                    #ink {
                        position: absolute;
                        top: -16px;
                        left: -16px;
                        width: 48px;
                        height: 48px;
                        color: #5a5a5a;
                    }
                    #ink[checked] {
                        color: #0f9d58;
                    }
                    #offRadio {
                        position: absolute;
                        top: 0px;
                        left: 0px;
                        width: 12px;
                        height: 12px;
                        border-radius: 50%;
                        border: solid 2px;
                        border-color: #5a5a5a;
                    }
                    #onRadio {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 16px;
                        height: 16px;
                        border-radius: 50%;
                        background-color: #0f9d58;
                        -webkit-transform: scale(0);
                        transform: scale(0);
                        transition: -webkit-transform ease 0.28s;
                        transition: transform ease 0.28s;
                    }
                    #onRadio.fill {
                        -webkit-transform: scale(1.1);
                        transform: scale(1.1);
                    }
                    #radioLabel {
                        position: relative;
                        display: inline-block;
                        vertical-align: middle;
                        margin-left: 10px;
                        white-space: normal;
                        pointer-events: none;
                    }
                    #radioLabel[hidden] {
                        display: none;
                    }
                    /* disabled state */
                    :host([disabled]) {
                        pointer-events: none;
                    }
                    :host([disabled]) #onRadio {
                        display: none;
                    }
                    :host([disabled]) #offRadio {
                        opacity: 0.33;
                        border-color: #5a5a5a;
                    }
                    :host([disabled][checked]) #offRadio {
                        opacity: 0.33;
                        background-color: #5a5a5a;
                    }
                </style>

                <core-a11y-keys target="{{}}" keys="space" on-keys-pressed="{{tap}}"></core-a11y-keys>

                <div id="radioContainer" class="{{ {labeled: label} | tokenList }}">

                    <div id="offRadio"></div>
                    <div id="onRadio"></div>

                    <paper-ripple id="ink" class="circle recenteringTouch" checked?="{{!checked}}"></paper-ripple>

                </div>

                <div id="radioLabel" aria-hidden="true" hidden?="{{!label}}">{{label}}
                    <content></content>
                </div>

            </template>
            <script>
                Polymer('paper-radio-button', {

                    /**
                     * Fired when the checked state changes due to user interaction.
                     *
                     * @event change
                     */

                    /**
                     * Fired when the checked state changes.
                     *
                     * @event core-change
                     */

                    publish: {
                        /**
                         * Gets or sets the state, `true` is checked and `false` is unchecked.
                         *
                         * @attribute checked
                         * @type boolean
                         * @default false
                         */
                        checked: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * The label for the radio button.
                         *
                         * @attribute label
                         * @type string
                         * @default ''
                         */
                        label: '',

                        /**
                         * Normally the user cannot uncheck the radio button by tapping once
                         * checked.  Setting this property to `true` makes the radio button
                         * toggleable from checked to unchecked.
                         *
                         * @attribute toggles
                         * @type boolean
                         * @default false
                         */
                        toggles: false,

                        /**
                         * If true, the user cannot interact with this element.
                         *
                         * @attribute disabled
                         * @type boolean
                         * @default false
                         */
                        disabled: {
                            value: false,
                            reflect: true
                        }
                    },

                    eventDelegates: {
                        tap: 'tap'
                    },

                    tap: function () {
                        var old = this.checked;
                        this.toggle();
                        if (this.checked !== old) {
                            this.fire('change');
                        }
                    },

                    toggle: function () {
                        this.checked = !this.toggles || !this.checked;
                    },

                    checkedChanged: function () {
                        this.$.onRadio.classList.toggle('fill', this.checked);
                        this.setAttribute('aria-checked', this.checked ? 'true' : 'false');
                        this.fire('core-change');
                    },

                    labelChanged: function () {
                        this.setAttribute('aria-label', this.label);
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-checkbox" extends="paper-radio-button" role="checkbox" assetpath="bower_components/paper-checkbox/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                        white-space: nowrap;
                    }
                    :host(:focus) {
                        outline: none;
                    }
                    #checkboxContainer {
                        position: relative;
                        width: 18px;
                        height: 18px;
                        cursor: pointer;
                        -webkit-transform: translateZ(0);
                        transform: translateZ(0);
                    }
                    #checkboxContainer.labeled {
                        display: inline-block;
                        vertical-align: middle;
                    }
                    #ink {
                        position: absolute;
                        top: -15px;
                        left: -15px;
                        width: 48px;
                        height: 48px;
                        color: #5a5f5a;
                    }
                    #ink[checked] {
                        color: #0f9d58;
                    }
                    #checkbox {
                        position: absolute;
                        box-sizing: border-box;
                        top: 0px;
                        left: 0px;
                        width: 18px;
                        height: 18px;
                        border: solid 2px;
                        border-color: #5a5a5a;
                        pointer-events: none;
                    }
                    /* checkbox checked animations */
                    #checkbox.checked.box {
                        border: solid 2px;
                        -webkit-animation: box-shrink 140ms ease-out forwards;
                        animation: box-shrink 140ms ease-out forwards;
                    }
                    @-webkit-keyframes box-shrink {
                        0% {
                            -webkit-transform: rotate(0deg);
                            top: 0px;
                            left: 0px;
                            width: 18px;
                            height: 18px;
                        }
                        100% {
                            -webkit-transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                    }
                    @keyframes box-shrink {
                        0% {
                            transform: rotate(0deg);
                            top: 0px;
                            left: 0px;
                            width: 18px;
                            height: 18px;
                        }
                        100% {
                            transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                    }
                    #checkbox.checked.checkmark {
                        border-left: none;
                        border-top: none;
                        -webkit-animation: checkmark-expand 140ms ease-out forwards;
                        animation: checkmark-expand 140ms ease-out forwards;
                    }
                    @-webkit-keyframes checkmark-expand {
                        0% {
                            -webkit-transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                        100% {
                            -webkit-transform: rotate(45deg);
                            top: -4px;
                            left: 6px;
                            width: 10px;
                            height: 21px;
                            border-right-width: 2px;
                            border-bottom-width: 2px;
                        }
                    }
                    @keyframes checkmark-expand {
                        0% {
                            transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                        100% {
                            transform: rotate(45deg);
                            top: -4px;
                            left: 6px;
                            width: 10px;
                            height: 21px;
                            border-right-width: 2px;
                            border-bottom-width: 2px;
                        }
                    }
                    #checkbox.checked {
                        -webkit-transform: rotate(45deg);
                        transform: rotate(45deg);
                        top: -4px;
                        left: 6px;
                        width: 10px;
                        height: 21px;
                        border-top: none;
                        border-left: none;
                        border-right-width: 2px;
                        border-bottom-width: 2px;
                        border-color: #0f9d58;
                    }
                    /* checkbox unchecked animations */
                    #checkbox.unchecked.checkmark {
                        -webkit-transform: rotate(45deg);
                        transform: rotate(45deg);
                        border-left: none;
                        border-top: none;
                        -webkit-animation: checkmark-shrink 140ms ease-out forwards;
                        animation: checkmark-shrink 140ms ease-out forwards;
                    }
                    @-webkit-keyframes checkmark-shrink {
                        0% {
                            top: -4px;
                            left: 6px;
                            width: 10px;
                            height: 21px;
                            border-right-width: 2px;
                            border-bottom-width: 2px;
                        }
                        100% {
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                    }
                    @keyframes checkmark-shrink {
                        0% {
                            top: -4px;
                            left: 6px;
                            width: 10px;
                            height: 21px;
                            border-right-width: 2px;
                            border-bottom-width: 2px;
                        }
                        100% {
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                    }
                    #checkbox.unchecked.box {
                        -webkit-animation: box-expand 140ms ease-out forwards;
                        animation: box-expand 140ms ease-out forwards;
                    }
                    @-webkit-keyframes box-expand {
                        0% {
                            -webkit-transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                        100% {
                            -webkit-transform: rotate(0deg);
                            top: 0px;
                            left: 0px;
                            width: 18px;
                            height: 18px;
                        }
                    }
                    @keyframes box-expand {
                        0% {
                            transform: rotate(45deg);
                            top: 13px;
                            left: 5px;
                            width: 4px;
                            height: 4px;
                        }
                        100% {
                            transform: rotate(0deg);
                            top: 0px;
                            left: 0px;
                            width: 18px;
                            height: 18px;
                        }
                    }
                    /* label */
                    #checkboxLabel {
                        position: relative;
                        display: inline-block;
                        vertical-align: middle;
                        padding-left: 8px;
                        white-space: normal;
                        pointer-events: none;
                    }
                    #checkboxLabel[hidden] {
                        display: none;
                    }
                    /* disabled state */
                    :host([disabled]) {
                        pointer-events: none;
                    }
                    :host([disabled]) #checkbox {
                        opacity: 0.33;
                        border-color: #5a5a5a;
                    }
                </style>

                <div id="checkboxContainer" class="{{ {labeled: label} | tokenList }}">

                    <paper-ripple id="ink" class="circle recenteringTouch" checked?="{{!checked}}"></paper-ripple>

                    <div id="checkbox" on-animationend="{{checkboxAnimationEnd}}" on-webkitanimationend="{{checkboxAnimationEnd}}"></div>

                </div>

                <div id="checkboxLabel" hidden?="{{!label}}">{{label}}
                    <content></content>
                </div>

            </template>
            <script>
                Polymer('paper-checkbox', {

                    /**
                     * Fired when the checked state changes due to user interaction.
                     *
                     * @event change
                     */

                    /**
                     * Fired when the checked state changes.
                     *
                     * @event core-change
                     */

                    toggles: true,

                    checkedChanged: function () {
                        var cl = this.$.checkbox.classList;
                        cl.toggle('checked', this.checked);
                        cl.toggle('unchecked', !this.checked);
                        cl.toggle('checkmark', !this.checked);
                        cl.toggle('box', this.checked);
                        this.setAttribute('aria-checked', this.checked ? 'true' : 'false');
                        this.fire('core-change');
                    },

                    checkboxAnimationEnd: function () {
                        var cl = this.$.checkbox.classList;
                        cl.toggle('checkmark', this.checked && !cl.contains('checkmark'));
                        cl.toggle('box', !this.checked && !cl.contains('box'));
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-transition" extends="core-meta" assetpath="bower_components/core-transition/">

            <script>
                Polymer('core-transition', {

                    type: 'transition',

                    /**
                     * Run the animation.
                     *
                     * @method go
                     * @param {Node} node The node to apply the animation on
                     * @param {Object} state State info
                     */
                    go: function (node, state) {
                        this.complete(node);
                    },

                    /**
                     * Set up the animation. This may include injecting a stylesheet,
                     * applying styles, creating a web animations object, etc.. This
                     *
                     * @method setup
                     * @param {Node} node The animated node
                     */
                    setup: function (node) {},

                    /**
                     * Tear down the animation.
                     *
                     * @method teardown
                     * @param {Node} node The animated node
                     */
                    teardown: function (node) {},

                    /**
                     * Called when the animation completes. This function also fires the
                     * `core-transitionend` event.
                     *
                     * @method complete
                     * @param {Node} node The animated node
                     */
                    complete: function (node) {
                        this.fire('core-transitionend', null, node);
                    },

                    /**
                     * Utility function to listen to an event on a node once.
                     *
                     * @method listenOnce
                     * @param {Node} node The animated node
                     * @param {string} event Name of an event
                     * @param {Function} fn Event handler
                     * @param {Array} args Additional arguments to pass to `fn`
                     */
                    listenOnce: function (node, event, fn, args) {
                        var self = this;
                        var listener = function () {
                            fn.apply(self, args);
                            node.removeEventListener(event, listener, false);
                        }
                        node.addEventListener(event, listener, false);
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="core-key-helper" assetpath="bower_components/core-overlay/">
            <script>
                Polymer('core-key-helper', {
                    ENTER_KEY: 13,
                    ESCAPE_KEY: 27
                });
            </script>
        </polymer-element>

        <polymer-element name="core-overlay-layer" assetpath="bower_components/core-overlay/">
            <template>
                <style>
                    :host {
                        position: fixed;
                        top: 0;
                        left: 0;
                        z-index: 1000;
                        display: none;
                    }
                    :host(.core-opened) {
                        display: block;
                    }
                </style>
                <content></content>
            </template>
            <script>
                (function () {

                    Polymer('core-overlay-layer', {
                        publish: {
                            opened: false
                        },
                        openedChanged: function () {
                            this.classList.toggle('core-opened', this.opened);
                        },
                        /**
                         * Adds an element to the overlay layer
                         */
                        addElement: function (element) {
                            if (!this.parentNode) {
                                document.querySelector('body').appendChild(this);
                            }
                            if (element.parentNode !== this) {
                                element.__contents = [];
                                var ip$ = element.querySelectorAll('content');
                                for (var i = 0, l = ip$.length, n;
                                    (i < l) && (n = ip$[i]); i++) {
                                    this.moveInsertedElements(n);
                                    this.cacheDomLocation(n);
                                    n.parentNode.removeChild(n);
                                    element.__contents.push(n);
                                }
                                this.cacheDomLocation(element);
                                this.updateEventController(element);
                                var h = this.makeHost();
                                h.shadowRoot.appendChild(element);
                                element.__host = h;
                            }
                        },
                        makeHost: function () {
                            var h = document.createElement('overlay-host');
                            h.createShadowRoot();
                            this.appendChild(h);
                            return h;
                        },
                        moveInsertedElements: function (insertionPoint) {
                            var n$ = insertionPoint.getDistributedNodes();
                            var parent = insertionPoint.parentNode;
                            insertionPoint.__contents = [];
                            for (var i = 0, l = n$.length, n;
                                (i < l) && (n = n$[i]); i++) {
                                this.cacheDomLocation(n);
                                this.updateEventController(n);
                                insertionPoint.__contents.push(n);
                                parent.appendChild(n);
                            }
                        },
                        updateEventController: function (element) {
                            element.eventController = this.element.findController(element);
                        },
                        /**
                         * Removes an element from the overlay layer
                         */
                        removeElement: function (element) {
                            element.eventController = null;
                            this.replaceElement(element);
                            var h = element.__host;
                            if (h) {
                                h.parentNode.removeChild(h);
                            }
                        },
                        replaceElement: function (element) {
                            if (element.__contents) {
                                for (var i = 0, c$ = element.__contents, c;
                                    (c = c$[i]); i++) {
                                    this.replaceElement(c);
                                }
                                element.__contents = null;
                            }
                            if (element.__parentNode) {
                                var n = element.__nextElementSibling && element.__nextElementSibling === element.__parentNode ? element.__nextElementSibling : null;
                                element.__parentNode.insertBefore(element, n);
                            }
                        },
                        cacheDomLocation: function (element) {
                            element.__nextElementSibling = element.nextElementSibling;
                            element.__parentNode = element.parentNode;
                        }
                    });

                })();
            </script>
        </polymer-element>
        <polymer-element name="core-overlay" assetpath="bower_components/core-overlay/">
            <script>
                (function () {

                    Polymer('core-overlay', {

                        publish: {
                            /**
                             * The target element that will be shown when the overlay is
                             * opened. If unspecified, the core-overlay itself is the target.
                             *
                             * @attribute target
                             * @type Object
                             * @default the overlay element
                             */
                            target: null,


                            /**
                             * A `core-overlay`'s size is guaranteed to be
                             * constrained to the window size. To achieve this, the sizingElement
                             * is sized with a max-height/width. By default this element is the
                             * target element, but it can be specifically set to a specific element
                             * inside the target if that is more appropriate. This is useful, for
                             * example, when a region inside the overlay should scroll if needed.
                             *
                             * @attribute sizingTarget
                             * @type Object
                             * @default the target element
                             */
                            sizingTarget: null,

                            /**
                             * Set opened to true to show an overlay and to false to hide it.
                             * A `core-overlay` may be made initially opened by setting its
                             * `opened` attribute.
                             * @attribute opened
                             * @type boolean
                             * @default false
                             */
                            opened: false,

                            /**
                             * If true, the overlay has a backdrop darkening the rest of the screen.
                             * The backdrop element is attached to the document body and may be styled
                             * with the class `core-overlay-backdrop`. When opened the `core-opened`
                             * class is applied.
                             *
                             * @attribute backdrop
                             * @type boolean
                             * @default false
                             */
                            backdrop: false,

                            /**
                             * If true, the overlay is guaranteed to display above page content.
                             *
                             * @attribute layered
                             * @type boolean
                             * @default false
                             */
                            layered: false,

                            /**
                             * By default an overlay will close automatically if the user
                             * taps outside it or presses the escape key. Disable this
                             * behavior by setting the `autoCloseDisabled` property to true.
                             * @attribute autoCloseDisabled
                             * @type boolean
                             * @default false
                             */
                            autoCloseDisabled: false,

                            /**
                             * By default an overlay will focus its target or an element inside
                             * it with the `autoFocus` attribute. Disable this
                             * behavior by setting the `autoFocusDisabled` property to true.
                             * @attribute autoFocusDisabled
                             * @type boolean
                             * @default false
                             */
                            autoFocusDisabled: false,

                            /**
                             * This property specifies an attribute on elements that should
                             * close the overlay on tap. Should not set `closeSelector` if this
                             * is set.
                             *
                             * @attribute closeAttribute
                             * @type string
                             * @default "core-overlay-toggle"
                             */
                            closeAttribute: 'core-overlay-toggle',

                            /**
                             * This property specifies a selector matching elements that should
                             * close the overlay on tap. Should not set `closeAttribute` if this
                             * is set.
                             *
                             * @attribute closeSelector
                             * @type string
                             * @default ""
                             */
                            closeSelector: '',

                            /**
                             * The transition property specifies a string which identifies a
                             * <a href="../core-transition/">`core-transition`</a> element that
                             * will be used to help the overlay open and close. The default
                             * `core-transition-fade` will cause the overlay to fade in and out.
                             *
                             * @attribute transition
                             * @type string
                             * @default 'core-transition-fade'
                             */
                            transition: 'core-transition-fade'

                        },

                        captureEventName: 'tap',
                        targetListeners: {
                            'tap': 'tapHandler',
                            'keydown': 'keydownHandler',
                            'core-transitionend': 'transitionend'
                        },

                        registerCallback: function (element) {
                            this.layer = document.createElement('core-overlay-layer');
                            this.keyHelper = document.createElement('core-key-helper');
                            this.meta = document.createElement('core-transition');
                            this.scrim = document.createElement('div');
                            this.scrim.className = 'core-overlay-backdrop';
                        },

                        ready: function () {
                            this.target = this.target || this;
                            // flush to ensure styles are installed before paint
                            Platform.flush();
                        },

                        /**
                         * Toggle the opened state of the overlay.
                         * @method toggle
                         */
                        toggle: function () {
                            this.opened = !this.opened;
                        },

                        /**
                         * Open the overlay. This is equivalent to setting the `opened`
                         * property to true.
                         * @method open
                         */
                        open: function () {
                            this.opened = true;
                        },

                        /**
                         * Close the overlay. This is equivalent to setting the `opened`
                         * property to false.
                         * @method close
                         */
                        close: function () {
                            this.opened = false;
                        },

                        domReady: function () {
                            this.ensureTargetSetup();
                        },

                        targetChanged: function (old) {
                            if (this.target) {
                                // really make sure tabIndex is set
                                if (this.target.tabIndex < 0) {
                                    this.target.tabIndex = -1;
                                }
                                this.addElementListenerList(this.target, this.targetListeners);
                                this.target.style.display = 'none';
                                this.target.__overlaySetup = false;
                            }
                            if (old) {
                                this.removeElementListenerList(old, this.targetListeners);
                                var transition = this.getTransition();
                                if (transition) {
                                    transition.teardown(old);
                                } else {
                                    old.style.position = '';
                                    old.style.outline = '';
                                }
                                old.style.display = '';
                            }
                        },

                        transitionChanged: function (old) {
                            if (!this.target) {
                                return;
                            }
                            if (old) {
                                this.getTransition(old).teardown(this.target);
                            }
                            this.target.__overlaySetup = false;
                        },

                        // NOTE: wait to call this until we're as sure as possible that target
                        // is styled.
                        ensureTargetSetup: function () {
                            if (!this.target || this.target.__overlaySetup) {
                                return;
                            }
                            if (!this.sizingTarget) {
                                this.sizingTarget = this.target;
                            }
                            this.target.__overlaySetup = true;
                            this.target.style.display = '';
                            var transition = this.getTransition();
                            if (transition) {
                                transition.setup(this.target);
                            }
                            var style = this.target.style;
                            var computed = getComputedStyle(this.target);
                            if (computed.position === 'static') {
                                style.position = 'fixed';
                            }
                            style.outline = 'none';
                            style.display = 'none';
                        },

                        openedChanged: function () {
                            this.transitioning = true;
                            this.ensureTargetSetup();
                            this.prepareRenderOpened();
                            // async here to allow overlay layer to become visible.
                            this.async(function () {
                                this.target.style.display = '';
                                // force layout to ensure transitions will go
                                this.target.offsetWidth;
                                this.renderOpened();
                            });
                            this.fire('core-overlay-open', this.opened);
                        },

                        // tasks which must occur before opening; e.g. making the element visible
                        prepareRenderOpened: function () {
                            if (this.opened) {
                                addOverlay(this);
                            }
                            this.prepareBackdrop();
                            // async so we don't auto-close immediately via a click.
                            this.async(function () {
                                if (!this.autoCloseDisabled) {
                                    this.enableElementListener(this.opened, document,
                                        this.captureEventName, 'captureHandler', true);
                                }
                            });
                            this.enableElementListener(this.opened, window, 'resize',
                                'resizeHandler');

                            if (this.opened) {
                                // force layout so SD Polyfill renders
                                this.target.offsetHeight;
                                this.discoverDimensions();
                                // if we are showing, then take care when positioning
                                this.preparePositioning();
                                this.positionTarget();
                                this.updateTargetDimensions();
                                this.finishPositioning();
                                if (this.layered) {
                                    this.layer.addElement(this.target);
                                    this.layer.opened = this.opened;
                                }
                            }
                        },

                        // tasks which cause the overlay to actually open; typically play an
                        // animation
                        renderOpened: function () {
                            var transition = this.getTransition();
                            if (transition) {
                                transition.go(this.target, {
                                    opened: this.opened
                                });
                            } else {
                                this.transitionend();
                            }
                            this.renderBackdropOpened();
                        },

                        // finishing tasks; typically called via a transition
                        transitionend: function (e) {
                            // make sure this is our transition event.
                            if (e && e.target !== this.target) {
                                return;
                            }
                            this.transitioning = false;
                            if (!this.opened) {
                                this.resetTargetDimensions();
                                this.target.style.display = 'none';
                                this.completeBackdrop();
                                removeOverlay(this);
                                if (this.layered) {
                                    if (!currentOverlay()) {
                                        this.layer.opened = this.opened;
                                    }
                                    this.layer.removeElement(this.target);
                                }
                            }
                            this.fire('core-overlay-' + (this.opened ? 'open' : 'close') +
                                '-completed');
                            this.applyFocus();
                        },

                        prepareBackdrop: function () {
                            if (this.backdrop && this.opened) {
                                if (!this.scrim.parentNode) {
                                    document.body.appendChild(this.scrim);
                                    this.scrim.style.zIndex = currentOverlayZ() - 1;
                                }
                                trackBackdrop(this);
                            }
                        },

                        renderBackdropOpened: function () {
                            if (this.backdrop && getBackdrops().length < 2) {
                                this.scrim.classList.toggle('core-opened', this.opened);
                            }
                        },

                        completeBackdrop: function () {
                            if (this.backdrop) {
                                trackBackdrop(this);
                                if (getBackdrops().length === 0) {
                                    this.scrim.parentNode.removeChild(this.scrim);
                                }
                            }
                        },

                        preparePositioning: function () {
                            this.target.style.transition = this.target.style.webkitTransition = 'none';
                            this.target.style.transform = this.target.style.webkitTransform = 'none';
                            this.target.style.display = '';
                        },

                        discoverDimensions: function () {
                            if (this.dimensions) {
                                return;
                            }
                            var target = getComputedStyle(this.target);
                            var sizer = getComputedStyle(this.sizingTarget);
                            this.dimensions = {
                                position: {
                                    v: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
                                        'bottom' : null),
                                    h: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
                                        'right' : null),
                                    css: target.position
                                },
                                size: {
                                    v: sizer.maxHeight !== 'none',
                                    h: sizer.maxWidth !== 'none'
                                },
                                margin: {
                                    top: parseInt(target.marginTop) || 0,
                                    right: parseInt(target.marginRight) || 0,
                                    bottom: parseInt(target.marginBottom) || 0,
                                    left: parseInt(target.marginLeft) || 0
                                }
                            };
                        },

                        finishPositioning: function (target) {
                            this.target.style.display = 'none';
                            this.target.style.transform = this.target.style.webkitTransform = '';
                            // force layout to avoid application of transform
                            this.target.offsetWidth;
                            this.target.style.transition = this.target.style.webkitTransition = '';
                        },

                        getTransition: function (name) {
                            return this.meta.byId(name || this.transition);
                        },

                        getFocusNode: function () {
                            return this.target.querySelector('[autofocus]') || this.target;
                        },

                        applyFocus: function () {
                            var focusNode = this.getFocusNode();
                            if (this.opened) {
                                if (!this.autoFocusDisabled) {
                                    focusNode.focus();
                                }
                            } else {
                                focusNode.blur();
                                if (currentOverlay() == this) {
                                    console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
                                } else {
                                    focusOverlay();
                                }
                            }
                        },

                        positionTarget: function () {
                            // fire positioning event
                            this.fire('core-overlay-position', {
                                target: this.target,
                                sizingTarget: this.sizingTarget,
                                opened: this.opened
                            });
                            if (!this.dimensions.position.v) {
                                this.target.style.top = '0px';
                            }
                            if (!this.dimensions.position.h) {
                                this.target.style.left = '0px';
                            }
                        },

                        updateTargetDimensions: function () {
                            this.sizeTarget();
                            this.repositionTarget();
                        },

                        sizeTarget: function () {
                            this.sizingTarget.style.boxSizing = 'border-box';
                            var dims = this.dimensions;
                            var rect = this.target.getBoundingClientRect();
                            if (!dims.size.v) {
                                this.sizeDimension(rect, dims.position.v, 'top', 'bottom', 'Height');
                            }
                            if (!dims.size.h) {
                                this.sizeDimension(rect, dims.position.h, 'left', 'right', 'Width');
                            }
                        },

                        sizeDimension: function (rect, positionedBy, start, end, extent) {
                            var dims = this.dimensions;
                            var flip = (positionedBy === end);
                            var m = flip ? start : end;
                            var ws = window['inner' + extent];
                            var o = dims.margin[m] + (flip ? ws - rect[end] :
                                rect[start]);
                            var offset = 'offset' + extent;
                            var o2 = this.target[offset] - this.sizingTarget[offset];
                            this.sizingTarget.style['max' + extent] = (ws - o - o2) + 'px';
                        },

                        // vertically and horizontally center if not positioned
                        repositionTarget: function () {
                            // only center if position fixed.
                            if (this.dimensions.position.css !== 'fixed') {
                                return;
                            }
                            if (!this.dimensions.position.v) {
                                var t = (window.innerHeight - this.target.offsetHeight) / 2;
                                t -= this.dimensions.margin.top;
                                this.target.style.top = t + 'px';
                            }

                            if (!this.dimensions.position.h) {
                                var l = (window.innerWidth - this.target.offsetWidth) / 2;
                                l -= this.dimensions.margin.left;
                                this.target.style.left = l + 'px';
                            }
                        },

                        resetTargetDimensions: function () {
                            if (!this.dimensions.size.v) {
                                this.sizingTarget.style.maxHeight = '';
                            }
                            if (!this.dimensions.size.h) {
                                this.sizingTarget.style.maxWidth = '';
                            }
                            this.dimensions = null;
                        },

                        tapHandler: function (e) {
                            // closeSelector takes precedence since closeAttribute has a default non-null value.
                            if (e.target &&
                                (this.closeSelector && e.target.matches(this.closeSelector)) ||
                                (this.closeAttribute && e.target.hasAttribute(this.closeAttribute))) {
                                this.toggle();
                            } else {
                                if (this.autoCloseJob) {
                                    this.autoCloseJob.stop();
                                    this.autoCloseJob = null;
                                }
                            }
                        },

                        // We use the traditional approach of capturing events on document
                        // to to determine if the overlay needs to close. However, due to
                        // ShadowDOM event retargeting, the event target is not useful. Instead
                        // of using it, we attempt to close asynchronously and prevent the close
                        // if a tap event is immediately heard on the target.
                        // TODO(sorvell): This approach will not work with modal. For
                        // this we need a scrim.
                        captureHandler: function (e) {
                            if (!this.autoCloseDisabled && (currentOverlay() == this)) {
                                this.autoCloseJob = this.job(this.autoCloseJob, function () {
                                    this.close();
                                });
                            }
                        },

                        keydownHandler: function (e) {
                            if (!this.autoCloseDisabled && (e.keyCode == this.keyHelper.ESCAPE_KEY)) {
                                this.close();
                                e.stopPropagation();
                            }
                        },

                        /**
                         * Extensions of core-overlay should implement the `resizeHandler`
                         * method to adjust the size and position of the overlay when the
                         * browser window resizes.
                         * @method resizeHandler
                         */
                        resizeHandler: function () {
                            this.updateTargetDimensions();
                        },

                        // TODO(sorvell): these utility methods should not be here.
                        addElementListenerList: function (node, events) {
                            for (var i in events) {
                                this.addElementListener(node, i, events[i]);
                            }
                        },

                        removeElementListenerList: function (node, events) {
                            for (var i in events) {
                                this.removeElementListener(node, i, events[i]);
                            }
                        },

                        enableElementListener: function (enable, node, event, methodName, capture) {
                            if (enable) {
                                this.addElementListener(node, event, methodName, capture);
                            } else {
                                this.removeElementListener(node, event, methodName, capture);
                            }
                        },

                        addElementListener: function (node, event, methodName, capture) {
                            var fn = this._makeBoundListener(methodName);
                            if (node && fn) {
                                Polymer.addEventListener(node, event, fn, capture);
                            }
                        },

                        removeElementListener: function (node, event, methodName, capture) {
                            var fn = this._makeBoundListener(methodName);
                            if (node && fn) {
                                Polymer.removeEventListener(node, event, fn, capture);
                            }
                        },

                        _makeBoundListener: function (methodName) {
                            var self = this,
                                method = this[methodName];
                            if (!method) {
                                return;
                            }
                            var bound = '_bound' + methodName;
                            if (!this[bound]) {
                                this[bound] = function (e) {
                                    method.call(self, e);
                                };
                            }
                            return this[bound];
                        },
                    });

                    // TODO(sorvell): This should be an element with private state so it can
                    // be independent of overlay.
                    // track overlays for z-index and focus managemant
                    var overlays = [];

                    function addOverlay(overlay) {
                        var z0 = currentOverlayZ();
                        overlays.push(overlay);
                        var z1 = currentOverlayZ();
                        if (z1 <= z0) {
                            applyOverlayZ(overlay, z0);
                        }
                    }

                    function removeOverlay(overlay) {
                        var i = overlays.indexOf(overlay);
                        if (i >= 0) {
                            overlays.splice(i, 1);
                            setZ(overlay, '');
                        }
                    }

                    function applyOverlayZ(overlay, aboveZ) {
                        setZ(overlay.target, aboveZ + 2);
                    }

                    function setZ(element, z) {
                        element.style.zIndex = z;
                    }

                    function currentOverlay() {
                        return overlays[overlays.length - 1];
                    }

                    var DEFAULT_Z = 10;

                    function currentOverlayZ() {
                        var z;
                        var current = currentOverlay();
                        if (current) {
                            var z1 = window.getComputedStyle(current.target).zIndex;
                            if (!isNaN(z1)) {
                                z = Number(z1);
                            }
                        }
                        return z || DEFAULT_Z;
                    }

                    function focusOverlay() {
                        var current = currentOverlay();
                        // We have to be careful to focus the next overlay _after_ any current
                        // transitions are complete (due to the state being toggled prior to the
                        // transition). Otherwise, we risk infinite recursion when a transitioning
                        // (closed) overlay becomes the current overlay.
                        //
                        // NOTE: We make the assumption that any overlay that completes a transition
                        // will call into focusOverlay to kick the process back off. Currently:
                        // transitionend -> applyFocus -> focusOverlay.
                        if (current && !current.transitioning) {
                            current.applyFocus();
                        }
                    }

                    var backdrops = [];

                    function trackBackdrop(element) {
                        if (element.opened) {
                            backdrops.push(element);
                        } else {
                            var i = backdrops.indexOf(element);
                            if (i >= 0) {
                                backdrops.splice(i, 1);
                            }
                        }
                    }

                    function getBackdrops() {
                        return backdrops;
                    }
                })();
            </script>
        </polymer-element>
        <polymer-element name="paper-dialog" attributes="opened heading transition autoCloseDisabled backdrop layered closeSelector" role="dialog" assetpath="bower_components/paper-dialog/">

            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        background: white;
                        color: rgba(0, 0, 0, 0.87);
                    }
                    #shadow {
                        position: absolute;
                        top: 0;
                        left: 0;
                        bottom: 0;
                        right: 0;
                        z-index: -1;
                    }
                    #container {
                        overflow: hidden;
                    }
                    #main {
                        height: auto;
                        -webkit-order: 1;
                        -ms-flex-order: 1;
                        order: 1;
                        padding: 24px;
                        overflow: auto;
                    }
                    h1 {
                        margin: 0;
                    }
                    #actions {
                        -webkit-order: 2;
                        -ms-flex-order: 2;
                        order: 2;
                        padding: 4px 16px 20px;
                    }
                    polyfill-next-selector {
                        content: ':host > *';
                    }
                    ::content > * {
                        font: inherit;
                    }
                </style>

                <div id="shadow">
                    <paper-shadow z="3" hasposition=""></paper-shadow>
                </div>

                <core-overlay id="overlay" opened="{{opened}}" autoclosedisabled?="{{autoCloseDisabled}}" backdrop?="{{backdrop}}" layered?="{{layered}}" target="{{}}" sizingtarget="{{$.container}}" closeselector="{{closeSelector}}" transition="{{transition}}" margin="20"></core-overlay>

                <div id="container" layout="" vertical="">

                    <div id="actions" layout="" horizontal="">
                        <content select="[dismissive]"></content>
                        <div flex="" auto=""></div>
                        <content select="[affirmative]"></content>
                    </div>

                    <div id="main" flex="" auto="">
                        <h1>{{heading}}</h1>
                        <content></content>
                    </div>

                </div>

            </template>

            <script>
                Polymer('paper-dialog', {

                    /**
       * Set opened to true to show the dialog and to false to hide it.
       * A dialog may be made intially opened by setting its opened attribute.

       * @attribute opened
       * @type boolean
       * @default false
       */
                    opened: false,

                    /**
                     * If true, the dialog has a backdrop darkening the rest of the screen.
                     * The backdrop element is attached to the document body and may be styled
                     * with the class `core-overlay-backdrop`. When opened the `core-opened`
                     * class is applied.
                     *
                     * @attribute backdrop
                     * @type boolean
                     * @default false
                     */
                    backdrop: false,

                    /**
                     * If true, the dialog is guaranteed to display above page content.
                     *
                     * @attribute layered
                     * @type boolean
                     * @default false
                     */
                    layered: false,

                    /**
                     * By default a dialog will close automatically if the user
                     * taps outside it or presses the escape key. Disable this
                     * behavior by setting the `autoCloseDisabled` property to true.
                     * @attribute autoCloseDisabled
                     * @type boolean
                     * @default false
                     */
                    autoCloseDisabled: false,

                    /**
                     * This property specifies a selector matching elements that should
                     * close the dialog on tap.
                     *
                     * @attribute closeSelector
                     * @type string
                     * @default ""
                     */
                    closeSelector: '[dismissive],[affirmative]',

                    /**
                     * @attribute heading
                     * @type string
                     * @default ''
                     */
                    heading: '',

                    /**
                     * Set this property to the id of a `core-transition` element to specify
                     * the transition to use when opening/closing this dialog.
                     *
                     * @attribute transition
                     * @type string
                     * @default ''
                     */
                    transition: '',

                    /**
                     * Toggle the dialog's opened state.
                     * @method toggle
                     */
                    toggle: function () {
                        this.$.overlay.toggle();
                    },

                    headingChanged: function () {
                        this.setAttribute('aria-label', this.heading);
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-dropdown-overlay" extends="core-overlay" assetpath="bower_components/core-dropdown/">
            <script>
                Polymer('core-dropdown-overlay', {

                    publish: {

                        /**
                         * The `relatedTarget` is an element used to position the overlay. It should have
                         * the same offsetParent as the target.
                         *
                         * @attribute relatedTarget
                         * @type Node
                         */
                        relatedTarget: null,

                        /**
                         * The horizontal alignment of the overlay relative to the `relatedTarget`.
                         * `left` means the left edges are aligned together and `right` means the right
                         * edges are aligned together.
                         *
                         * @attribute halign
                         * @type 'left' | 'right'
                         * @default 'auto'
                         */
                        halign: 'left',

                        /**
                         * The vertical alignment of the overlay relative to the `relatedTarget`. `top`
                         * means the top edges are aligned together and `bottom` means the bottom edges
                         * are aligned together.
                         *
                         * @attribute valign
                         * @type 'top' | 'bottom'
                         * @default 'top'
                         */
                        valign: 'top'

                    },

                    measure: function () {
                        var target = this.target;
                        // remember position, because core-overlay may have set the property
                        var pos = target.style.position;

                        // get the size of the target as if it's positioned in the top left
                        // corner of the screen
                        target.style.position = 'fixed';
                        target.style.left = '0px';
                        target.style.top = '0px';

                        var rect = target.getBoundingClientRect();

                        target.style.position = pos;
                        target.style.left = null;
                        target.style.top = null;

                        return rect;
                    },

                    resetTargetDimensions: function () {
                        var dims = this.dimensions;
                        var style = this.target.style;
                        if (dims.position.h_by === this.localName) {
                            style[dims.position.h] = null;
                        }
                        if (dims.position.v_by === this.localName) {
                            style[dims.position.v] = null;
                        }
                        this.super();
                    },

                    positionTarget: function () {
                        if (!this.relatedTarget) {
                            this.super();
                            return;
                        }

                        var target = this.target;
                        var related = this.relatedTarget;

                        // explicitly set width/height, because we don't want it constrained
                        // to the offsetParent
                        var rect = this.measure();
                        target.style.width = rect.width + 'px';
                        target.style.height = rect.height + 'px';

                        var t_op = target.offsetParent;
                        var r_op = related.offsetParent;
                        if (window.ShadowDOMPolyfill) {
                            t_op = wrap(t_op);
                            r_op = wrap(r_op);
                        }

                        if (t_op !== r_op && t_op !== related) {
                            console.warn('core-dropdown-overlay: dropdown\'s offsetParent must be the relatedTarget or the relatedTarget\'s offsetParent!');
                        }

                        // Don't use CSS to handle halign/valign so we can use
                        // dimensions.position to detect custom positioning

                        var dims = this.dimensions;
                        var margin = dims.margin;
                        var inside = t_op === related;

                        if (!dims.position.h) {
                            if (this.halign === 'right') {
                                target.style.right = ((inside ? 0 : t_op.offsetWidth - related.offsetLeft - related.offsetWidth) - margin.right) + 'px';
                                dims.position.h = 'right';
                            } else {
                                target.style.left = ((inside ? 0 : related.offsetLeft) - margin.left) + 'px';
                                dims.position.h = 'left';
                            }
                            dims.position.h_by = this.localName;
                        }

                        if (!dims.position.v) {
                            if (this.valign === 'bottom') {
                                target.style.bottom = ((inside ? 0 : t_op.offsetHeight - related.offsetTop - related.offsetHeight) - margin.bottom) + 'px';
                                dims.position.v = 'bottom';
                            } else {
                                target.style.top = ((inside ? 0 : related.offsetTop) - margin.top) + 'px';
                                dims.position.v = 'top';
                            }
                            dims.position.v_by = this.localName;
                        }
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="core-dropdown" assetpath="bower_components/core-dropdown/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        position: absolute;
                        overflow: auto;
                        background-color: #fff;
                    }
                </style>

                <core-dropdown-overlay id="overlay" target="{{}}" relatedtarget="{{relatedTarget}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}" margin="{{margin}}" transition="{{transition}}" autofocusdisabled="{{autoFocusDisabled}}"></core-dropdown-overlay>

                <content></content>

            </template>
            <script>
                Polymer('core-dropdown', {

                    publish: {

                        /**
                         * The element associated with this dropdown, usually the element that triggers
                         * the menu.
                         *
                         * @attribute relatedTarget
                         * @type Node
                         */
                        relatedTarget: null,

                        /**
                         * If true, the menu is currently visible.
                         *
                         * @attribute opened
                         * @type boolean
                         * @default false
                         */
                        opened: false,

                        /**
                         * The horizontal alignment of the popup relative to `relatedTarget`. `left`
                         * means the left edges are aligned together. `right` means the right edges
                         * are aligned together.
                         *
                         * @attribute halign
                         * @type 'left' | 'right'
                         * @default 'left'
                         */
                        halign: 'left',

                        /**
                         * The vertical alignment of the popup relative to `relatedTarget`. `top` means
                         * the top edges are aligned together. `bottom` means the bottom edges are
                         * aligned together.
                         *
                         * @attribute valign
                         * @type 'top' | 'bottom'
                         * @default 'top'
                         */
                        valign: 'top',

                        /**
                         * By default an overlay will focus its target or an element inside
                         * it with the `autoFocus` attribute. Disable this
                         * behavior by setting the `autoFocusDisabled` property to true.
                         *
                         * @attribute autoFocusDisabled
                         * @type boolean
                         * @default false
                         */
                        autoFocusDisabled: false,

                        /**
                         * The transition property specifies a string which identifies a
                         * <a href="../core-transition/">`core-transition`</a> element that
                         * will be used to help the overlay open and close. The default
                         * `core-transition-fade` will cause the overlay to fade in and out.
                         *
                         * @attribute transition
                         * @type string
                         * @default null
                         */
                        transition: null

                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-iconset-svg" extends="core-meta" attributes="iconSize" assetpath="bower_components/core-iconset-svg/">

            <script>
                Polymer('core-iconset-svg', {


                    /**
                     * The size of an individual icon. Note that icons must be square.
                     *
                     * @attribute iconSize
                     * @type number
                     * @default 24
                     */
                    iconSize: 24,
                    type: 'iconset',

                    created: function () {
                        this._icons = {};
                    },

                    ready: function () {
                        this.super();
                        this.updateIcons();
                    },

                    iconById: function (id) {
                        return this._icons[id] || (this._icons[id] = this.querySelector('#' + id));
                    },

                    cloneIcon: function (id) {
                        var icon = this.iconById(id);
                        if (icon) {
                            var content = icon.cloneNode(true);
                            content.removeAttribute('id');
                            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            svg.setAttribute('viewBox', '0 0 ' + this.iconSize + ' ' +
                                this.iconSize);
                            // NOTE(dfreedm): work around https://crbug.com/370136
                            svg.style.pointerEvents = 'none';
                            svg.appendChild(content);
                            return svg;
                        }
                    },

                    get iconNames() {
                        if (!this._iconNames) {
                            this._iconNames = this.findIconNames();
                        }
                        return this._iconNames;
                    },

                    findIconNames: function () {
                        var icons = this.querySelectorAll('[id]').array();
                        if (icons.length) {
                            return icons.map(function (n) {
                                return n.id
                            });
                        }
                    },

                    /**
                     * Applies an icon to the given element. The svg icon is added to the
                     * element's shadowRoot if one exists or directly to itself.
                     *
                     * @method applyIcon
                     * @param {Element} element The element to which the icon is
                     * applied.
                     * @param {String|Number} icon The name the icon to apply.
                     * @return {Element} The icon element
                     */
                    applyIcon: function (element, icon) {
                        var root = element;
                        // remove old
                        var old = root.querySelector('svg');
                        if (old) {
                            old.remove();
                        }
                        // install new
                        var svg = this.cloneIcon(icon);
                        if (!svg) {
                            return;
                        }
                        svg.setAttribute('height', '100%');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        svg.style.display = 'block';
                        root.insertBefore(svg, root.firstElementChild);
                        return svg;
                    },

                    /**
                     * Tell users of the iconset, that the set has loaded.
                     * This finds all elements matching the selector argument and calls
                     * the method argument on them.
                     * @method updateIcons
                     * @param selector {string} css selector to identify iconset users,
                     * defaults to '[icon]'
                     * @param method {string} method to call on found elements,
                     * defaults to 'updateIcon'
                     */
                    updateIcons: function (selector, method) {
                        selector = selector || '[icon]';
                        method = method || 'updateIcon';
                        var deep = window.ShadowDOMPolyfill ? '' : 'html /deep/ ';
                        var i$ = document.querySelectorAll(deep + selector);
                        for (var i = 0, e; e = i$[i]; i++) {
                            if (e[method]) {
                                e[method].call(e);
                            }
                        }
                    }


                });
            </script>

        </polymer-element>
        <core-iconset-svg id="icons" iconsize="24">
            <svg>
                <defs>
                    <g id="accessibility">
                        <path d="M12,2c1.1,0,2,0.9,2,2s-0.9,2-2,2s-2-0.9-2-2S10.9,2,12,2z M21,9h-6v13h-2v-6h-2v6H9V9H3V7h18V9z"></path>
                    </g>
                    <g id="account-balance">
                        <path d="M4,10v7h3v-7H4z M10,10v7h3v-7H10z M2,22h19v-3H2V22z M16,10v7h3v-7H16z M11.5,1L2,6v2h19V6L11.5,1z"></path>
                    </g>
                    <g id="account-box">
                        <path d="M3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5c0-1.1-0.9-2-2-2H5C3.9,3,3,3.9,3,5z M15,9c0,1.7-1.3,3-3,3c-1.7,0-3-1.3-3-3c0-1.7,1.3-3,3-3C13.7,6,15,7.3,15,9z M6,17c0-2,4-3.1,6-3.1s6,1.1,6,3.1v1H6V17z"></path>
                    </g>
                    <g id="account-child">
                        <path d="M16.5,12c1.4,0,2.5-1.1,2.5-2.5C19,8.1,17.9,7,16.5,7C15.1,7,14,8.1,14,9.5C14,10.9,15.1,12,16.5,12z M9,11c1.7,0,3-1.3,3-3s-1.3-3-3-3C7.3,5,6,6.3,6,8S7.3,11,9,11z M16.5,14c-1.8,0-5.5,0.9-5.5,2.7V19h11v-2.2C22,14.9,18.3,14,16.5,14z M9,13c-2.3,0-7,1.2-7,3.5V19h7v-2.2c0-0.8,0.3-2.3,2.4-3.5C10.5,13.1,9.7,13,9,13z"></path>
                    </g>
                    <g id="account-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,5c1.7,0,3,1.3,3,3c0,1.7-1.3,3-3,3c-1.7,0-3-1.3-3-3C9,6.3,10.3,5,12,5z M12,19.2c-2.5,0-4.7-1.3-6-3.2c0-2,4-3.1,6-3.1c2,0,6,1.1,6,3.1C16.7,17.9,14.5,19.2,12,19.2z"></path>
                    </g>
                    <g id="add">
                        <path d="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6V13z"></path>
                    </g>
                    <g id="add-box">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M17,13h-4v4h-2v-4H7v-2h4V7h2v4h4V13z"></path>
                    </g>
                    <g id="add-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M17,13h-4v4h-2v-4H7v-2h4V7h2v4h4V13z"></path>
                    </g>
                    <g id="add-circle-outline">
                        <path d="M13,7h-2v4H7v2h4v4h2v-4h4v-2h-4V7z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="add-shopping-cart">
                        <polygon points="18.3,6 18.3,6 15.6,11 "></polygon>
                        <path d="M11,9h2V6h3V4h-3V1h-2v3H8v2h3V9z M7,18c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S8.1,18,7,18z M17,18c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S18.1,18,17,18z M7.2,14.8c0,0,0-0.1,0-0.1L8.1,13h7.4c0.8,0,1.4-0.4,1.7-1l3.9-7l-1.7-1h0l-1.1,2l-2.8,5h-7l-0.1-0.3L6.2,6L5.2,4L4.3,2H1v2h2l3.6,7.6L5.2,14C5.1,14.3,5,14.7,5,15c0,1.1,0.9,2,2,2h12v-2H7.4C7.3,15,7.2,14.9,7.2,14.8z"></path>
                    </g>
                    <g id="alarm">
                        <path d="M22,5.7l-4.6-3.9l-1.3,1.5l4.6,3.9L22,5.7z M7.9,3.4L6.6,1.9L2,5.7l1.3,1.5L7.9,3.4z M12.5,8H11v6l4.7,2.9l0.8-1.2l-4-2.4V8z M12,4c-5,0-9,4-9,9c0,5,4,9,9,9c5,0,9-4,9-9C21,8,17,4,12,4z M12,20c-3.9,0-7-3.1-7-7c0-3.9,3.1-7,7-7c3.9,0,7,3.1,7,7C19,16.9,15.9,20,12,20z"></path>
                    </g>
                    <g id="alarm-add">
                        <path d="M7.9,3.4L6.6,1.9L2,5.7l1.3,1.5L7.9,3.4z M22,5.7l-4.6-3.9l-1.3,1.5l4.6,3.9L22,5.7z M12,4c-5,0-9,4-9,9c0,5,4,9,9,9c5,0,9-4,9-9C21,8,17,4,12,4z M12,20c-3.9,0-7-3.1-7-7c0-3.9,3.1-7,7-7c3.9,0,7,3.1,7,7C19,16.9,15.9,20,12,20z M13,9h-2v3H8v2h3v3h2v-3h3v-2h-3V9z"></path>
                    </g>
                    <g id="alarm-off">
                        <path d="M12,6c3.9,0,7,3.1,7,7c0,0.8-0.2,1.6-0.4,2.4l1.5,1.5c0.6-1.2,0.9-2.5,0.9-3.9c0-5-4-9-9-9c-1.4,0-2.7,0.3-3.9,0.9l1.5,1.5C10.4,6.2,11.2,6,12,6z M22,5.7l-4.6-3.9l-1.3,1.5l4.6,3.9L22,5.7z M2.9,2.3L1.6,3.6L3,4.9L1.9,5.8l1.4,1.4l1.1-0.9l0.8,0.8C3.8,8.7,3,10.7,3,13c0,5,4,9,9,9c2.3,0,4.3-0.8,5.9-2.2l2.2,2.2l1.3-1.3L3.9,3.3L2.9,2.3z M16.5,18.4c-1.2,1-2.8,1.6-4.5,1.6c-3.9,0-7-3.1-7-7c0-1.7,0.6-3.3,1.6-4.5L16.5,18.4z M8,3.3L6.6,1.9L5.7,2.6L7.2,4L8,3.3z"></path>
                    </g>
                    <g id="alarm-on">
                        <path d="M22,5.7l-4.6-3.9l-1.3,1.5l4.6,3.9L22,5.7z M7.9,3.4L6.6,1.9L2,5.7l1.3,1.5L7.9,3.4z M12,4c-5,0-9,4-9,9c0,5,4,9,9,9c5,0,9-4,9-9C21,8,17,4,12,4z M12,20c-3.9,0-7-3.1-7-7c0-3.9,3.1-7,7-7s7,3.1,7,7C19,16.9,15.9,20,12,20z M10.5,14.5l-2.1-2.1l-1.1,1.1l3.2,3.2l6-6l-1.1-1.1L10.5,14.5z"></path>
                    </g>
                    <g id="android">
                        <path d="M6,18c0,0.6,0.4,1,1,1h1v3.5C8,23.3,8.7,24,9.5,24c0.8,0,1.5-0.7,1.5-1.5V19h2v3.5c0,0.8,0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5V19h1c0.6,0,1-0.4,1-1V8H6V18z M3.5,8C2.7,8,2,8.7,2,9.5v7C2,17.3,2.7,18,3.5,18C4.3,18,5,17.3,5,16.5v-7C5,8.7,4.3,8,3.5,8z M20.5,8C19.7,8,19,8.7,19,9.5v7c0,0.8,0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5v-7C22,8.7,21.3,8,20.5,8z M15.5,2.2l1.3-1.3c0.2-0.2,0.2-0.5,0-0.7c-0.2-0.2-0.5-0.2-0.7,0l-1.5,1.5C13.9,1.2,13,1,12,1c-1,0-1.9,0.2-2.7,0.6L7.9,0.1C7.7,0,7.3,0,7.1,0.1C7,0.3,7,0.7,7.1,0.9l1.3,1.3C7,3.3,6,5,6,7h12C18,5,17,3.2,15.5,2.2z M10,5H9V4h1V5z M15,5h-1V4h1V5z"></path>
                    </g>
                    <g id="announcement">
                        <path d="M20,2H4C2.9,2,2,2.9,2,4l0,18l4-4h14c1.1,0,2-0.9,2-2V4C22,2.9,21.1,2,20,2z M13,11h-2V5h2V11z M13,15h-2v-2h2V15z"></path>
                    </g>
                    <g id="apps">
                        <path d="M4,8h4V4H4V8z M10,20h4v-4h-4V20z M4,20h4v-4H4V20z M4,14h4v-4H4V14z M10,14h4v-4h-4V14z M16,4v4h4V4H16z M10,8h4V4h-4V8z M16,14h4v-4h-4V14z M16,20h4v-4h-4V20z"></path>
                    </g>
                    <g id="archive">
                        <path d="M20.5,5.2l-1.4-1.7C18.9,3.2,18.5,3,18,3H6C5.5,3,5.1,3.2,4.8,3.5L3.5,5.2C3.2,5.6,3,6,3,6.5V19c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V6.5C21,6,20.8,5.6,20.5,5.2z M12,17.5L6.5,12H10v-2h4v2h3.5L12,17.5z M5.1,5l0.8-1h12l0.9,1H5.1z"></path>
                    </g>
                    <g id="arrow-back">
                        <path d="M20,11H7.8l5.6-5.6L12,4l-8,8l8,8l1.4-1.4L7.8,13H20V11z"></path>
                    </g>
                    <g id="arrow-drop-down">
                        <polygon points="7,10 12,15 17,10 "></polygon>
                    </g>
                    <g id="arrow-drop-down-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,14l-4-4h8L12,14z"></path>
                    </g>
                    <g id="arrow-drop-up">
                        <polygon points="7,14 12,9 17,14 "></polygon>
                    </g>
                    <g id="arrow-forward">
                        <polygon points="12,4 10.6,5.4 16.2,11 4,11 4,13 16.2,13 10.6,18.6 12,20 20,12 "></polygon>
                    </g>
                    <g id="aspect-ratio">
                        <path d="M19,12h-2v3h-3v2h5V12z M7,9h3V7H5v5h2V9z M21,3H3C1.9,3,1,3.9,1,5v14c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3z M21,19H3V5h18V19z"></path>
                    </g>
                    <g id="assessment">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M9,17H7v-7h2V17z M13,17h-2V7h2V17z M17,17h-2v-4h2V17z"></path>
                    </g>
                    <g id="assignment">
                        <path d="M19,3h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,3c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S11.4,3,12,3z M14,17H7v-2h7V17z M17,13H7v-2h10V13z M17,9H7V7h10V9z"></path>
                    </g>
                    <g id="assignment-ind">
                        <path d="M19,3h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,3c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S11.4,3,12,3z M12,7c1.7,0,3,1.3,3,3c0,1.7-1.3,3-3,3c-1.7,0-3-1.3-3-3C9,8.3,10.3,7,12,7z M18,19H6v-1.4c0-2,4-3.1,6-3.1s6,1.1,6,3.1V19z"></path>
                    </g>
                    <g id="assignment-late">
                        <path d="M19,3h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,3c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S11.4,3,12,3z M17,15.6L15.6,17L12,13.4L8.4,17L7,15.6l3.6-3.6L7,8.4L8.4,7l3.6,3.6L15.6,7L17,8.4L13.4,12L17,15.6z"></path>
                    </g>
                    <g id="assignment-return">
                        <path d="M19,3h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,3c0.6,0,1,0.4,1,1s-0.4,1-1,1c-0.6,0-1-0.4-1-1S11.4,3,12,3z M16,15h-4v3l-5-5l5-5v3h4V15z"></path>
                    </g>
                    <g id="assignment-returned">
                        <path d="M19,3h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,3c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S11.4,3,12,3z M12,18l-5-5h3V9h4v4h3L12,18z"></path>
                    </g>
                    <g id="attachment">
                        <path d="M7.5,18c-3,0-5.5-2.5-5.5-5.5S4.5,7,7.5,7H18c2.2,0,4,1.8,4,4s-1.8,4-4,4H9.5C8.1,15,7,13.9,7,12.5S8.1,10,9.5,10H17v1.5H9.5c-0.6,0-1,0.4-1,1s0.4,1,1,1H18c1.4,0,2.5-1.1,2.5-2.5S19.4,8.5,18,8.5H7.5c-2.2,0-4,1.8-4,4s1.8,4,4,4H17V18H7.5z"></path>
                    </g>
                    <g id="backspace">
                        <path d="M22,3H7C6.3,3,5.8,3.3,5.4,3.9L0,12l5.4,8.1C5.8,20.6,6.3,21,7,21h15c1.1,0,2-0.9,2-2V5C24,3.9,23.1,3,22,3z M19,15.6L17.6,17L14,13.4L10.4,17L9,15.6l3.6-3.6L9,8.4L10.4,7l3.6,3.6L17.6,7L19,8.4L15.4,12L19,15.6z"></path>
                    </g>
                    <g id="backup">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z M14,13v4h-4v-4H7l5-5l5,5H14z"></path>
                    </g>
                    <g id="block">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M4,12c0-4.4,3.6-8,8-8c1.8,0,3.5,0.6,4.9,1.7L5.7,16.9C4.6,15.5,4,13.8,4,12z M12,20c-1.8,0-3.5-0.6-4.9-1.7L18.3,7.1C19.4,8.5,20,10.2,20,12C20,16.4,16.4,20,12,20z"></path>
                    </g>
                    <g id="book">
                        <path d="M18,2H6C4.9,2,4,2.9,4,4v16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V4C20,2.9,19.1,2,18,2z M6,4h5v8l-2.5-1.5L6,12V4z"></path>
                    </g>
                    <g id="bookmark">
                        <path d="M17,3H7C5.9,3,5,3.9,5,5l0,16l7-3l7,3V5C19,3.9,18.1,3,17,3z"></path>
                    </g>
                    <g id="bookmark-outline">
                        <path d="M17,3H7C5.9,3,5,3.9,5,5l0,16l7-3l7,3V5C19,3.9,18.1,3,17,3z M17,18l-5-2.2L7,18V5h10V18z"></path>
                    </g>
                    <g id="bug-report">
                        <path d="M20,8h-2.8c-0.5-0.8-1.1-1.5-1.8-2L17,4.4L15.6,3l-2.2,2.2C13,5.1,12.5,5,12,5s-1,0.1-1.4,0.2L8.4,3L7,4.4L8.6,6C7.9,6.5,7.3,7.2,6.8,8H4v2h2.1C6,10.3,6,10.7,6,11v1H4v2h2v1c0,0.3,0,0.7,0.1,1H4v2h2.8c1,1.8,3,3,5.2,3s4.2-1.2,5.2-3H20v-2h-2.1c0.1-0.3,0.1-0.7,0.1-1v-1h2v-2h-2v-1c0-0.3,0-0.7-0.1-1H20V8z M14,16h-4v-2h4V16z M14,12h-4v-2h4V12z"></path>
                    </g>
                    <g id="cached">
                        <path d="M19,8l-4,4h3c0,3.3-2.7,6-6,6c-1,0-2-0.3-2.8-0.7l-1.5,1.5C9,19.5,10.4,20,12,20c4.4,0,8-3.6,8-8h3L19,8z M6,12c0-3.3,2.7-6,6-6c1,0,2,0.3,2.8,0.7l1.5-1.5C15,4.5,13.6,4,12,4c-4.4,0-8,3.6-8,8H1l4,4l4-4H6z"></path>
                    </g>
                    <g id="cancel">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M17,15.6L15.6,17L12,13.4L8.4,17L7,15.6l3.6-3.6L7,8.4L8.4,7l3.6,3.6L15.6,7L17,8.4L13.4,12L17,15.6z"></path>
                    </g>
                    <g id="check">
                        <polygon points="9,16.2 4.8,12 3.4,13.4 9,19 21,7 19.6,5.6 "></polygon>
                    </g>
                    <g id="check-box">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M10,17l-5-5l1.4-1.4l3.6,3.6l7.6-7.6L19,8L10,17z"></path>
                    </g>
                    <g id="check-box-blank">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z"></path>
                    </g>
                    <g id="check-box-outline">
                        <path d="M7.9,10.1l-1.4,1.4L11,16L21,6l-1.4-1.4L11,13.2L7.9,10.1z M19,19L5,19V5h10V3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-8h-2V19z"></path>
                    </g>
                    <g id="check-box-outline-blank">
                        <path d="M19,5v14L5,19V5H19 M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3L19,3z"></path>
                    </g>
                    <g id="check-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12c0,5.5,4.5,10,10,10c5.5,0,10-4.5,10-10C22,6.5,17.5,2,12,2z M10,17l-5-5l1.4-1.4l3.6,3.6l7.6-7.6L19,8L10,17z"></path>
                    </g>
                    <g id="check-circle-blank">
                        <path d="M12,2C6.5,2,2,6.5,2,12c0,5.5,4.5,10,10,10c5.5,0,10-4.5,10-10C22,6.5,17.5,2,12,2z"></path>
                    </g>
                    <g id="check-circle-outline">
                        <path d="M7.9,10.1l-1.4,1.4L11,16L21,6l-1.4-1.4L11,13.2L7.9,10.1z M20,12c0,4.4-3.6,8-8,8s-8-3.6-8-8s3.6-8,8-8c0.8,0,1.5,0.1,2.2,0.3l1.6-1.6C14.6,2.3,13.3,2,12,2C6.5,2,2,6.5,2,12s4.5,10,10,10s10-4.5,10-10H20z"></path>
                    </g>
                    <g id="check-circle-outline-blank">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="chevron-left">
                        <polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "></polygon>
                    </g>
                    <g id="chevron-right">
                        <polygon points="10,6 8.6,7.4 13.2,12 8.6,16.6 10,18 16,12 "></polygon>
                    </g>
                    <g id="class">
                        <path d="M18,2H6C4.9,2,4,2.9,4,4v16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V4C20,2.9,19.1,2,18,2z M6,4h5v8l-2.5-1.5L6,12V4z"></path>
                    </g>
                    <g id="clear">
                        <polygon points="19,6.4 17.6,5 12,10.6 6.4,5 5,6.4 10.6,12 5,17.6 6.4,19 12,13.4 17.6,19 19,17.6 13.4,12 "></polygon>
                    </g>
                    <g id="close">
                        <polygon points="19,6.4 17.6,5 12,10.6 6.4,5 5,6.4 10.6,12 5,17.6 6.4,19 12,13.4 17.6,19 19,17.6 13.4,12 "></polygon>
                    </g>
                    <g id="cloud">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z"></path>
                    </g>
                    <g id="cloud-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12c0,5.5,4.5,10,10,10c5.5,0,10-4.5,10-10C22,6.5,17.5,2,12,2z M16.5,16c0,0-8.5,0-8.5,0c-1.7,0-3-1.3-3-3s1.3-3,3-3c0,0,0.1,0,0.1,0c0.4-1.7,2-3,3.9-3c2.2,0,4,1.8,4,4h0.5c1.4,0,2.5,1.1,2.5,2.5C19,14.9,17.9,16,16.5,16z"></path>
                    </g>
                    <g id="cloud-done">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z M10,17l-3.5-3.5l1.4-1.4l2.1,2.1L15.2,9l1.4,1.4L10,17z"></path>
                    </g>
                    <g id="cloud-download">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z M17,13l-5,5l-5-5h3V9h4v4H17z"></path>
                    </g>
                    <g id="cloud-off">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6c-1.5,0-2.9,0.4-4,1.2l1.5,1.5C10.2,6.2,11.1,6,12,6c3,0,5.5,2.5,5.5,5.5V12H19c1.7,0,3,1.3,3,3c0,1.1-0.6,2.1-1.6,2.6l1.5,1.5c1.3-0.9,2.1-2.4,2.1-4.1C24,12.4,21.9,10.2,19.4,10z M3,5.3L5.8,8C2.6,8.2,0,10.8,0,14c0,3.3,2.7,6,6,6h11.7l2,2l1.3-1.3L4.3,4L3,5.3z M7.7,10l8,8H6c-2.2,0-4-1.8-4-4c0-2.2,1.8-4,4-4H7.7z"></path>
                    </g>
                    <g id="cloud-queue">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z M19,18H6c-2.2,0-4-1.8-4-4c0-2.2,1.8-4,4-4h0.7C7.4,7.7,9.5,6,12,6c3,0,5.5,2.5,5.5,5.5V12H19c1.7,0,3,1.3,3,3S20.7,18,19,18z"></path>
                    </g>
                    <g id="cloud-upload">
                        <path d="M19.4,10c-0.7-3.4-3.7-6-7.4-6C9.1,4,6.6,5.6,5.4,8C2.3,8.4,0,10.9,0,14c0,3.3,2.7,6,6,6h13c2.8,0,5-2.2,5-5C24,12.4,21.9,10.2,19.4,10z M14,13v4h-4v-4H7l5-5l5,5H14z"></path>
                    </g>
                    <g id="content-copy">
                        <path d="M16,1H4C2.9,1,2,1.9,2,3v14h2V3h12V1z M19,5H8C6.9,5,6,5.9,6,7v14c0,1.1,0.9,2,2,2h11c1.1,0,2-0.9,2-2V7C21,5.9,20.1,5,19,5z M19,21H8V7h11V21z"></path>
                    </g>
                    <g id="content-cut">
                        <path d="M10,6c0-2.2-1.8-4-4-4S2,3.8,2,6c0,2.2,1.8,4,4,4c0.6,0,1.1-0.1,1.6-0.4L10,12l-2.4,2.4C7.1,14.1,6.6,14,6,14c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4s4-1.8,4-4c0-0.6-0.1-1.1-0.4-1.6L12,14l7,7h4L9.6,7.6C9.9,7.1,10,6.6,10,6z M6,8C4.9,8,4,7.1,4,6s0.9-2,2-2c1.1,0,2,0.9,2,2S7.1,8,6,8z M6,20c-1.1,0-2-0.9-2-2s0.9-2,2-2c1.1,0,2,0.9,2,2S7.1,20,6,20z M12,11.5c0.3,0,0.5,0.2,0.5,0.5c0,0.3-0.2,0.5-0.5,0.5c-0.3,0-0.5-0.2-0.5-0.5C11.5,11.7,11.7,11.5,12,11.5z M23,3h-4l-6,6l2,2L23,3z"></path>
                    </g>
                    <g id="content-paste">
                        <path d="M19,2h-4.2c-0.4-1.2-1.5-2-2.8-2c-1.3,0-2.4,0.8-2.8,2H5C3.9,2,3,2.9,3,4v16c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V4C21,2.9,20.1,2,19,2z M12,2c0.6,0,1,0.4,1,1s-0.4,1-1,1c-0.6,0-1-0.4-1-1S11.4,2,12,2z M19,20H5V4h2v3h10V4h2V20z"></path>
                    </g>
                    <g id="create">
                        <path d="M3,17.2V21h3.8L17.8,9.9l-3.8-3.8L3,17.2z M20.7,7c0.4-0.4,0.4-1,0-1.4l-2.3-2.3c-0.4-0.4-1-0.4-1.4,0l-1.8,1.8l3.8,3.8L20.7,7z"></path>
                    </g>
                    <g id="credit-card">
                        <path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M20,18H4v-6h16V18z M20,8H4V6h16V8z"></path>
                    </g>
                    <g id="delete">
                        <path d="M6,19c0,1.1,0.9,2,2,2h8c1.1,0,2-0.9,2-2V7H6V19z M19,4h-3.5l-1-1h-5l-1,1H5v2h14V4z"></path>
                    </g>
                    <g id="description">
                        <path d="M14,2H6C4.9,2,4,2.9,4,4l0,16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V8L14,2z M16,18H8v-2h8V18z M16,14H8v-2h8V14z M13,9V3.5L18.5,9H13z"></path>
                    </g>
                    <g id="developer-mode-tv">
                        <path d="M4,5h16v2h2l0-2c0-1.1-0.9-2-2-2H4C2.9,3,2,3.9,2,5v2h2V5z M7.6,13.8L4.7,11l2.8-2.8L6.1,6.8L1.9,11l4.2,4.2L7.6,13.8z M20,17H4v-2H2v2c0,1.1,0.9,2,2,2h4v2h8v-2h4c1.1,0,2-0.9,2-2l0-2h-2V17z M22,11l-4.2-4.2l-1.4,1.4l2.8,2.8l-2.8,2.8l1.4,1.4L22,11L22,11L22,11L22,11L22,11z"></path>
                    </g>
                    <g id="done">
                        <polygon points="9,16.2 4.8,12 3.4,13.4 9,19 21,7 19.6,5.6 "></polygon>
                    </g>
                    <g id="done-all">
                        <path d="M18,7l-1.4-1.4l-6.3,6.3l1.4,1.4L18,7z M22.2,5.6L11.7,16.2L7.5,12l-1.4,1.4l5.6,5.6l12-12L22.2,5.6z M0.4,13.4L6,19l1.4-1.4L1.8,12L0.4,13.4z"></path>
                    </g>
                    <g id="drafts">
                        <path d="M22,8c0-0.7-0.4-1.3-0.9-1.7L12,1L2.9,6.3C2.4,6.7,2,7.3,2,8v10c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2L22,8z M12,13L3.7,7.8L12,3l8.3,4.8L12,13z"></path>
                    </g>
                    <g id="drawer">
                        <path d="M12,8c1.1,0,2-0.9,2-2s-0.9-2-2-2c-1.1,0-2,0.9-2,2S10.9,8,12,8z M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S13.1,10,12,10z M12,16c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S13.1,16,12,16z"></path>
                    </g>
                    <g id="drive">
                        <path d="M22.3,14L15.4,2H8.6l0,0l6.9,12H22.3z M9.7,15l-3.4,6h13.1l3.4-6H9.7z M7.7,3.5L1.2,15l3.4,6l6.6-11.5L7.7,3.5z"></path>
                    </g>
                    <g id="drive-archive">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,18l-4-4h8L12,18z M16,12H8v-2h8V12z M16,8H8V6h8V8z"></path>
                    </g>
                    <g id="drive-audio">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M7.2,18C6.5,18,6,17.5,6,16.8v-3.6V12c0-3.3,2.7-6,6-6s6,2.7,6,6v1.2v3.6c0,0.7-0.5,1.2-1.2,1.2H14v-4h2v-2c0-2.2-1.8-4-4-4s-4,1.8-4,4v2h2v4H7.2z"></path>
                    </g>
                    <g id="drive-chart">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M9,17H7v-7h2V17z M13,17h-2V7h2V17z M17,17h-2v-4h2V17z"></path>
                    </g>
                    <g id="drive-document">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M17,9H7V7h10V9z M17,13H7v-2h10V13z M14,17H7v-2h7V17z"></path>
                    </g>
                    <g id="drive-drawing">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M18,18h-6v-5.8c-0.7,0.6-1.5,1-2.5,1c-2,0-3.7-1.7-3.7-3.7s1.7-3.7,3.7-3.7c2,0,3.7,1.7,3.7,3.7c0,1-0.4,1.8-1,2.5H18V18z"></path>
                    </g>
                    <g id="drive-file">
                        <path d="M6,2C4.9,2,4,2.9,4,4l0,16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V8l-6-6H6z M13,9V3.5L18.5,9H13z"></path>
                    </g>
                    <g id="drive-file-move">
                        <path d="M20,6h-8l-2-2H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M9,18v-3H5v-4h4V8l5,5L9,18z"></path>
                    </g>
                    <g id="drive-file-rename">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M6,17v-2.5l7.9-7.9c0.2-0.2,0.5-0.2,0.7,0l1.8,1.8c0.2,0.2,0.2,0.5,0,0.7L8.5,17H6z M18,17h-7.5l2-2H18V17z"></path>
                    </g>
                    <g id="drive-form">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M9,17H7v-2h2V17z M9,13H7v-2h2V13z M9,9H7V7h2V9z M17,17h-7v-2h7V17z M17,13h-7v-2h7V13z M17,9h-7V7h7V9z"></path>
                    </g>
                    <g id="drive-fusiontable">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,10.2L13,17l-4-4l-4,4v-3l4-4l4,4l6-6.8V10.2z"></path>
                    </g>
                    <g id="drive-image">
                        <path d="M21,19V5c0-1.1-0.9-2-2-2H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14C20.1,21,21,20.1,21,19z M8.5,13.5l2.5,3l3.5-4.5l4.5,6H5L8.5,13.5z"></path>
                    </g>
                    <g id="drive-keep">
                        <path d="M9,21c0,0.6,0.4,1,1,1h4c0.6,0,1-0.4,1-1v-1H9V21z M12,2C8.1,2,5,5.1,5,9c0,2.4,1.2,4.5,3,5.7V17c0,0.6,0.4,1,1,1h6c0.6,0,1-0.4,1-1v-2.3c1.8-1.3,3-3.4,3-5.7C19,5.1,15.9,2,12,2z"></path>
                    </g>
                    <g id="drive-ms-excel">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M16.2,17h-2L12,13.2L9.8,17h-2l3.2-5L7.8,7h2l2.2,3.8L14.2,7h2L13,12L16.2,17z"></path>
                    </g>
                    <g id="drive-ms-powerpoint">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M9.8,13.4V17H8V7h4.3c1.5,0,2.2,0.3,2.8,0.9c0.7,0.6,0.9,1.4,0.9,2.3c0,1-0.3,1.8-0.9,2.3c-0.6,0.5-1.3,0.8-2.8,0.8H9.8z"></path>
                        <path d="M9.8,12V8.4h2.3c0.7,0,1.2,0.2,1.5,0.6c0.3,0.4,0.5,0.7,0.5,1.2c0,0.6-0.2,0.9-0.5,1.3c-0.3,0.3-0.7,0.5-1.4,0.5H9.8z"></path>
                    </g>
                    <g id="drive-ms-word">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M15.5,17H14l-2-7.5L10,17H8.5L6.1,7h1.7l1.5,7.5l2-7.5h1.4l2,7.5L16.2,7h1.7L15.5,17z"></path>
                    </g>
                    <g id="drive-pdf">
                        <path d="M11.3,8.6L11.3,8.6C11.4,8.6,11.4,8.6,11.3,8.6c0.1-0.4,0.2-0.6,0.2-0.9l0-0.2c0.1-0.5,0.1-0.9,0-1c0,0,0,0,0-0.1l-0.1-0.1c0,0,0,0,0,0c0,0,0,0,0,0c0,0,0,0.1-0.1,0.1C11.1,7,11.1,7.7,11.3,8.6C11.3,8.6,11.3,8.6,11.3,8.6z M8.3,15.5c-0.2,0.1-0.4,0.2-0.5,0.3c-0.7,0.6-1.2,1.3-1.3,1.6c0,0,0,0,0,0c0,0,0,0,0,0c0,0,0,0,0,0C7.1,17.3,7.7,16.7,8.3,15.5C8.4,15.5,8.4,15.5,8.3,15.5C8.4,15.5,8.3,15.5,8.3,15.5z M17.5,14c-0.1-0.1-0.5-0.4-1.9-0.4c-0.1,0-0.1,0-0.2,0c0,0,0,0,0,0c0,0,0,0,0,0.1c0.7,0.3,1.4,0.5,1.9,0.5c0.1,0,0.1,0,0.2,0l0,0c0,0,0.1,0,0.1,0c0,0,0,0,0-0.1c0,0,0,0,0,0C17.6,14.1,17.5,14.1,17.5,14z M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M17.9,14.8C17.7,14.9,17.4,15,17,15c-0.8,0-2-0.2-3-0.7c-1.7,0.2-3,0.4-4,0.8c-0.1,0-0.1,0-0.2,0.1c-1.2,2.1-2.2,3.1-3,3.1c-0.2,0-0.3,0-0.4-0.1l-0.5-0.3l0-0.1c-0.1-0.2-0.1-0.3-0.1-0.5c0.1-0.5,0.7-1.4,1.9-2.1c0.2-0.1,0.5-0.3,0.9-0.5c0.3-0.5,0.6-1.1,1-1.8c0.5-1,0.8-2,1.1-2.9l0,0c-0.4-1.2-0.6-1.9-0.2-3.3c0.1-0.4,0.4-0.8,0.8-0.8l0.2,0c0.2,0,0.4,0.1,0.6,0.2c0.7,0.7,0.4,2.3,0,3.6c0,0.1,0,0.1,0,0.1c0.4,1.1,1,2,1.6,2.6c0.3,0.2,0.5,0.4,0.9,0.6c0.5,0,0.9-0.1,1.3-0.1c1.2,0,2,0.2,2.3,0.7c0.1,0.2,0.1,0.4,0.1,0.6C18.2,14.3,18.1,14.6,17.9,14.8z M11.4,10.9c-0.2,0.7-0.6,1.5-1,2.4c-0.2,0.4-0.4,0.7-0.6,1.1c0,0,0.1,0,0.1,0l0.1,0v0c1.3-0.5,2.5-0.8,3.3-0.9c-0.2-0.1-0.3-0.2-0.4-0.3C12.4,12.6,11.8,11.8,11.4,10.9z"></path>
                    </g>
                    <g id="drive-presentation">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,16H5V8h14V16z"></path>
                    </g>
                    <g id="drive-script">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5l0,4h0v6h0l0,4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M11,17v-3H5v-4h6V7l5,5L11,17z"></path>
                    </g>
                    <g id="drive-site">
                        <path d="M19,4H5C3.9,4,3,4.9,3,6l0,12c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V6C21,4.9,20.1,4,19,4z M14,18H5v-4h9V18z M14,13H5V9h9V13z M19,18h-4V9h4V18z"></path>
                    </g>
                    <g id="drive-spreadsheet">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5l0,3h0v11c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,11h-8v8H9v-8H5V9h4V5h2v4h8V11z"></path>
                    </g>
                    <g id="drive-text">
                        <path d="M14,2H6C4.9,2,4,2.9,4,4l0,16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V8L14,2z M16,18H8v-2h8V18z M16,14H8v-2h8V14z M13,9V3.5L18.5,9H13z"></path>
                    </g>
                    <g id="drive-video">
                        <path d="M18,4l2,4h-3l-2-4h-2l2,4h-3l-2-4H8l2,4H7L5,4H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V4H18z"></path>
                    </g>
                    <g id="drive-zip">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M14,9h-2v2h2v2h-2v-2h-2V9h2V7h-2V5h2v2h2V9z M14,17h-2v-2h-2v-2h2v2h2V17z"></path>
                    </g>
                    <g id="due-date">
                        <path d="M17,12h-5v5h5V12z M16,1v2H8V1H6v2H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5c0-1.1-0.9-2-2-2h-1V1H16z M19,19H5V8h14V19z"></path>
                    </g>
                    <g id="error">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M13,17h-2v-2h2V17z M13,13h-2V7h2V13z"></path>
                    </g>
                    <g id="event">
                        <path d="M17,12h-5v5h5V12z M16,1v2H8V1H6v2H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5c0-1.1-0.9-2-2-2h-1V1H16z M19,19H5V8h14V19z"></path>
                    </g>
                    <g id="exit-to-app">
                        <path d="M10.1,15.6l1.4,1.4l5-5l-5-5l-1.4,1.4l2.6,2.6H3v2h9.7L10.1,15.6z M19,3H5C3.9,3,3,3.9,3,5v4h2V5h14v14H5v-4H3v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z"></path>
                    </g>
                    <g id="expand-less">
                        <polygon points="12,8 6,14 7.4,15.4 12,10.8 16.6,15.4 18,14 "></polygon>
                    </g>
                    <g id="expand-more">
                        <polygon points="16.6,8.6 12,13.2 7.4,8.6 6,10 12,16 18,10 "></polygon>
                    </g>
                    <g id="explore">
                        <path d="M12,10.9c-0.6,0-1.1,0.5-1.1,1.1s0.5,1.1,1.1,1.1c0.6,0,1.1-0.5,1.1-1.1S12.6,10.9,12,10.9z M12,2C6.5,2,2,6.5,2,12c0,5.5,4.5,10,10,10c5.5,0,10-4.5,10-10C22,6.5,17.5,2,12,2z M14.2,14.2L6,18l3.8-8.2L18,6L14.2,14.2z"></path>
                    </g>
                    <g id="extension">
                        <path d="M20.5,11H19V7c0-1.1-0.9-2-2-2h-4V3.5C13,2.1,11.9,1,10.5,1C9.1,1,8,2.1,8,3.5V5H4C2.9,5,2,5.9,2,7l0,3.8h1.5c1.5,0,2.7,1.2,2.7,2.7S5,16.2,3.5,16.2H2L2,20c0,1.1,0.9,2,2,2h3.8v-1.5c0-1.5,1.2-2.7,2.7-2.7c1.5,0,2.7,1.2,2.7,2.7V22H17c1.1,0,2-0.9,2-2v-4h1.5c1.4,0,2.5-1.1,2.5-2.5S21.9,11,20.5,11z"></path>
                    </g>
                    <g id="favorite">
                        <path d="M12,21.4L10.6,20C5.4,15.4,2,12.3,2,8.5C2,5.4,4.4,3,7.5,3c1.7,0,3.4,0.8,4.5,2.1C13.1,3.8,14.8,3,16.5,3C19.6,3,22,5.4,22,8.5c0,3.8-3.4,6.9-8.6,11.5L12,21.4z"></path>
                    </g>
                    <g id="favorite-outline">
                        <path d="M16.5,3c-1.7,0-3.4,0.8-4.5,2.1C10.9,3.8,9.2,3,7.5,3C4.4,3,2,5.4,2,8.5c0,3.8,3.4,6.9,8.6,11.5l1.4,1.3l1.4-1.3c5.1-4.7,8.6-7.8,8.6-11.5C22,5.4,19.6,3,16.5,3z M12.1,18.6L12,18.6l-0.1-0.1C7.1,14.2,4,11.4,4,8.5C4,6.5,5.5,5,7.5,5c1.5,0,3,1,3.6,2.4h1.9C13.5,6,15,5,16.5,5c2,0,3.5,1.5,3.5,3.5C20,11.4,16.9,14.2,12.1,18.6z"></path>
                    </g>
                    <g id="file-download">
                        <path d="M19,9h-4V3H9v6H5l7,7L19,9z M5,18v2h14v-2H5z"></path>
                    </g>
                    <g id="file-map">
                        <path d="M12,6.5c-0.8,0-1.5,0.7-1.5,1.5s0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5S12.8,6.5,12,6.5z M19,1H5C3.9,1,3,1.9,3,3v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V3C21,1.9,20.1,1,19,1z M12.5,17h-1c-1-4.1-4-5.8-4-9c0-2.5,2-4.5,4.5-4.5c2.5,0,4.5,2,4.5,4.5C16.5,11.2,13.5,12.9,12.5,17z"></path>
                    </g>
                    <g id="file-upload">
                        <polygon points="9,16 15,16 15,10 19,10 12,3 5,10 9,10 "></polygon>
                        <rect x="5" y="18" width="14" height="2"></rect>
                    </g>
                    <g id="filter">
                        <path d="M10,18h4v-2h-4V18z M3,6v2h18V6H3z M6,13h12v-2H6V13z"></path>
                    </g>
                    <g id="flag">
                        <polygon points="14.4,6 14,4 5,4 5,21 7,21 7,14 12.6,14 13,16 20,16 20,6 "></polygon>
                    </g>
                    <g id="flip-to-back">
                        <path d="M9,7H7l0,2h2V7z M9,11H7v2h2V11z M9,3C7.9,3,7,3.9,7,5h2V3z M13,15h-2v2h2V15z M19,3v2h2C21,3.9,20.1,3,19,3z M13,3h-2v2h2V3z M9,17v-2H7C7,16.1,7.9,17,9,17z M19,13h2v-2h-2V13z M19,9h2V7h-2V9z M19,17c1.1,0,2-0.9,2-2h-2V17z M5,7H3v2h0l0,10c0,1.1,0.9,2,2,2h12v-2H5V7z M15,5h2V3h-2V5z M15,17h2v-2h-2V17z"></path>
                    </g>
                    <g id="flip-to-front">
                        <path d="M3,13h2v-2H3L3,13z M3,17h2v-2H3V17z M5,21v-2H3C3,20.1,3.9,21,5,21z M3,9h2V7H3V9z M15,21h2v-2h-2V21z M19,3H9C7.9,3,7,3.9,7,5v2h0v2v6c0,1.1,0.9,2,2,2h5h4h1c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,15H9V5h10V15z M11,21h2v-2h-2V21z M7,21h2v-2H7V21z"></path>
                    </g>
                    <g id="folder">
                        <path d="M10,4H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8c0-1.1-0.9-2-2-2h-8L10,4z"></path>
                    </g>
                    <g id="folder-mydrive">
                        <path d="M20,6h-8l-2-2H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M11.5,17l-1.1-2.1l2.8-5l1.5,2.7L12.3,17H11.5z M18.3,17h-5.5l1.4-2.5h5.1l0.3,0.5L18.3,17z M13.8,9h2.4l2.8,5H16l-2.6-4.5L13.8,9z"></path>
                    </g>
                    <g id="folder-open">
                        <path d="M20,6h-8l-2-2H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M20,18H4V8h16V18z"></path>
                    </g>
                    <g id="folder-shared">
                        <path d="M20,6h-8l-2-2H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M15,9c1.1,0,2,0.9,2,2c0,1.1-0.9,2-2,2c-1.1,0-2-0.9-2-2C13,9.9,13.9,9,15,9z M19,17h-8v-1c0-1.3,2.7-2,4-2c1.3,0,4,0.7,4,2V17z"></path>
                    </g>
                    <g id="forward">
                        <polygon points="12,8 12,4 20,12 12,20 12,16 4,16 4,8 "></polygon>
                    </g>
                    <g id="fullscreen">
                        <path d="M7,14H5v5h5v-2H7V14z M5,10h2V7h3V5H5V10z M17,17h-3v2h5v-5h-2V17z M14,5v2h3v3h2V5H14z"></path>
                    </g>
                    <g id="fullscreen-exit">
                        <path d="M5,16h3v3h2v-5H5V16z M8,8H5v2h5V5H8V8z M14,19h2v-3h3v-2h-5V19z M16,8V5h-2v5h5V8H16z"></path>
                    </g>
                    <g id="gesture">
                        <path d="M4.6,6.9C5.3,6.2,6,5.5,6.3,5.7c0.5,0.2,0,1-0.3,1.5c-0.3,0.4-2.9,3.9-2.9,6.3c0,1.3,0.5,2.3,1.3,3c0.8,0.6,1.7,0.7,2.6,0.5c1.1-0.3,1.9-1.4,3.1-2.8c1.2-1.5,2.8-3.4,4.1-3.4c1.6,0,1.6,1,1.8,1.8c-3.8,0.6-5.4,3.7-5.4,5.4c0,1.7,1.4,3.1,3.2,3.1c1.6,0,4.3-1.3,4.7-6.1H21v-2.5h-2.5c-0.2-1.6-1.1-4.2-4-4.2c-2.2,0-4.2,1.9-4.9,2.8c-0.6,0.7-2.1,2.5-2.3,2.7c-0.3,0.3-0.7,0.8-1.1,0.8c-0.4,0-0.7-0.8-0.4-1.9c0.4-1.1,1.4-2.9,1.9-3.5C8.4,8,8.9,7.2,8.9,5.9C8.9,3.7,7.3,3,6.4,3C5.1,3,4,4,3.7,4.3C3.4,4.6,3.1,4.9,2.8,5.2L4.6,6.9z M13.9,18.6c-0.3,0-0.7-0.3-0.7-0.7c0-0.6,0.7-2.2,2.9-2.8C15.7,17.8,14.6,18.6,13.9,18.6z"></path>
                    </g>
                    <g id="get-app">
                        <path d="M19,9h-4V3H9v6H5l7,7L19,9z M5,18v2h14v-2H5z"></path>
                    </g>
                    <g id="google">
                        <path d="M16.3,13.4l-1.1-0.8c-0.4-0.3-0.8-0.7-0.8-1.4c0-0.7,0.5-1.3,1-1.6c1.3-1,2.6-2.1,2.6-4.3c0-2.1-1.3-3.3-2-3.9h1.7L18.9,0h-6.2C8.3,0,6.1,2.8,6.1,5.8c0,2.3,1.8,4.8,5,4.8h0.8c-0.1,0.3-0.4,0.8-0.4,1.3c0,1,0.4,1.4,0.9,2c-1.4,0.1-4,0.4-5.9,1.6c-1.8,1.1-2.3,2.6-2.3,3.7c0,2.3,2.1,4.5,6.6,4.5c5.4,0,8-3,8-5.9C18.8,15.7,17.7,14.6,16.3,13.4z M8.7,4.3c0-2.2,1.3-3.2,2.7-3.2c2.6,0,4,3.5,4,5.5c0,2.6-2.1,3.1-2.9,3.1C10,9.7,8.7,6.6,8.7,4.3z M12.3,22.3c-3.3,0-5.4-1.5-5.4-3.7c0-2.2,2-2.9,2.6-3.2c1.3-0.4,3-0.5,3.3-0.5c0.3,0,0.5,0,0.7,0c2.4,1.7,3.4,2.4,3.4,4C16.9,20.8,15,22.3,12.3,22.3z"></path>
                    </g>
                    <g id="google-plus">
                        <path d="M21,10V7h-2v3h-3v2h3v3h2v-3h3v-2H21z M13.3,13.4l-1.1-0.8c-0.4-0.3-0.8-0.7-0.8-1.4c0-0.7,0.5-1.3,1-1.6c1.3-1,2.6-2.1,2.6-4.3c0-2.1-1.3-3.3-2-3.9h1.7L15.9,0H9.7C5.3,0,3.1,2.8,3.1,5.8c0,2.3,1.8,4.8,5,4.8h0.8c-0.1,0.3-0.4,0.8-0.4,1.3c0,1,0.4,1.4,0.9,2c-1.4,0.1-4,0.4-5.9,1.6c-1.8,1.1-2.3,2.6-2.3,3.7c0,2.3,2.1,4.5,6.6,4.5c5.4,0,8-3,8-5.9C15.8,15.7,14.7,14.6,13.3,13.4z M5.7,4.3c0-2.2,1.3-3.2,2.7-3.2c2.6,0,4,3.5,4,5.5c0,2.6-2.1,3.1-2.9,3.1C7,9.7,5.7,6.6,5.7,4.3z M9.3,22.3c-3.3,0-5.4-1.5-5.4-3.7c0-2.2,2-2.9,2.6-3.2c1.3-0.4,3-0.5,3.3-0.5c0.3,0,0.5,0,0.7,0c2.4,1.7,3.4,2.4,3.4,4C13.9,20.8,12,22.3,9.3,22.3z"></path>
                    </g>
                    <g id="grade">
                        <polygon points="12,17.3 18.2,21 16.5,14 22,9.2 14.8,8.6 12,2 9.2,8.6 2,9.2 7.5,14 5.8,21 "></polygon>
                    </g>
                    <g id="group-work">
                        <path d="M12,2C6.5,2,2,6.5,2,12c0,5.5,4.5,10,10,10c5.5,0,10-4.5,10-10C22,6.5,17.5,2,12,2z M8,17.5c-1.4,0-2.5-1.1-2.5-2.5s1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5S9.4,17.5,8,17.5z M9.5,8c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5s-1.1,2.5-2.5,2.5S9.5,9.4,9.5,8z M16,17.5c-1.4,0-2.5-1.1-2.5-2.5s1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5S17.4,17.5,16,17.5z"></path>
                    </g>
                    <g id="help">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M13,19h-2v-2h2V19z M15.1,11.3l-0.9,0.9C13.4,12.9,13,13.5,13,15h-2v-0.5c0-1.1,0.4-2.1,1.2-2.8l1.2-1.3C13.8,10.1,14,9.6,14,9c0-1.1-0.9-2-2-2c-1.1,0-2,0.9-2,2H8c0-2.2,1.8-4,4-4c2.2,0,4,1.8,4,4C16,9.9,15.6,10.7,15.1,11.3z"></path>
                    </g>
                    <g id="highlight-remove">
                        <path d="M14.6,8L12,10.6L9.4,8L8,9.4l2.6,2.6L8,14.6L9.4,16l2.6-2.6l2.6,2.6l1.4-1.4L13.4,12L16,9.4L14.6,8z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="history">
                        <path opacity="0.9" d="M13,3c-5,0-9,4-9,9H1l3.9,3.9c0,0,0,0.1,0.1,0.1l4-4H6c0-3.9,3.1-7,7-7c3.9,0,7,3.1,7,7s-3.1,7-7,7c-1.9,0-3.7-0.8-4.9-2.1l-1.4,1.4C8.3,20,10.5,21,13,21c5,0,9-4,9-9S18,3,13,3z M12,8v5l4.3,2.5l0.7-1.2l-3.5-2.1V8H12z"></path>
                    </g>
                    <g id="home">
                        <polygon points="10,20 10,14 14,14 14,20 19,20 19,12 22,12 12,3 2,12 5,12 5,20 "></polygon>
                    </g>
                    <g id="https">
                        <path d="M18,8h-1V6c0-2.8-2.2-5-5-5C9.2,1,7,3.2,7,6v2H6c-1.1,0-2,0.9-2,2v10c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V10C20,8.9,19.1,8,18,8z M12,17c-1.1,0-2-0.9-2-2s0.9-2,2-2c1.1,0,2,0.9,2,2S13.1,17,12,17z M15.1,8H8.9V6c0-1.7,1.4-3.1,3.1-3.1c1.7,0,3.1,1.4,3.1,3.1V8z"></path>
                    </g>
                    <g id="inbox">
                        <path d="M19,3H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,15h-4c0,1.7-1.3,3-3,3c-1.7,0-3-1.3-3-3H5V5h14V15z M16,10h-2V7h-4v3H8l4,4L16,10z"></path>
                    </g>
                    <g id="info">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M13,17h-2v-6h2V17z M13,9h-2V7h2V9z"></path>
                    </g>
                    <g id="info-outline">
                        <path d="M11,17h2v-6h-2V17z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z M11,9h2V7h-2V9z"></path>
                    </g>
                    <g id="input">
                        <path d="M21,3H3C1.9,3,1,3.9,1,5v4h2V5h18v14H3v-4H1v4c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3z M11,16l4-4l-4-4v3H1v2h10V16z"></path>
                    </g>
                    <g id="invert-colors">
                        <path d="M17.7,7.9L12,2.3l0,0v0L6.3,7.9c-3.1,3.1-3.1,8.2,0,11.3c1.6,1.6,3.6,2.3,5.7,2.3c2,0,4.1-0.8,5.7-2.3C20.8,16.1,20.8,11.1,17.7,7.9z M12,19.6L12,19.6c-1.6,0-3.1-0.6-4.2-1.8C6.6,16.7,6,15.2,6,13.6c0-1.6,0.6-3.1,1.8-4.2L12,5.1L12,19.6z"></path>
                    </g>
                    <g id="keep">
                        <path d="M16,12V4h1V2H7v2h1v8l-2,2v2h5.2v6h1.6v-6H18v-2L16,12z"></path>
                    </g>
                    <g id="label">
                        <path d="M17.6,5.8C17.3,5.3,16.7,5,16,5L5,5C3.9,5,3,5.9,3,7v10c0,1.1,0.9,2,2,2l11,0c0.7,0,1.3-0.3,1.6-0.8L22,12L17.6,5.8z"></path>
                    </g>
                    <g id="label-outline">
                        <path d="M17.6,5.8C17.3,5.3,16.7,5,16,5L5,5C3.9,5,3,5.9,3,7v10c0,1.1,0.9,2,2,2l11,0c0.7,0,1.3-0.3,1.6-0.8L22,12L17.6,5.8z M16,17H5V7h11l3.5,5L16,17z"></path>
                    </g>
                    <g id="language">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M18.9,8H16c-0.3-1.3-0.8-2.4-1.4-3.6C16.4,5.1,18,6.3,18.9,8z M12,4c0.8,1.2,1.5,2.5,1.9,4h-3.8C10.5,6.6,11.2,5.2,12,4z M4.3,14C4.1,13.4,4,12.7,4,12s0.1-1.4,0.3-2h3.4c-0.1,0.7-0.1,1.3-0.1,2s0.1,1.3,0.1,2H4.3z M5.1,16H8c0.3,1.3,0.8,2.4,1.4,3.6C7.6,18.9,6,17.7,5.1,16z M8,8H5.1c1-1.7,2.5-2.9,4.3-3.6C8.8,5.6,8.3,6.7,8,8z M12,20c-0.8-1.2-1.5-2.5-1.9-4h3.8C13.5,17.4,12.8,18.8,12,20z M14.3,14H9.7c-0.1-0.7-0.2-1.3-0.2-2s0.1-1.3,0.2-2h4.7c0.1,0.7,0.2,1.3,0.2,2S14.4,13.3,14.3,14z M14.6,19.6c0.6-1.1,1.1-2.3,1.4-3.6h2.9C18,17.7,16.4,18.9,14.6,19.6z M16.4,14c0.1-0.7,0.1-1.3,0.1-2s-0.1-1.3-0.1-2h3.4c0.2,0.6,0.3,1.3,0.3,2s-0.1,1.4-0.3,2H16.4z"></path>
                    </g>
                    <g id="launch">
                        <path d="M19,19H5V5h7V3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-7h-2V19z M14,3v2h3.6l-9.8,9.8l1.4,1.4L19,6.4V10h2V3H14z"></path>
                    </g>
                    <g id="link">
                        <path d="M3.9,12c0-1.7,1.4-3.1,3.1-3.1h4V7H7c-2.8,0-5,2.2-5,5s2.2,5,5,5h4v-1.9H7C5.3,15.1,3.9,13.7,3.9,12z M8,13h8v-2H8V13z M17,7h-4v1.9h4c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1h-4V17h4c2.8,0,5-2.2,5-5S19.8,7,17,7z"></path>
                    </g>
                    <g id="list">
                        <path d="M3,13h2v-2H3V13z M3,17h2v-2H3V17z M3,9h2V7H3V9z M7,13h14v-2H7V13z M7,17h14v-2H7V17z M7,7v2h14V7H7z"></path>
                    </g>
                    <g id="lock">
                        <path d="M18,8h-1V6c0-2.8-2.2-5-5-5C9.2,1,7,3.2,7,6v2H6c-1.1,0-2,0.9-2,2v10c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V10C20,8.9,19.1,8,18,8z M12,17c-1.1,0-2-0.9-2-2s0.9-2,2-2c1.1,0,2,0.9,2,2S13.1,17,12,17z M15.1,8H8.9V6c0-1.7,1.4-3.1,3.1-3.1c1.7,0,3.1,1.4,3.1,3.1V8z"></path>
                    </g>
                    <g id="lock-open">
                        <path d="M12,17c1.1,0,2-0.9,2-2s-0.9-2-2-2c-1.1,0-2,0.9-2,2S10.9,17,12,17z M18,8h-1V6c0-2.8-2.2-5-5-5C9.2,1,7,3.2,7,6h1.9c0-1.7,1.4-3.1,3.1-3.1c1.7,0,3.1,1.4,3.1,3.1v2H6c-1.1,0-2,0.9-2,2v10c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V10C20,8.9,19.1,8,18,8z M18,20H6V10h12V20z"></path>
                    </g>
                    <g id="lock-outline">
                        <path d="M18,8h-1V6c0-2.8-2.2-5-5-5C9.2,1,7,3.2,7,6v2H6c-1.1,0-2,0.9-2,2v10c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V10C20,8.9,19.1,8,18,8z M12,2.9c1.7,0,3.1,1.4,3.1,3.1v2H9V6H8.9C8.9,4.3,10.3,2.9,12,2.9z M18,20H6V10h12V20z M12,17c1.1,0,2-0.9,2-2s-0.9-2-2-2c-1.1,0-2,0.9-2,2S10.9,17,12,17z"></path>
                    </g>
                    <g id="loyalty">
                        <path d="M21.4,11.6l-9-9C12.1,2.2,11.6,2,11,2H4C2.9,2,2,2.9,2,4v7c0,0.6,0.2,1.1,0.6,1.4l9,9c0.4,0.4,0.9,0.6,1.4,0.6c0.6,0,1.1-0.2,1.4-0.6l7-7c0.4-0.4,0.6-0.9,0.6-1.4C22,12.4,21.8,11.9,21.4,11.6z M5.5,7C4.7,7,4,6.3,4,5.5S4.7,4,5.5,4S7,4.7,7,5.5S6.3,7,5.5,7z M17.3,15.3L13,19.5l-4.3-4.3l0,0C8.3,14.8,8,14.2,8,13.5c0-1.4,1.1-2.5,2.5-2.5c0.7,0,1.3,0.3,1.8,0.7l0.7,0.7l0.7-0.7c0.5-0.5,1.1-0.7,1.8-0.7c1.4,0,2.5,1.1,2.5,2.5C18,14.2,17.7,14.8,17.3,15.3L17.3,15.3z"></path>
                    </g>
                    <g id="mail">
                        <path d="M20,4H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M20,8l-8,5L4,8V6l8,5l8-5V8z"></path>
                    </g>
                    <g id="markunread">
                        <path d="M20,6H10v6H8V4h6V0H6v6H4C2.9,6,2,6.9,2,8l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z"></path>
                    </g>
                    <g id="markunread">
                        <path d="M22,6l2-2l-2-2l-2,2l-2-2l-2,2l-2-2l-2,2l-2-2L8,4L6,2L4,4L2,2L0,4l2,2L0,8l2,2l-2,2l2,2l-2,2l2,2l-2,2l2,2l2-2l2,2l2-2l2,2l2-2l2,2l2-2l2,2l2-2l2,2l2-2l-2-2l2-2l-2-2l2-2l-2-2l2-2L22,6z M20,8l-8,5L4,8V6l8,5l8-5V8z"></path>
                    </g>
                    <g id="menu">
                        <path d="M3,18h18v-2H3V18z M3,13h18v-2H3V13z M3,6v2h18V6H3z"></path>
                    </g>
                    <g id="more-horiz">
                        <path d="M6,10c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S7.1,10,6,10z M18,10c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S19.1,10,18,10z M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S13.1,10,12,10z"></path>
                    </g>
                    <g id="more-vert">
                        <path d="M12,8c1.1,0,2-0.9,2-2s-0.9-2-2-2c-1.1,0-2,0.9-2,2S10.9,8,12,8z M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S13.1,10,12,10z M12,16c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S13.1,16,12,16z"></path>
                    </g>
                    <g id="note-add">
                        <path d="M14,2H6C4.9,2,4,2.9,4,4l0,16c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2V8L14,2z M16,16h-3v3h-2v-3H8v-2h3v-3h2v3h3V16z M13,9V3.5L18.5,9H13z"></path>
                    </g>
                    <g id="open-in-browser">
                        <path d="M19,4H5C3.9,4,3,4.9,3,6v12c0,1.1,0.9,2,2,2h3v-2H5V8h14v10h-3v2h3c1.1,0,2-0.9,2-2V6C21,4.9,20.1,4,19,4z M12,10l-5,5h3v5h4v-5h3L12,10z"></path>
                    </g>
                    <g id="open-in-new">
                        <path d="M19,19H5V5h7V3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-7h-2V19z M14,3v2h3.6l-9.8,9.8l1.4,1.4L19,6.4V10h2V3H14z"></path>
                    </g>
                    <g id="open-with">
                        <path d="M10,9h4V6h3l-5-5L7,6h3V9z M9,10H6V7l-5,5l5,5v-3h3V10z M23,12l-5-5v3h-3v4h3v3L23,12z M14,15h-4v3H7l5,5l5-5h-3V15z"></path>
                    </g>
                    <g id="payment">
                        <path d="M20,4H4C2.9,4,2,4.9,2,6l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M20,18H4v-6h16V18z M20,8H4V6h16V8z"></path>
                    </g>
                    <g id="perm-camera-mic">
                        <path d="M20,5h-3.2L15,3H9L7.2,5H4C2.9,5,2,5.9,2,7v12c0,1.1,0.9,2,2,2h7v-2.1C8.2,18.4,6,16,6,13h2c0,2.2,1.8,4,4,4s4-1.8,4-4h2c0,3-2.2,5.4-5,5.9V21h7c1.1,0,2-0.9,2-2V7C22,5.9,21.1,5,20,5z M14,13c0,1.1-0.9,2-2,2s-2-0.9-2-2V9c0-1.1,0.9-2,2-2s2,0.9,2,2V13z"></path>
                    </g>
                    <g id="perm-contact-cal">
                        <path d="M19,3h-1V1h-2v2H8V1H6v2H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M12,6c1.7,0,3,1.3,3,3c0,1.7-1.3,3-3,3s-3-1.3-3-3C9,7.3,10.3,6,12,6z M18,18H6v-1c0-2,4-3.1,6-3.1s6,1.1,6,3.1V18z"></path>
                    </g>
                    <g id="perm-data-setting">
                        <path d="M19,11.5c0.3,0,0.7,0,1,0.1V0L0,20h11.6c0-0.3-0.1-0.7-0.1-1C11.5,14.9,14.9,11.5,19,11.5z M22.7,19.5c0-0.2,0-0.3,0-0.5c0-0.2,0-0.3,0-0.5l1.1-0.8c0.1-0.1,0.1-0.2,0.1-0.3l-1-1.7c-0.1-0.1-0.2-0.2-0.3-0.1L21.3,16c-0.3-0.2-0.5-0.4-0.8-0.5l-0.2-1.3c0-0.1-0.1-0.2-0.2-0.2h-2c-0.1,0-0.2,0.1-0.2,0.2l-0.2,1.3c-0.3,0.1-0.6,0.3-0.8,0.5l-1.2-0.5c-0.1,0-0.2,0-0.3,0.1l-1,1.7c-0.1,0.1,0,0.2,0.1,0.3l1.1,0.8c0,0.2,0,0.3,0,0.5c0,0.2,0,0.3,0,0.5l-1.1,0.8c-0.1,0.1-0.1,0.2-0.1,0.3l1,1.7c0.1,0.1,0.2,0.2,0.3,0.1l1.2-0.5c0.3,0.2,0.5,0.4,0.8,0.5l0.2,1.3c0,0.1,0.1,0.2,0.2,0.2h2c0.1,0,0.2-0.1,0.2-0.2l0.2-1.3c0.3-0.1,0.6-0.3,0.8-0.5l1.2,0.5c0.1,0,0.2,0,0.3-0.1l1-1.7c0.1-0.1,0-0.2-0.1-0.3L22.7,19.5z M19,20.5c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5s1.5,0.7,1.5,1.5S19.8,20.5,19,20.5z"></path>
                    </g>
                    <g id="perm-device-info">
                        <path d="M13,7h-2v2h2V7z M13,11h-2v6h2V11z M17,1L7,1C5.9,1,5,1.9,5,3v18c0,1.1,0.9,2,2,2h10c1.1,0,2-0.9,2-2V3C19,1.9,18.1,1,17,1z M17,19H7V5h10V19z"></path>
                    </g>
                    <g id="perm-identity">
                        <path d="M12,5.9c1.2,0,2.1,0.9,2.1,2.1s-0.9,2.1-2.1,2.1S9.9,9.2,9.9,8S10.8,5.9,12,5.9 M12,14.9c3,0,6.1,1.5,6.1,2.1v1.1H5.9V17C5.9,16.4,9,14.9,12,14.9 M12,4C9.8,4,8,5.8,8,8c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,5.8,14.2,4,12,4L12,4z M12,13c-2.7,0-8,1.3-8,4v3h16v-3C20,14.3,14.7,13,12,13L12,13z"></path>
                    </g>
                    <g id="perm-media">
                        <path d="M2,6H0v5h0l0,9c0,1.1,0.9,2,2,2h18v-2H2V6z M22,4h-8l-2-2H6C4.9,2,4,2.9,4,4l0,12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C24,4.9,23.1,4,22,4z M7,15l4.5-6l3.5,4.5l2.5-3L21,15H7z"></path>
                    </g>
                    <g id="perm-phone-msg">
                        <path d="M20,15.5c-1.2,0-2.4-0.2-3.6-0.6c-0.3-0.1-0.7,0-1,0.2l-2.2,2.2c-2.8-1.4-5.1-3.8-6.6-6.6l2.2-2.2c0.3-0.3,0.4-0.7,0.2-1C8.7,6.4,8.5,5.2,8.5,4c0-0.6-0.4-1-1-1H4C3.5,3,3,3.4,3,4c0,9.4,7.6,17,17,17c0.6,0,1-0.4,1-1v-3.5C21,15.9,20.6,15.5,20,15.5z M12,3v10l3-3h6V3H12z"></path>
                    </g>
                    <g id="perm-scan-wifi">
                        <path d="M12,3C7,3,3.2,4.9,0,7.2L12,22L24,7.3C20.9,4.9,17.1,3,12,3z M13,16h-2v-6h2V16z M11,8V6h2v2H11z"></path>
                    </g>
                    <g id="picture-in-picture">
                        <path d="M19,7h-8v6h8V7z M21,3H3C1.9,3,1,3.9,1,5v14c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3z M21,19H3V5h18V19z"></path>
                    </g>
                    <g id="polymer">
                        <polygon points="19,4 15,4 7.1,16.6 4.5,12 9,4 5,4 0.5,12 5,20 9,20 16.9,7.4 19.5,12 15,20 19,20 23.5,12 "></polygon>
                    </g>
                    <g id="print">
                        <path d="M19,8H5c-1.7,0-3,1.3-3,3v6h4v4h12v-4h4v-6C22,9.3,20.7,8,19,8z M16,19H8v-5h8V19z M19,12c-0.6,0-1-0.4-1-1s0.4-1,1-1c0.6,0,1,0.4,1,1S19.6,12,19,12z M18,3H6v4h12V3z"></path>
                    </g>
                    <g id="query-builder">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                        <polygon points="12.5,7 11,7 11,13 16.2,16.2 17,14.9 12.5,12.3 "></polygon>
                    </g>
                    <g id="question-answer">
                        <path d="M21,6h-2v9H6v2c0,0.6,0.4,1,1,1h11l4,4V7C22,6.4,21.6,6,21,6z M17,12V3c0-0.6-0.4-1-1-1H3C2.4,2,2,2.4,2,3v14l4-4h10C16.6,13,17,12.6,17,12z"></path>
                    </g>
                    <g id="radio-button-off">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="radio-button-on">
                        <path d="M12,7c-2.8,0-5,2.2-5,5s2.2,5,5,5c2.8,0,5-2.2,5-5S14.8,7,12,7z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="receipt">
                        <path d="M18,17H6v-2h12V17z M18,13H6v-2h12V13z M18,9H6V7h12V9z M3,22l1.5-1.5L6,22l1.5-1.5L9,22l1.5-1.5L12,22l1.5-1.5L15,22l1.5-1.5L18,22l1.5-1.5L21,22V2l-1.5,1.5L18,2l-1.5,1.5L15,2l-1.5,1.5L12,2l-1.5,1.5L9,2L7.5,3.5L6,2L4.5,3.5L3,2V22z"></path>
                    </g>
                    <g id="redeem">
                        <path d="M20,6h-2.2C17.9,5.7,18,5.4,18,5c0-1.7-1.3-3-3-3c-1,0-2,0.5-2.5,1.3l0,0L12,4l-0.5-0.7l0,0C11,2.5,10.1,2,9,2C7.4,2,6,3.3,6,5c0,0.4,0.1,0.7,0.2,1H4C2.9,6,2,6.9,2,8l0,11c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M15,4c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S14.5,4,15,4z M9,4c0.6,0,1,0.4,1,1S9.6,6,9,6S8,5.6,8,5S8.5,4,9,4z M20,19H4v-2h16V19z M20,14H4V8h5.1L7,10.8L8.6,12L11,8.8l1-1.4l1,1.4l2.4,3.2l1.6-1.2L14.9,8H20V14z"></path>
                    </g>
                    <g id="refresh">
                        <path d="M17.6,6.4C16.2,4.9,14.2,4,12,4c-4.4,0-8,3.6-8,8s3.6,8,8,8c3.7,0,6.8-2.6,7.7-6h-2.1c-0.8,2.3-3,4-5.6,4c-3.3,0-6-2.7-6-6s2.7-6,6-6c1.7,0,3.1,0.7,4.2,1.8L13,11h7V4L17.6,6.4z"></path>
                    </g>
                    <g id="reminder">
                        <path d="M16.9,13c1.3-1.3,2.1-3,2.1-5c0-3.9-3.1-7-7-7C8.1,1,5,4.1,5,8c0,2,0.8,3.7,2.1,5l0,0l3.5,3.5L6,21.1l1.4,1.4L16.9,13z M15.5,11.5L15.5,11.5L12,15.1l-3.5-3.5l0,0l0,0C7.6,10.6,7,9.4,7,8c0-2.8,2.2-5,5-5c2.8,0,5,2.2,5,5C17,9.4,16.4,10.6,15.5,11.5L15.5,11.5z M13.4,19.3l3.2,3.2l1.4-1.4l-3.2-3.2L13.4,19.3z"></path>
                    </g>
                    <g id="remove">
                        <path d="M19,13H5v-2h14V13z"></path>
                    </g>
                    <g id="remove-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M17,13H7v-2h10V13z"></path>
                    </g>
                    <g id="remove-circle-outline">
                        <path d="M7,11v2h10v-2H7z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                    </g>
                    <g id="reorder">
                        <path d="M4,16h16v-2H4V16z M4,9v2h16V9H4z"></path>
                    </g>
                    <g id="reply">
                        <path d="M10,9V5l-7,7l7,7v-4.1c5,0,8.5,1.6,11,5.1C20,15,17,10,10,9z"></path>
                    </g>
                    <g id="reply-all">
                        <path d="M7,8V5l-7,7l7,7v-3l-4-4L7,8z M13,9V5l-7,7l7,7v-4.1c5,0,8.5,1.6,11,5.1C23,15,20,10,13,9z"></path>
                    </g>
                    <g id="report">
                        <path d="M15.7,3H8.3L3,8.3v7.5L8.3,21h7.5l5.3-5.3V8.3L15.7,3z M12,17.3c-0.7,0-1.3-0.6-1.3-1.3c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3C13.3,16.7,12.7,17.3,12,17.3z M13,13h-2V7h2V13z"></path>
                    </g>
                    <g id="report-problem">
                        <path d="M1,21h22L12,2L1,21z M13,18h-2v-2h2V18z M13,14h-2v-4h2V14z"></path>
                    </g>
                    <g id="restore">
                        <path d="M13,3c-5,0-9,4-9,9H1l3.9,3.9c0,0,0,0.1,0.1,0.1l4-4H6c0-3.9,3.1-7,7-7c3.9,0,7,3.1,7,7s-3.1,7-7,7c-1.9,0-3.7-0.8-4.9-2.1l-1.4,1.4C8.3,20,10.5,21,13,21c5,0,9-4,9-9S18,3,13,3z M12,8v5l4.3,2.5l0.7-1.2l-3.5-2.1V8H12z"></path>
                    </g>
                    <g id="room">
                        <path d="M12,2C8.1,2,5,5.1,5,9c0,5.2,7,13,7,13s7-7.8,7-13C19,5.1,15.9,2,12,2z M12,11.5c-1.4,0-2.5-1.1-2.5-2.5s1.1-2.5,2.5-2.5c1.4,0,2.5,1.1,2.5,2.5S13.4,11.5,12,11.5z"></path>
                    </g>
                    <g id="rotate-left">
                        <path d="M7.1,8.5L5.7,7.1C4.8,8.3,4.2,9.6,4.1,11h2C6.2,10.1,6.6,9.3,7.1,8.5z M6.1,13h-2c0.2,1.4,0.7,2.7,1.6,3.9l1.4-1.4C6.6,14.7,6.2,13.9,6.1,13z M7.1,18.3c1.2,0.9,2.5,1.4,3.9,1.6v-2c-0.9-0.1-1.7-0.5-2.5-1L7.1,18.3z M13,4.1V1L8.5,5.5L13,10V6.1c2.8,0.5,5,2.9,5,5.9s-2.2,5.4-5,5.9v2c3.9-0.5,7-3.9,7-7.9S16.9,4.6,13,4.1z"></path>
                    </g>
                    <g id="rotate-right">
                        <path d="M15.5,5.5L11,1v3.1C7.1,4.6,4,7.9,4,12s3.1,7.4,7,7.9v-2C8.2,17.4,6,15,6,12s2.2-5.4,5-5.9V10L15.5,5.5z M19.9,11c-0.2-1.4-0.7-2.7-1.6-3.9l-1.4,1.4c0.5,0.8,0.9,1.6,1,2.5H19.9z M13,17.9v2c1.4-0.2,2.7-0.7,3.9-1.6l-1.4-1.4C14.7,17.4,13.9,17.8,13,17.9z M16.9,15.5l1.4,1.4c0.9-1.2,1.5-2.5,1.6-3.9h-2C17.8,13.9,17.4,14.7,16.9,15.5z"></path>
                    </g>
                    <g id="rotation-3d">
                        <path d="M11,14v-1c0-0.6-0.4-1-1-1c0.6,0,1-0.4,1-1v-1c0-1.1-0.9-2-2-2H6v2h3v1H7v2h2v1l0,0l0,0v0h0H6v2h3C10.1,16,11,15.1,11,14z M15,8h-3v8h3c1.7,0,3-1.3,3-3v-2C18,9.3,16.7,8,15,8z M16,13c0,0.6-0.4,1-1,1h-1v-4h1c0.6,0,1,0.4,1,1V13z M12,0c-0.2,0-0.4,0-0.7,0l3.8,3.8l1.3-1.3c3.3,1.5,5.6,4.7,6,8.5h1.5C23.4,4.8,18.3,0,12,0z M7.5,21.5c-3.3-1.5-5.6-4.7-6-8.5H0.1C0.6,19.2,5.7,24,12,24c0.2,0,0.4,0,0.7,0l-3.8-3.8L7.5,21.5z"></path>
                    </g>
                    <g id="save">
                        <path d="M17,3H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V7L17,3z M12,19c-1.7,0-3-1.3-3-3s1.3-3,3-3c1.7,0,3,1.3,3,3S13.7,19,12,19z M15,9H5V5h10V9z"></path>
                    </g>
                    <g id="schedule">
                        <path fill-opacity="0.9" d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M12,20c-4.4,0-8-3.6-8-8s3.6-8,8-8c4.4,0,8,3.6,8,8S16.4,20,12,20z"></path>
                        <polygon fill-opacity="0.9" points="12.5,7 11,7 11,13 16.2,16.2 17,14.9 12.5,12.2 "></polygon>
                    </g>
                    <g id="search">
                        <path d="M15.5,14h-0.8l-0.3-0.3c1-1.1,1.6-2.6,1.6-4.2C16,5.9,13.1,3,9.5,3C5.9,3,3,5.9,3,9.5S5.9,16,9.5,16c1.6,0,3.1-0.6,4.2-1.6l0.3,0.3v0.8l5,5l1.5-1.5L15.5,14z M9.5,14C7,14,5,12,5,9.5S7,5,9.5,5C12,5,14,7,14,9.5S12,14,9.5,14z"></path>
                    </g>
                    <g id="select-all">
                        <path d="M3,5h2V3C3.9,3,3,3.9,3,5z M3,13h2v-2H3V13z M7,21h2v-2H7V21z M3,9h2V7H3V9z M13,3h-2v2h2V3z M19,3v2h2C21,3.9,20.1,3,19,3z M5,21v-2H3C3,20.1,3.9,21,5,21z M3,17h2v-2H3V17z M9,3H7v2h2V3z M11,21h2v-2h-2V21z M19,13h2v-2h-2V13z M19,21c1.1,0,2-0.9,2-2h-2V21z M19,9h2V7h-2V9z M19,17h2v-2h-2V17z M15,21h2v-2h-2V21z M15,5h2V3h-2V5z M7,17h10V7H7V17z M9,9h6v6H9V9z"></path>
                    </g>
                    <g id="send">
                        <polygon points="2,21 23,12 2,3 2,10 17,12 2,14 "></polygon>
                    </g>
                    <g id="send-money">
                        <path d="M2,12c0-2.6,1.7-4.8,4-5.7V4.3c-3.4,0.9-6,4-6,7.7s2.6,6.8,6,7.7v-2.1C3.7,16.8,2,14.6,2,12z M24,12l-4-4v3h-7v2h7v3L24,12z M14,18c-3.3,0-6-2.7-6-6s2.7-6,6-6c1.7,0,3.2,0.7,4.2,1.8l1.4-1.4C18.2,4.9,16.2,4,14,4c-4.4,0-8,3.6-8,8s3.6,8,8,8c2.2,0,4.2-0.9,5.7-2.3l-1.4-1.4C17.2,17.3,15.7,18,14,18z"></path>
                    </g>
                    <g id="settings">
                        <path d="M19.4,13c0-0.3,0.1-0.6,0.1-1s0-0.7-0.1-1l2.1-1.7c0.2-0.2,0.2-0.4,0.1-0.6l-2-3.5C19.5,5.1,19.3,5,19,5.1l-2.5,1c-0.5-0.4-1.1-0.7-1.7-1l-0.4-2.6C14.5,2.2,14.2,2,14,2h-4C9.8,2,9.5,2.2,9.5,2.4L9.1,5.1C8.5,5.3,8,5.7,7.4,6.1L5,5.1C4.7,5,4.5,5.1,4.3,5.3l-2,3.5C2.2,8.9,2.3,9.2,2.5,9.4L4.6,11c0,0.3-0.1,0.6-0.1,1s0,0.7,0.1,1l-2.1,1.7c-0.2,0.2-0.2,0.4-0.1,0.6l2,3.5C4.5,18.9,4.7,19,5,18.9l2.5-1c0.5,0.4,1.1,0.7,1.7,1l0.4,2.6c0,0.2,0.2,0.4,0.5,0.4h4c0.2,0,0.5-0.2,0.5-0.4l0.4-2.6c0.6-0.3,1.2-0.6,1.7-1l2.5,1c0.2,0.1,0.5,0,0.6-0.2l2-3.5c0.1-0.2,0.1-0.5-0.1-0.6L19.4,13z M12,15.5c-1.9,0-3.5-1.6-3.5-3.5s1.6-3.5,3.5-3.5s3.5,1.6,3.5,3.5S13.9,15.5,12,15.5z"></path>
                    </g>
                    <g id="settings-applications">
                        <path d="M12,10c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S13.1,10,12,10z M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M17.2,12c0,0.2,0,0.5,0,0.7l1.5,1.2c0.1,0.1,0.2,0.3,0.1,0.4l-1.4,2.4c-0.1,0.2-0.3,0.2-0.4,0.2l-1.7-0.7c-0.4,0.3-0.8,0.5-1.2,0.7l-0.3,1.9c0,0.2-0.2,0.3-0.3,0.3h-2.8c-0.2,0-0.3-0.1-0.3-0.3L10,16.9c-0.4-0.2-0.8-0.4-1.2-0.7l-1.7,0.7c-0.2,0.1-0.3,0-0.4-0.2l-1.4-2.4c-0.1-0.2,0-0.3,0.1-0.4l1.5-1.2c0-0.2,0-0.5,0-0.7s0-0.5,0-0.7l-1.5-1.2c-0.1-0.1-0.2-0.3-0.1-0.4l1.4-2.4c0.1-0.2,0.3-0.2,0.4-0.2l1.7,0.7C9.2,7.6,9.6,7.3,10,7.1l0.3-1.9c0-0.2,0.2-0.3,0.3-0.3h2.8c0.2,0,0.3,0.1,0.3,0.3L14,7.1c0.4,0.2,0.8,0.4,1.2,0.7l1.7-0.7c0.2-0.1,0.3,0,0.4,0.2l1.4,2.4c0.1,0.2,0,0.3-0.1,0.4l-1.5,1.2C17.2,11.5,17.2,11.8,17.2,12z"></path>
                    </g>
                    <g id="settings-backup-restore">
                        <path d="M14,12c0-1.1-0.9-2-2-2s-2,0.9-2,2s0.9,2,2,2S14,13.1,14,12z M12,3c-5,0-9,4-9,9H0l4,4l4-4H5c0-3.9,3.1-7,7-7s7,3.1,7,7s-3.1,7-7,7c-1.5,0-2.9-0.5-4.1-1.3l-1.4,1.4C8,20.3,9.9,21,12,21c5,0,9-4,9-9S17,3,12,3z"></path>
                    </g>
                    <g id="settings-bluetooth">
                        <path d="M11,24h2v-2h-2V24z M7,24h2v-2H7V24z M15,24h2v-2h-2V24z M17.7,5.7L12,0h-1v7.6L6.4,3L5,4.4l5.6,5.6L5,15.6L6.4,17l4.6-4.6V20h1l5.7-5.7L13.4,10L17.7,5.7z M13,3.8l1.9,1.9L13,7.6V3.8z M14.9,14.3L13,16.2v-3.8L14.9,14.3z"></path>
                    </g>
                    <g id="settings-cell">
                        <path d="M7,24h2v-2H7V24z M11,24h2v-2h-2V24z M15,24h2v-2h-2V24z M16,0L8,0C6.9,0,6,0.9,6,2v16c0,1.1,0.9,2,2,2h8c1.1,0,2-0.9,2-2V2C18,0.9,17.1,0,16,0z M16,16H8V4h8V16z"></path>
                    </g>
                    <g id="settings-display">
                        <path d="M21,19H3V5h18V19z M21,3H3C1.9,3,1,3.9,1,5v14c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3L21,3z"></path>
                        <path d="M10,12c0-1.1,0.9-2,2-2V8c0.3,0,0.7,0.1,1,0.1V6h-2v2.1c-0.4,0.1-0.7,0.2-1,0.4L8.5,7.1L7.1,8.5L8.6,10c-0.2,0.3-0.3,0.7-0.4,1H6v2h2.1c0.1,0.4,0.2,0.7,0.4,1l-1.5,1.5l1.4,1.4l1.5-1.5c0.3,0.2,0.7,0.3,1,0.4V18h2v-2.1c-0.3,0.1-0.7,0.1-1,0.1v-2C10.9,14,10,13.1,10,12z M15.4,10l1.5-1.5l-1.4-1.4L14,8.6C14.6,8.9,15.1,9.4,15.4,10z M14,15.4l1.5,1.5l1.4-1.4L15.4,14C15.1,14.6,14.6,15.1,14,15.4z M12,10v4c1.1,0,2-0.9,2-2C14,10.9,13.1,10,12,10z M15.9,11c0.1,0.3,0.1,0.7,0.1,1s-0.1,0.7-0.1,1H18v-2H15.9z"></path>
                    </g>
                    <g id="settings-ethernet">
                        <path d="M7.8,6.8L6.2,5.5L0.8,12l5.4,6.5l1.5-1.3L3.4,12L7.8,6.8z M7,13h2v-2H7V13z M17,11h-2v2h2V11z M11,13h2v-2h-2V13z M17.8,5.5l-1.5,1.3l4.3,5.2l-4.3,5.2l1.5,1.3l5.4-6.5L17.8,5.5z"></path>
                    </g>
                    <g id="settings-input-antenna">
                        <path d="M12,5c-3.9,0-7,3.1-7,7h2c0-2.8,2.2-5,5-5s5,2.2,5,5h2C19,8.1,15.9,5,12,5z M13,14.3c0.9-0.4,1.5-1.3,1.5-2.3c0-1.4-1.1-2.5-2.5-2.5S9.5,10.6,9.5,12c0,1,0.6,1.9,1.5,2.3v3.3L7.6,21L9,22.4l3-3l3,3l1.4-1.4L13,17.6V14.3z M12,1C5.9,1,1,5.9,1,12h2c0-5,4-9,9-9s9,4,9,9h2C23,5.9,18.1,1,12,1z"></path>
                    </g>
                    <g id="settings-input-component">
                        <path d="M5,2c0-0.6-0.4-1-1-1S3,1.4,3,2v4H1v6h6V6H5V2z M9,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2H9V16z M1,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2H1V16z M21,6V2c0-0.6-0.4-1-1-1s-1,0.4-1,1v4h-2v6h6V6H21z M13,2c0-0.6-0.4-1-1-1s-1,0.4-1,1v4H9v6h6V6h-2V2z M17,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2h-6V16z"></path>
                    </g>
                    <g id="settings-input-composite">
                        <path d="M5,2c0-0.6-0.4-1-1-1S3,1.4,3,2v4H1v6h6V6H5V2z M9,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2H9V16z M1,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2H1V16z M21,6V2c0-0.6-0.4-1-1-1s-1,0.4-1,1v4h-2v6h6V6H21z M13,2c0-0.6-0.4-1-1-1s-1,0.4-1,1v4H9v6h6V6h-2V2z M17,16c0,1.3,0.8,2.4,2,2.8V23h2v-4.2c1.2-0.4,2-1.5,2-2.8v-2h-6V16z"></path>
                    </g>
                    <g id="settings-input-hdmi">
                        <path d="M18,7V4c0-1.1-0.9-2-2-2H8C6.9,2,6,2.9,6,4v3H5v6l3,6v3h8v-3l3-6V7H18z M8,4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z"></path>
                    </g>
                    <g id="settings-input-svideo">
                        <path d="M8,11.5C8,10.7,7.3,10,6.5,10S5,10.7,5,11.5S5.7,13,6.5,13S8,12.3,8,11.5z M15,6.5C15,5.7,14.3,5,13.5,5h-3C9.7,5,9,5.7,9,6.5S9.7,8,10.5,8h3C14.3,8,15,7.3,15,6.5z M8.5,15C7.7,15,7,15.7,7,16.5S7.7,18,8.5,18s1.5-0.7,1.5-1.5S9.3,15,8.5,15z M12,1C5.9,1,1,5.9,1,12s4.9,11,11,11s11-4.9,11-11S18.1,1,12,1z M12,21c-5,0-9-4-9-9s4-9,9-9s9,4,9,9S17,21,12,21z M17.5,10c-0.8,0-1.5,0.7-1.5,1.5s0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5S18.3,10,17.5,10z M15.5,15c-0.8,0-1.5,0.7-1.5,1.5s0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5S16.3,15,15.5,15z"></path>
                    </g>
                    <g id="settings-overscan">
                        <path d="M12,5.5L10,8h4L12,5.5z M18,10v4l2.5-2L18,10z M6,10l-2.5,2L6,14V10z M14,16h-4l2,2.5L14,16z M21,3H3C1.9,3,1,3.9,1,5v14c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3z M21,19H3V5h18V19z"></path>
                    </g>
                    <g id="settings-phone">
                        <path d="M13,9h-2v2h2V9z M17,9h-2v2h2V9z M20,15.5c-1.2,0-2.4-0.2-3.6-0.6c-0.3-0.1-0.7,0-1,0.2l-2.2,2.2c-2.8-1.4-5.1-3.8-6.6-6.6l2.2-2.2c0.3-0.3,0.4-0.7,0.2-1C8.7,6.4,8.5,5.2,8.5,4c0-0.6-0.4-1-1-1H4C3.4,3,3,3.4,3,4c0,9.4,7.6,17,17,17c0.6,0,1-0.4,1-1v-3.5C21,15.9,20.6,15.5,20,15.5z M19,9v2h2V9H19z"></path>
                    </g>
                    <g id="settings-power">
                        <path d="M7,24h2v-2H7V24z M11,24h2v-2h-2V24z M13,2h-2v10h2V2z M16.6,4.4l-1.4,1.4C16.8,6.9,18,8.8,18,11c0,3.3-2.7,6-6,6c-3.3,0-6-2.7-6-6c0-2.2,1.2-4.1,2.9-5.1L7.4,4.4C5.4,5.9,4,8.3,4,11c0,4.4,3.6,8,8,8c4.4,0,8-3.6,8-8C20,8.3,18.6,5.9,16.6,4.4z M15,24h2v-2h-2V24z"></path>
                    </g>
                    <g id="settings-remote">
                        <path d="M15,9H9c-0.6,0-1,0.4-1,1v12c0,0.6,0.4,1,1,1h6c0.6,0,1-0.4,1-1V10C16,9.4,15.6,9,15,9z M12,15c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S13.1,15,12,15z M7.1,6.1l1.4,1.4C9.4,6.6,10.6,6,12,6s2.6,0.6,3.5,1.5l1.4-1.4C15.7,4.8,13.9,4,12,4S8.3,4.8,7.1,6.1z M12,0C9,0,6.2,1.2,4.2,3.2l1.4,1.4C7.3,3,9.5,2,12,2s4.7,1,6.4,2.6l1.4-1.4C17.8,1.2,15,0,12,0z"></path>
                    </g>
                    <g id="settings-voice">
                        <path d="M7,24h2v-2H7V24z M12,13c1.7,0,3-1.3,3-3l0-6c0-1.7-1.3-3-3-3c-1.7,0-3,1.3-3,3v6C9,11.7,10.3,13,12,13z M11,24h2v-2h-2V24z M15,24h2v-2h-2V24z M19,10h-1.7c0,3-2.5,5.1-5.3,5.1c-2.8,0-5.3-2.1-5.3-5.1H5c0,3.4,2.7,6.2,6,6.7V20h2v-3.3C16.3,16.2,19,13.4,19,10z"></path>
                    </g>
                    <g id="shop">
                        <path d="M16,6V4l-2-2h-4L8,4v2H2v13c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6H16z M10,4h4v2h-4V4z M9,18V9l7.5,4L9,18z"></path>
                    </g>
                    <g id="shop-two">
                        <path d="M18,5V3l-2-2h-4l-2,2v2H5v11c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5H18z M12,3h4v2h-4V3z M12,15V8l5.5,3L12,15z M3,9H1v11c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2H3V9z"></path>
                    </g>
                    <g id="shopping-basket">
                        <path d="M17.2,9l-4.4-6.6C12.6,2.2,12.3,2,12,2c-0.3,0-0.6,0.1-0.8,0.4L6.8,9H2c-0.6,0-1,0.4-1,1c0,0.1,0,0.2,0,0.3l2.5,9.3c0.2,0.8,1,1.5,1.9,1.5h13c0.9,0,1.7-0.6,1.9-1.5l2.5-9.3c0-0.1,0-0.2,0-0.3c0-0.6-0.4-1-1-1H17.2z M9,9l3-4.4L15,9H9z M12,17c-1.1,0-2-0.9-2-2s0.9-2,2-2c1.1,0,2,0.9,2,2S13.1,17,12,17z"></path>
                    </g>
                    <g id="shopping-cart">
                        <path d="M7,18c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S8.1,18,7,18z M1,2v2h2l3.6,7.6L5.2,14C5.1,14.3,5,14.7,5,15c0,1.1,0.9,2,2,2h12v-2H7.4c-0.1,0-0.2-0.1-0.2-0.2c0,0,0-0.1,0-0.1L8.1,13h7.4c0.8,0,1.4-0.4,1.7-1l3.6-6.5C21,5.3,21,5.2,21,5c0-0.6-0.4-1-1-1H5.2L4.3,2H1z M17,18c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2S18.1,18,17,18z"></path>
                    </g>
                    <g id="sort">
                        <path d="M3,18h6v-2H3V18z M3,6v2h18V6H3z M3,13h12v-2H3V13z"></path>
                    </g>
                    <g id="star">
                        <polygon points="12,17.273 18.18,21 16.545,13.971 22,9.244 14.809,8.627 12,2 9.191,8.627 2,9.244 7.455,13.971 5.82,21 "></polygon>
                    </g>
                    <g id="star-half">
                        <path d="M22,9.744l-7.191-0.617L12,2.5L9.191,9.127L2,9.744v0l0,0l5.455,4.727L5.82,21.5L12,17.772l0,0l6.18,3.727l-1.635-7.029L22,9.744z M12,15.896V6.595l1.71,4.036l4.38,0.376l-3.322,2.878l0.996,4.281L12,15.896z"></path>
                    </g>
                    <g id="star-outline">
                        <path d="M22,9.244l-7.191-0.617L12,2L9.191,8.627L2,9.244l5.455,4.727L5.82,21L12,17.272L18.18,21l-1.635-7.029L22,9.244z M12,15.396l-3.763,2.27l0.996-4.281L5.91,10.507l4.38-0.376L12,6.095l1.71,4.036l4.38,0.376l-3.322,2.878l0.996,4.281L12,15.396z"></path>
                    </g>
                    <g id="star-rate">
                        <polygon points="12,14.3 15.7,17 14.3,12.6 18,10 13.5,10 12,5.5 10.5,10 6,10 9.7,12.6 8.3,17 "></polygon>
                    </g>
                    <g id="stars">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M16.2,18L12,15.4L7.8,18l1.1-4.8L5.2,10l4.9-0.4L12,5l1.9,4.5l4.9,0.4l-3.7,3.2L16.2,18z"></path>
                    </g>
                    <g id="store">
                        <path d="M20,4H4v2h16V4z M21,14v-2l-1-5H4l-1,5v2h1v6h10v-6h4v6h2v-6H21z M12,18H6v-4h6V18z"></path>
                    </g>
                    <g id="subject">
                        <path d="M14,17H4v2h10V17z M20,9H4v2h16V9z M4,15h16v-2H4V15z M4,5v2h16V5H4z"></path>
                    </g>
                    <g id="swap-driving-apps">
                        <circle cx="6.5" cy="15.5" r="1.5"></circle>
                        <circle cx="17.5" cy="15.5" r="1.5"></circle>
                        <path d="M18.9,7c-0.2-0.6-0.8-1-1.4-1H16H6V4L3,7l2,2l1,1V8h11.7l1.3,4H3v9c0,0.6,0.4,1,1,1h1c0.6,0,1-0.4,1-1v-1h12v1c0,0.6,0.4,1,1,1h1c0.6,0,1-0.4,1-1v-8L18.9,7z M6.5,17C5.7,17,5,16.3,5,15.5S5.7,14,6.5,14C7.3,14,8,14.7,8,15.5S7.3,17,6.5,17z M17.5,17c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5c0.8,0,1.5,0.7,1.5,1.5S18.3,17,17.5,17z M16,0v2H8v2h8v2l3-3L16,0z"></path>
                    </g>
                    <g id="swap-driving-apps-wheel">
                        <path d="M14.4,6.1c-0.5-0.2-1.1,0-1.3,0.6L11.7,10c-1,0.1-1.7,1-1.7,2c0,1.1,0.9,2,2,2s2-0.9,2-2c0-0.5-0.2-0.9-0.4-1.2l1.4-3.4C15.1,6.9,14.9,6.3,14.4,6.1z M7,9c-0.6,0-1,0.4-1,1c0,0.6,0.4,1,1,1s1-0.4,1-1C8,9.4,7.6,9,7,9z M11,7c0-0.6-0.4-1-1-1S9,6.4,9,7c0,0.6,0.4,1,1,1S11,7.6,11,7z M17,9c-0.6,0-1,0.4-1,1c0,0.6,0.4,1,1,1s1-0.4,1-1C18,9.4,17.6,9,17,9z M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10s10-4.5,10-10S17.5,2,12,2z M17.3,18c-1.4-1.2-3.2-2-5.3-2s-3.9,0.8-5.3,2C5.1,16.5,4,14.4,4,12c0-4.4,3.6-8,8-8s8,3.6,8,8C20,14.4,18.9,16.5,17.3,18z"></path>
                    </g>
                    <g id="swap-horiz">
                        <path d="M7,11l-4,4l4,4v-3h7v-2H7V11z M21,9l-4-4v3h-7v2h7v3L21,9z"></path>
                    </g>
                    <g id="swap-vert">
                        <path d="M16,17v-7h-2v7h-3l4,4l4-4H16z M9,3L5,7h3v7h2V7h3L9,3z"></path>
                    </g>
                    <g id="swap-vert-circle">
                        <path d="M12,2C6.5,2,2,6.5,2,12s4.5,10,10,10c5.5,0,10-4.5,10-10S17.5,2,12,2z M6.5,9L10,5.5L13.5,9H11v4H9V9H6.5z M17.5,15L14,18.5L10.5,15H13v-4h2v4H17.5z"></path>
                    </g>
                    <g id="system-update-tv">
                        <path d="M12,15l4-4h-3V3h-2v8H8L12,15z M20,3h-5v2h5v12H4V5h5V3H4C2.9,3,2,3.9,2,5v12c0,1.1,0.9,2,2,2h4v2h8v-2h4c1.1,0,2-0.9,2-2l0-12C22,3.9,21.1,3,20,3z"></path>
                    </g>
                    <g id="tab">
                        <path d="M21,3H3C1.9,3,1,3.9,1,5v14c0,1.1,0.9,2,2,2h18c1.1,0,2-0.9,2-2V5C23,3.9,22.1,3,21,3z M21,19L3,19V5h10v4h8V19z"></path>
                    </g>
                    <g id="tab-unselected">
                        <path d="M1,9h2V7H1V9z M1,13h2v-2H1V13z M1,5h2V3C1.9,3,1,3.9,1,5z M9,21h2v-2l-2,0V21z M1,17h2v-2H1V17z M3,21v-2H1C1,20.1,1.9,21,3,21z M21,3h-8v6h10V5C23,3.9,22.1,3,21,3z M21,17h2v-2h-2V17z M9,5h2V3H9V5z M5,21h2v-2l-2,0V21z M5,5h2V3H5V5z M21,21c1.1,0,2-0.9,2-2h-2V21z M21,13h2v-2h-2V13z M13,21h2v-2l-2,0V21z M17,21h2v-2l-2,0V21z"></path>
                    </g>
                    <g id="text-format">
                        <path d="M5,17v2h14v-2H5z M9.5,12.8h5l0.9,2.2h2.1L12.8,4h-1.5L6.5,15h2.1L9.5,12.8z M12,6l1.9,5h-3.7L12,6z"></path>
                    </g>
                    <g id="theaters">
                        <path d="M18,3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3H18z M8,17H6v-2h2V17z M8,13H6v-2h2V13z M8,9H6V7h2V9z M18,17h-2v-2h2V17z M18,13h-2v-2h2V13z M18,9h-2V7h2V9z"></path>
                    </g>
                    <g id="thumb-down">
                        <path d="M15,3H6C5.2,3,4.5,3.5,4.2,4.2l-3,7.1C1.1,11.5,1,11.7,1,12v1.9l0,0c0,0,0,0.1,0,0.1c0,1.1,0.9,2,2,2h6.3l-1,4.6c0,0.1,0,0.2,0,0.3c0,0.4,0.2,0.8,0.4,1.1L9.8,23l6.6-6.6c0.4-0.4,0.6-0.9,0.6-1.4V5C17,3.9,16.1,3,15,3z M19,3v12h4V3H19z"></path>
                    </g>
                    <g id="thumb-up">
                        <path d="M1,21h4V9H1V21z M23,10c0-1.1-0.9-2-2-2h-6.3l1-4.6c0-0.1,0-0.2,0-0.3c0-0.4-0.2-0.8-0.4-1.1L14.2,1L7.6,7.6C7.2,7.9,7,8.4,7,9v10c0,1.1,0.9,2,2,2h9c0.8,0,1.5-0.5,1.8-1.2l3-7.1c0.1-0.2,0.1-0.5,0.1-0.7V10L23,10C23,10.1,23,10,23,10z"></path>
                    </g>
                    <g id="toc">
                        <path d="M3,9h14V7H3V9z M3,13h14v-2H3V13z M3,17h14v-2H3V17z M19,17h2v-2h-2V17z M19,7v2h2V7H19z M19,13h2v-2h-2V13z"></path>
                    </g>
                    <g id="today">
                        <path d="M19,3h-1V1h-2v2H8V1H6v2H5C3.9,3,3,3.9,3,5l0,14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,19H5V8h14V19z"></path>
                        <rect x="7" y="10" width="5" height="5"></rect>
                    </g>
                    <g id="translate">
                        <path d="M12.9,15.1l-2.5-2.5l0,0c1.7-1.9,3-4.2,3.7-6.5H17V4h-7V2H8v2H1v2l11.2,0c-0.7,1.9-1.7,3.8-3.2,5.4c-0.9-1-1.7-2.2-2.3-3.4h-2c0.7,1.6,1.7,3.2,3,4.6l-5.1,5L4,19l5-5l3.1,3.1L12.9,15.1z M18.5,10h-2L12,22h2l1.1-3h4.8l1.1,3h2L18.5,10z M15.9,17l1.6-4.3l1.6,4.3H15.9z"></path>
                    </g>
                    <g id="trending-down">
                        <polygon points="16,18 18.3,15.7 13.4,10.8 9.4,14.8 2,7.4 3.4,6 9.4,12 13.4,8 19.7,14.3 22,12 22,18 "></polygon>
                    </g>
                    <g id="trending-neutral">
                        <polygon points="22,12 18,8 18,11 3,11 3,13 18,13 18,16 "></polygon>
                    </g>
                    <g id="trending-up">
                        <polygon points="16,6 18.3,8.3 13.4,13.2 9.4,9.2 2,16.6 3.4,18 9.4,12 13.4,16 19.7,9.7 22,12 22,6 "></polygon>
                    </g>
                    <g id="turned-in">
                        <path d="M17,3H7C5.9,3,5,3.9,5,5l0,16l7-3l7,3V5C19,3.9,18.1,3,17,3z"></path>
                    </g>
                    <g id="turned-in-not">
                        <path d="M17,3H7C5.9,3,5,3.9,5,5l0,16l7-3l7,3V5C19,3.9,18.1,3,17,3z M17,18l-5-2.2L7,18V5h10V18z"></path>
                    </g>
                    <g id="undo">
                        <path d="M12,5V1.5l-5,5l5,5V7c3.3,0,6,2.7,6,6s-2.7,6-6,6c-3.3,0-6-2.7-6-6H4c0,4.4,3.6,8,8,8c4.4,0,8-3.6,8-8S16.4,5,12,5z"></path>
                    </g>
                    <g id="unfold-less">
                        <path d="M7.4,18.6L8.8,20l3.2-3.2l3.2,3.2l1.4-1.4L12,14L7.4,18.6z M16.6,5.4L15.2,4L12,7.2L8.8,4L7.4,5.4L12,10L16.6,5.4z"></path>
                    </g>
                    <g id="unfold-more">
                        <path d="M12,5.8L15.2,9l1.4-1.4L12,3L7.4,7.6L8.8,9L12,5.8z M12,18.2L8.8,15l-1.4,1.4L12,21l4.6-4.6L15.2,15L12,18.2z"></path>
                    </g>
                    <g id="view-array">
                        <path d="M4,18h3V5H4V18z M18,5v13h3V5H18z M8,18h9V5H8V18z"></path>
                    </g>
                    <g id="view-column">
                        <path d="M10,18h5V5h-5V18z M4,18h5V5H4V18z M16,5v13h5V5H16z"></path>
                    </g>
                    <g id="view-headline">
                        <path d="M4,15h17v-2H4V15z M4,19h17v-2H4V19z M4,11h17V9H4V11z M4,5v2h17V5H4z"></path>
                    </g>
                    <g id="view-list">
                        <path d="M4,14h4v-4H4V14z M4,19h4v-4H4V19z M4,9h4V5H4V9z M9,14h12v-4H9V14z M9,19h12v-4H9V19z M9,5v4h12V5H9z"></path>
                    </g>
                    <g id="view-module">
                        <path d="M4,11h5V5H4V11z M4,18h5v-6H4V18z M10,18h5v-6h-5V18z M16,18h5v-6h-5V18z M10,11h5V5h-5V11z M16,5v6h5V5H16z"></path>
                    </g>
                    <g id="view-quilt">
                        <path d="M10,18h5v-6h-5V18z M4,18h5V5H4V18z M16,18h5v-6h-5V18z M10,5v6h11V5H10z"></path>
                    </g>
                    <g id="view-stream">
                        <path d="M4,18h17v-6H4V18z M4,5v6h17V5H4z"></path>
                    </g>
                    <g id="visibility">
                        <path d="M12,4.5C7,4.5,2.7,7.6,1,12c1.7,4.4,6,7.5,11,7.5c5,0,9.3-3.1,11-7.5C21.3,7.6,17,4.5,12,4.5z M12,17c-2.8,0-5-2.2-5-5s2.2-5,5-5c2.8,0,5,2.2,5,5S14.8,17,12,17z M12,9c-1.7,0-3,1.3-3,3s1.3,3,3,3c1.7,0,3-1.3,3-3S13.7,9,12,9z"></path>
                    </g>
                    <g id="visibility-off">
                        <path d="M12,7c2.8,0,5,2.2,5,5c0,0.6-0.1,1.3-0.4,1.8l2.9,2.9c1.5-1.3,2.7-2.9,3.4-4.7c-1.7-4.4-6-7.5-11-7.5c-1.4,0-2.7,0.3-4,0.7l2.2,2.2C10.7,7.1,11.4,7,12,7z M2,4.3l2.3,2.3L4.7,7c-1.7,1.3-3,3-3.7,5c1.7,4.4,6,7.5,11,7.5c1.5,0,3-0.3,4.4-0.8l0.4,0.4l2.9,2.9l1.3-1.3L3.3,3L2,4.3z M7.5,9.8l1.5,1.5C9,11.6,9,11.8,9,12c0,1.7,1.3,3,3,3c0.2,0,0.4,0,0.7-0.1l1.5,1.5C13.5,16.8,12.8,17,12,17c-2.8,0-5-2.2-5-5C7,11.2,7.2,10.5,7.5,9.8z M11.8,9l3.1,3.1c0-0.1,0-0.1,0-0.2c0-1.7-1.3-3-3-3C11.9,9,11.9,9,11.8,9z"></path>
                    </g>
                    <g id="wallet-giftcard">
                        <path d="M20,6h-2.2C17.9,5.7,18,5.4,18,5c0-1.7-1.3-3-3-3c-1,0-2,0.5-2.5,1.3l0,0L12,4l-0.5-0.7l0,0C11,2.5,10,2,9,2C7.3,2,6,3.3,6,5c0,0.4,0.1,0.7,0.2,1H4C2.9,6,2,6.9,2,8l0,11c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M15,4c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S14.4,4,15,4z M9,4c0.6,0,1,0.4,1,1S9.6,6,9,6S8,5.6,8,5S8.4,4,9,4z M20,19H4v-2h16V19z M20,14H4V8h5.1L7,10.8L8.6,12L11,8.8l1-1.4l1,1.4l2.4,3.2l1.6-1.2L14.9,8H20V14z"></path>
                    </g>
                    <g id="wallet-membership">
                        <path d="M20,2H4C2.9,2,2,2.9,2,4v11c0,1.1,0.9,2,2,2h4v5l4-2l4,2v-5h4c1.1,0,2-0.9,2-2V4C22,2.9,21.1,2,20,2z M20,15H4v-2h16V15z M20,10H4V4h16V10z"></path>
                    </g>
                    <g id="wallet-travel">
                        <path d="M20,6h-3V4l-2-2H9L7,4v2H4C2.9,6,2,6.9,2,8v11c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M9,4h6v2H9V4z M20,19H4v-2h16V19z M20,14H4V8h3v4h2V8h6v4h2V8h3V14z"></path>
                    </g>
                    <g id="warning">
                        <path d="M1,21h22L12,2L1,21z M13,18h-2v-2h2V18z M13,14h-2v-4h2V14z"></path>
                    </g>
                    <g id="work">
                        <path d="M20,6h-4V4l-2-2h-4L8,4v2H4C2.9,6,2,6.9,2,8l0,11c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M14,6h-4V4h4V6z"></path>
                    </g>
                </defs>
            </svg>
        </core-iconset-svg>

        <polymer-element name="core-selection" attributes="multi" hidden="" assetpath="bower_components/core-selection/">
            <script>
                Polymer('core-selection', {
                    /**
                     * If true, multiple selections are allowed.
                     *
                     * @attribute multi
                     * @type boolean
                     * @default false
                     */
                    multi: false,
                    ready: function () {
                        this.clear();
                    },
                    clear: function () {
                        this.selection = [];
                    },
                    /**
                     * Retrieves the selected item(s).
                     * @method getSelection
                     * @returns Returns the selected item(s). If the multi property is true,
                     * getSelection will return an array, otherwise it will return
                     * the selected item or undefined if there is no selection.
                     */
                    getSelection: function () {
                        return this.multi ? this.selection : this.selection[0];
                    },
                    /**
                     * Indicates if a given item is selected.
                     * @method isSelected
                     * @param {any} item The item whose selection state should be checked.
                     * @returns Returns true if `item` is selected.
                     */
                    isSelected: function (item) {
                        return this.selection.indexOf(item) >= 0;
                    },
                    setItemSelected: function (item, isSelected) {
                        if (item !== undefined && item !== null) {
                            if (isSelected) {
                                this.selection.push(item);
                            } else {
                                var i = this.selection.indexOf(item);
                                if (i >= 0) {
                                    this.selection.splice(i, 1);
                                }
                            }
                            this.fire("core-select", {
                                isSelected: isSelected,
                                item: item
                            });
                        }
                    },
                    /**
                     * Set the selection state for a given `item`. If the multi property
                     * is true, then the selected state of `item` will be toggled; otherwise
                     * the `item` will be selected.
                     * @method select
                     * @param {any} item: The item to select.
                     */
                    select: function (item) {
                        if (this.multi) {
                            this.toggle(item);
                        } else if (this.getSelection() !== item) {
                            this.setItemSelected(this.getSelection(), false);
                            this.setItemSelected(item, true);
                        }
                    },
                    /**
                     * Toggles the selection state for `item`.
                     * @method toggle
                     * @param {any} item: The item to toggle.
                     */
                    toggle: function (item) {
                        this.setItemSelected(item, !this.isSelected(item));
                    }
                });
            </script>
        </polymer-element>
        <polymer-element name="core-selector" attributes="selected multi valueattr selectedClass selectedProperty selectedAttribute selectedItem selectedModel selectedIndex notap excludedLocalNames target itemsSelector activateEvent" assetpath="bower_components/core-selector/">

            <template>
                <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectionSelect}}"></core-selection>
                <content id="items" select="*"></content>
            </template>

            <script>
                Polymer('core-selector', {

                    /**
                     * Gets or sets the selected element.  Default to use the index
                     * of the item element.
                     *
                     * If you want a specific attribute value of the element to be
                     * used instead of index, set "valueattr" to that attribute name.
                     *
                     * Example:
                     *
                     *     <core-selector valueattr="label" selected="foo">
                     *       <div label="foo"></div>
                     *       <div label="bar"></div>
                     *       <div label="zot"></div>
                     *     </core-selector>
                     *
                     * In multi-selection this should be an array of values.
                     *
                     * Example:
                     *
                     *     <core-selector id="selector" valueattr="label" multi>
                     *       <div label="foo"></div>
                     *       <div label="bar"></div>
                     *       <div label="zot"></div>
                     *     </core-selector>
                     *
                     *     this.$.selector.selected = ['foo', 'zot'];
                     *
                     * @attribute selected
                     * @type Object
                     * @default null
                     */
                    selected: null,

                    /**
                     * If true, multiple selections are allowed.
                     *
                     * @attribute multi
                     * @type boolean
                     * @default false
                     */
                    multi: false,

                    /**
                     * Specifies the attribute to be used for "selected" attribute.
                     *
                     * @attribute valueattr
                     * @type string
                     * @default 'name'
                     */
                    valueattr: 'name',

                    /**
                     * Specifies the CSS class to be used to add to the selected element.
                     *
                     * @attribute selectedClass
                     * @type string
                     * @default 'core-selected'
                     */
                    selectedClass: 'core-selected',

                    /**
                     * Specifies the property to be used to set on the selected element
                     * to indicate its active state.
                     *
                     * @attribute selectedProperty
                     * @type string
                     * @default ''
                     */
                    selectedProperty: '',

                    /**
                     * Specifies the attribute to set on the selected element to indicate
                     * its active state.
                     *
                     * @attribute selectedAttribute
                     * @type string
                     * @default 'active'
                     */
                    selectedAttribute: 'active',

                    /**
                     * Returns the currently selected element. In multi-selection this returns
                     * an array of selected elements.
                     * Note that you should not use this to set the selection. Instead use
                     * `selected`.
                     *
                     * @attribute selectedItem
                     * @type Object
                     * @default null
                     */
                    selectedItem: null,

                    /**
                     * In single selection, this returns the model associated with the
                     * selected element.
                     * Note that you should not use this to set the selection. Instead use
                     * `selected`.
                     *
                     * @attribute selectedModel
                     * @type Object
                     * @default null
                     */
                    selectedModel: null,

                    /**
                     * In single selection, this returns the selected index.
                     * Note that you should not use this to set the selection. Instead use
                     * `selected`.
                     *
                     * @attribute selectedIndex
                     * @type number
                     * @default -1
                     */
                    selectedIndex: -1,

                    /**
                     * Nodes with local name that are in the list will not be included
                     * in the selection items.  In the following example, `items` returns four
                     * `core-item`'s and doesn't include `h3` and `hr`.
                     *
                     *     <core-selector excludedLocalNames="h3 hr">
                     *       <h3>Header</h3>
                     *       <core-item>Item1</core-item>
                     *       <core-item>Item2</core-item>
                     *       <hr>
                     *       <core-item>Item3</core-item>
                     *       <core-item>Item4</core-item>
                     *     </core-selector>
                     *
                     * @attribute excludedLocalNames
                     * @type string
                     * @default ''
                     */
                    excludedLocalNames: '',

                    /**
                     * The target element that contains items.  If this is not set
                     * core-selector is the container.
                     *
                     * @attribute target
                     * @type Object
                     * @default null
                     */
                    target: null,

                    /**
                     * This can be used to query nodes from the target node to be used for
                     * selection items.  Note this only works if `target` is set
                     * and is not `core-selector` itself.
                     *
                     * Example:
                     *
                     *     <core-selector target="{{$.myForm}}" itemsSelector="input[type=radio]"></core-selector>
                     *     <form id="myForm">
                     *       <label><input type="radio" name="color" value="red"> Red</label> <br>
                     *       <label><input type="radio" name="color" value="green"> Green</label> <br>
                     *       <label><input type="radio" name="color" value="blue"> Blue</label> <br>
                     *       <p>color = {{color}}</p>
                     *     </form>
                     *
                     * @attribute itemsSelector
                     * @type string
                     * @default ''
                     */
                    itemsSelector: '',

                    /**
                     * The event that would be fired from the item element to indicate
                     * it is being selected.
                     *
                     * @attribute activateEvent
                     * @type string
                     * @default 'tap'
                     */
                    activateEvent: 'tap',

                    /**
                     * Set this to true to disallow changing the selection via the
                     * `activateEvent`.
                     *
                     * @attribute notap
                     * @type boolean
                     * @default false
                     */
                    notap: false,

                    defaultExcludedLocalNames: 'template',

                    ready: function () {
                        this.activateListener = this.activateHandler.bind(this);
                        this.itemFilter = this.filterItem.bind(this);
                        this.excludedLocalNamesChanged();
                        this.observer = new MutationObserver(this.updateSelected.bind(this));
                        if (!this.target) {
                            this.target = this;
                        }
                    },

                    /**
                     * Returns an array of all items.
                     *
                     * @property items
                     */
                    get items() {
                        if (!this.target) {
                            return [];
                        }
                        var nodes = this.target !== this ? (this.itemsSelector ?
                            this.target.querySelectorAll(this.itemsSelector) :
                            this.target.children) : this.$.items.getDistributedNodes();
                        return Array.prototype.filter.call(nodes, this.itemFilter);
                    },

                    filterItem: function (node) {
                        return !this._excludedNames[node.localName];
                    },

                    excludedLocalNamesChanged: function () {
                        this._excludedNames = {};
                        var s = this.defaultExcludedLocalNames;
                        if (this.excludedLocalNames) {
                            s += ' ' + this.excludedLocalNames;
                        }
                        s.split(/\s+/g).forEach(function (n) {
                            this._excludedNames[n] = 1;
                        }, this);
                    },

                    targetChanged: function (old) {
                        if (old) {
                            this.removeListener(old);
                            this.observer.disconnect();
                            this.clearSelection();
                        }
                        if (this.target) {
                            this.addListener(this.target);
                            this.observer.observe(this.target, {
                                childList: true
                            });
                            this.updateSelected();
                        }
                    },

                    addListener: function (node) {
                        Polymer.addEventListener(node, this.activateEvent, this.activateListener);
                    },

                    removeListener: function (node) {
                        Polymer.removeEventListener(node, this.activateEvent, this.activateListener);
                    },

                    /**
                     * Returns the selected item(s). If the `multi` property is true,
                     * this will return an array, otherwise it will return
                     * the selected item or undefined if there is no selection.
                     */
                    get selection() {
                        return this.$.selection.getSelection();
                    },

                    selectedChanged: function () {
                        this.updateSelected();
                    },

                    updateSelected: function () {
                        this.validateSelected();
                        if (this.multi) {
                            this.clearSelection();
                            this.selected && this.selected.forEach(function (s) {
                                this.valueToSelection(s);
                            }, this);
                        } else {
                            this.valueToSelection(this.selected);
                        }
                    },

                    validateSelected: function () {
                        // convert to an array for multi-selection
                        if (this.multi && !Array.isArray(this.selected) &&
                            this.selected !== null && this.selected !== undefined) {
                            this.selected = [this.selected];
                        }
                    },

                    clearSelection: function () {
                        if (this.multi) {
                            this.selection.slice().forEach(function (s) {
                                this.$.selection.setItemSelected(s, false);
                            }, this);
                        } else {
                            this.$.selection.setItemSelected(this.selection, false);
                        }
                        this.selectedItem = null;
                        this.$.selection.clear();
                    },

                    valueToSelection: function (value) {
                        var item = (value === null || value === undefined) ?
                            null : this.items[this.valueToIndex(value)];
                        this.$.selection.select(item);
                    },

                    updateSelectedItem: function () {
                        this.selectedItem = this.selection;
                    },

                    selectedItemChanged: function () {
                        if (this.selectedItem) {
                            var t = this.selectedItem.templateInstance;
                            this.selectedModel = t ? t.model : undefined;
                        } else {
                            this.selectedModel = null;
                        }
                        this.selectedIndex = this.selectedItem ?
                            parseInt(this.valueToIndex(this.selected)) : -1;
                    },

                    valueToIndex: function (value) {
                        // find an item with value == value and return it's index
                        for (var i = 0, items = this.items, c;
                            (c = items[i]); i++) {
                            if (this.valueForNode(c) == value) {
                                return i;
                            }
                        }
                        // if no item found, the value itself is probably the index
                        return value;
                    },

                    valueForNode: function (node) {
                        return node[this.valueattr] || node.getAttribute(this.valueattr);
                    },

                    // events fired from <core-selection> object
                    selectionSelect: function (e, detail) {
                        this.updateSelectedItem();
                        if (detail.item) {
                            this.applySelection(detail.item, detail.isSelected);
                        }
                    },

                    applySelection: function (item, isSelected) {
                        if (this.selectedClass) {
                            item.classList.toggle(this.selectedClass, isSelected);
                        }
                        if (this.selectedProperty) {
                            item[this.selectedProperty] = isSelected;
                        }
                        if (this.selectedAttribute && item.setAttribute) {
                            if (isSelected) {
                                item.setAttribute(this.selectedAttribute, '');
                            } else {
                                item.removeAttribute(this.selectedAttribute);
                            }
                        }
                    },

                    // event fired from host
                    activateHandler: function (e) {
                        if (!this.notap) {
                            var i = this.findDistributedTarget(e.target, this.items);
                            if (i >= 0) {
                                var item = this.items[i];
                                var s = this.valueForNode(item) || i;
                                if (this.multi) {
                                    if (this.selected) {
                                        this.addRemoveSelected(s);
                                    } else {
                                        this.selected = [s];
                                    }
                                } else {
                                    this.selected = s;
                                }
                                this.asyncFire('core-activate', {
                                    item: item
                                });
                            }
                        }
                    },

                    addRemoveSelected: function (value) {
                        var i = this.selected.indexOf(value);
                        if (i >= 0) {
                            this.selected.splice(i, 1);
                        } else {
                            this.selected.push(value);
                        }
                        this.valueToSelection(value);
                    },

                    findDistributedTarget: function (target, nodes) {
                        // find first ancestor of target (including itself) that
                        // is in nodes, if any
                        while (target && target != this) {
                            var i = Array.prototype.indexOf.call(nodes, target);
                            if (i >= 0) {
                                return i;
                            }
                            target = target.parentNode;
                        }
                    },

                    selectIndex: function (index) {
                        var item = this.items[index];
                        if (item) {
                            this.selected = this.valueForNode(item) || index;
                            return item;
                        }
                    },

                    /**
                     * Selects the previous item.  This should be used in single selection only.
                     *
                     * @method selectPrevious
                     * @param {boolean} wrap if true and it is already at the first item, wrap to the end
                     * @returns the previous item or undefined if there is none
                     */
                    selectPrevious: function (wrap) {
                        var i = wrap && !this.selectedIndex ? this.items.length - 1 : this.selectedIndex - 1;
                        return this.selectIndex(i);
                    },

                    /**
                     * Selects the next item.  This should be used in single selection only.
                     *
                     * @method selectNext
                     * @param {boolean} wrap if true and it is already at the last item, wrap to the front
                     * @returns the next item or undefined if there is none
                     */
                    selectNext: function (wrap) {
                        var i = wrap && this.selectedIndex >= this.items.length - 1 ? 0 : this.selectedIndex + 1;
                        return this.selectIndex(i);
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="core-menu" extends="core-selector" assetpath="bower_components/core-menu/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        margin: 12px;
                    }
                    polyfill-next-selector {
                        content: ':host > core-item';
                    }
                    ::content > core-item {
                        cursor: default;
                    }
                </style>

                <shadow></shadow>

            </template>
            <script>
                Polymer('core-menu');
            </script>
        </polymer-element>
        <polymer-element name="paper-dropdown-menu" assetpath="bower_components/paper-dropdown-menu/">
            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        position: relative;
                        display: inline-block;
                        background-color: #fff;
                        -moz-user-select: none;
                        -ms-user-select: none;
                        -webkit-user-select: none;
                        user-select: none;
                        cursor: pointer;
                        padding: 0.75em 0;
                    }
                    #control {
                        box-sizing: border-box;
                        max-height: 2em;
                        color: #757575;
                        border-bottom: 1px solid #757575;
                    }
                    #control[selected] {
                        color: #000;
                    }
                    #control > div {
                        padding: 0.5em 0 0.25em;
                        overflow: hidden;
                        /* FIXME not working for some reason */
                        white-space: nowrap;
                        text-overflow: ellipsis;
                    }
                    core-icon {
                        margin: 0.3em 0 0.2em 0.25em;
                    }
                    #dropdown {
                        margin: 12px;
                    }
                    #menu {
                        padding: 8px 0;
                        margin: 0;
                    }
                    .menu-container {
                        overflow: auto;
                        max-height: 100%;
                        max-width: 100%;
                    }
                </style>

                <div id="control" layout="" horizontal="" selected?="{{selectedItem}}" on-tap="{{toggle}}">
                    <div flex="">
                        {{selectedItem ? (selectedItem.label || selected) : label}}
                    </div>
                    <core-icon id="arrow" icon="{{opened ? 'arrow-drop-up' : 'arrow-drop-down'}}"></core-icon>
                </div>

                <core-dropdown id="dropdown" relatedtarget="{{$.control}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}">

                    <paper-shadow z="1" target="{{$.dropdown}}" hasposition=""></paper-shadow>

                    <div class="menu-container">
                        <core-menu id="menu" selected="{{selected}}" selecteditem="{{selectedItem}}" selectedclass="{{selectedClass}}" valueattr="{{valueattr}}" selectedproperty="{{selectedProperty}}" selectedattribute="{{selectedAttribute}}" on-core-activate="{{activateAction}}">
                            <content></content>
                        </core-menu>
                    </div>

                </core-dropdown>

            </template>
            <script>
                Polymer('paper-dropdown-menu', {

                    publish: {

                        /**
                         * True if the menu is open.
                         *
                         * @attribute opened
                         * @type boolean
                         * @default false
                         */
                        opened: false,

                        /**
                         * A label for the control. The label is displayed if no item is selected.
                         *
                         * @attribute label
                         * @type string
                         * @default 'Select an item'
                         */
                        label: 'Select an item',

                        /**
                         * The currently selected element. By default this is the index of the item element.
                         * If you want a specific attribute value of the element to be used instead of the
                         * index, set `valueattr` to that attribute name.
                         *
                         * @attribute selected
                         * @type Object
                         * @default null
                         */
                        selected: null,

                        /**
                         * Specifies the attribute to be used for "selected" attribute.
                         *
                         * @attribute valueattr
                         * @type string
                         * @default 'name'
                         */
                        valueattr: 'name',

                        /**
                         * Specifies the CSS class to be used to add to the selected element.
                         *
                         * @attribute selectedClass
                         * @type string
                         * @default 'core-selected'
                         */
                        selectedClass: 'core-selected',

                        /**
                         * Specifies the property to be used to set on the selected element
                         * to indicate its active state.
                         *
                         * @attribute selectedProperty
                         * @type string
                         * @default ''
                         */
                        selectedProperty: '',

                        /**
                         * Specifies the attribute to set on the selected element to indicate
                         * its active state.
                         *
                         * @attribute selectedAttribute
                         * @type string
                         * @default 'active'
                         */
                        selectedAttribute: 'selected',

                        /**
                         * The currently selected element.
                         *
                         * @attribute selectedItem
                         * @type Object
                         * @default null
                         */
                        selectedItem: null,

                        /**
                         * Horizontally align the overlay with the control.
                         * @attribute halign
                         * @type "left"|"right"
                         * @default "left"
                         */
                        halign: 'left',

                        /**
                         * Vertically align the dropdown menu with the control.
                         * @attribute valign
                         * @type "top"|"bottom"
                         * @default "top"
                         */
                        valign: 'top'

                    },

                    toggle: function () {
                        this.opened = !this.opened;
                    },

                    activateAction: function () {
                        this.opened = false;
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-fab" extends="paper-button-base" attributes="src icon mini" role="button" assetpath="bower_components/paper-fab/">

            <template>

                <style>
                    :host {
                        display: inline-block;
                        position: relative;
                        outline: none;
                        -webkit-user-select: none;
                        user-select: none;
                        cursor: pointer;
                        z-index: 0;
                        box-sizing: border-box;
                        width: 56px;
                        height: 56px;
                        background: #d23f31;
                        color: #fff;
                        border-radius: 50%;
                        padding: 16px;
                    }
                    :host([mini]) {
                        width: 40px;
                        height: 40px;
                        padding: 8px;
                    }
                    :host([disabled]) {
                        color: #c9c9c9;
                        pointer-events: none;
                        cursor: auto;
                    }
                    #ripple {
                        pointer-events: none;
                        z-index: -1;
                    }
                </style>

                <template if="{{raised}}">
                    <paper-shadow id="shadow" z="{{z}}" animated=""></paper-shadow>
                </template>

                <!-- to position to ripple behind the icon -->
                <core-icon relative="" id="icon" src="{{src}}" icon="{{icon}}"></core-icon>

            </template>

            <script>
                Polymer('paper-fab', {

                    publish: {

                        /**
                         * The URL of an image for the icon. If the src property is specified,
                         * the icon property should not be.
                         *
                         * @attribute src
                         * @type string
                         * @default ''
                         */
                        src: '',

                        /**
                         * Specifies the icon name or index in the set of icons available in
                         * the icon's icon set. If the icon property is specified,
                         * the src property should not be.
                         *
                         * @attribute icon
                         * @type string
                         * @default ''
                         */
                        icon: '',

                        /**
                         * Set this to true to style this is a "mini" FAB.
                         *
                         * @attribute mini
                         * @type boolean
                         * @default false
                         */
                        mini: false,

                        raised: true,
                        recenteringTouch: false,
                        fill: true

                    },

                    iconChanged: function (oldIcon) {
                        this.setAttribute('aria-label', this.icon);
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="paper-icon-button" extends="paper-button-base" attributes="src icon" role="button" assetpath="bower_components/paper-icon-button/">

            <template>

                <style>
                    :host {
                        display: inline-block;
                        position: relative;
                        padding: 8px;
                        outline: none;
                        -webkit-user-select: none;
                        user-select: none;
                        cursor: pointer;
                        z-index: 0;
                    }
                    :host([disabled]) {
                        color: #c9c9c9;
                        pointer-events: none;
                        cursor: auto;
                    }
                    #ripple {
                        pointer-events: none;
                        z-index: -1;
                    }
                </style>

                <!-- to position to ripple behind the icon -->
                <core-icon relative="" id="icon" src="{{src}}" icon="{{icon}}"></core-icon>

            </template>

            <script>
                Polymer('paper-icon-button', {

                    publish: {

                        /**
                         * The URL of an image for the icon. If the src property is specified,
                         * the icon property should not be.
                         *
                         * @attribute src
                         * @type string
                         * @default ''
                         */
                        src: '',

                        /**
                         * Specifies the icon name or index in the set of icons available in
                         * the icon's icon set. If the icon property is specified,
                         * the src property should not be.
                         *
                         * @attribute icon
                         * @type string
                         * @default ''
                         */
                        icon: '',

                        recenteringTouch: true,
                        fill: false

                    },

                    iconChanged: function (oldIcon) {
                        this.setAttribute('aria-label', this.icon);
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-input" on-focus="{{focusAction}}" assetpath="bower_components/core-input/">

            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: inline-block;
                        text-align: inherit;
                        position: relative;
                        width: 20em;
                    }
                    :host:hover {
                        cursor: text;
                    }
                    input,
                    textarea {
                        font: inherit;
                        color: inherit;
                        width: 100%;
                        margin: 0;
                        padding: 0;
                        background-color: transparent;
                        border: none;
                        outline: none;
                        width: 100%;
                    }
                    textarea {
                        resize: none;
                    }
                    textarea[rows=fit] {
                        height: 100%;
                    }
                </style>

                <template if="{{multiline}}">
                    <textarea id="input" value="{{inputValue}}" rows="{{rows}}" disabled?="{{disabled}}" placeholder="{{placeholder}}" autofocus?="{{autofocus}}" required?="{{required}}" readonly?="{{readonly}}" maxlength="{{maxlength}}" aria-label="{{label || placeholder}}" aria-invalid="{{invalid}}" on-change="{{inputChangeAction}}" on-focus="{{inputFocusAction}}" on-blur="{{inputBlurAction}}"></textarea>
                </template>

                <template if="{{!multiline}}">
                    <input id="input" value="{{inputValue}}" disabled?="{{disabled}}" type="{{type}}" placeholder="{{placeholder}}" autofocus?="{{autofocus}}" required?="{{required}}" readonly?="{{readonly}}" pattern="{{pattern}}" min="{{min}}" max="{{max}}" step="{{step}}" maxlength="{{maxlength}}" aria-label="{{label || placeholder}}" aria-invalid="{{invalid}}" on-keypress="{{keypressAction}}" on-change="{{inputChangeAction}}" on-focus="{{inputFocusAction}}" on-blur="{{inputBlurAction}}">
                </template>

            </template>

            <script>
                Polymer('core-input', {
                    publish: {
                        /**
                         * Placeholder text that hints to the user what can be entered in
                         * the input.
                         *
                         * @attribute placeholder
                         * @type string
                         * @default ''
                         */
                        placeholder: '',

                        /**
                         * If true, this input cannot be focused and the user cannot change
                         * its value.
                         *
                         * @attribute disabled
                         * @type boolean
                         * @default false
                         */
                        disabled: false,

                        /**
                         * If true, the user cannot modify the value of the input.
                         *
                         * @attribute readonly
                         * @type boolean
                         * @default false
                         */
                        readonly: false,

                        /**
                         * If true, this input will automatically gain focus on page load.
                         *
                         * @attribute autofocus
                         * @type boolean
                         * @default false
                         */
                        autofocus: false,

                        /**
                         * If true, this input accepts multi-line input like a `<textarea>`
                         *
                         * @attribute multiline
                         * @type boolean
                         * @default false
                         */
                        multiline: false,

                        /**
                         * (multiline only) The height of this text input in rows. The input
                         * will scroll internally if more input is entered beyond the size
                         * of the component. This property is meaningless if multiline is
                         * false. You can also set this property to "fit" and size the
                         * component with CSS to make the input fit the CSS size.
                         *
                         * @attribute rows
                         * @type number|'fit'
                         * @default 'fit'
                         */
                        rows: 'fit',

                        /**
                         * The current value of this input. Changing inputValue programmatically
                         * will cause value to be out of sync. Instead, change value directly
                         * or call commit() after changing inputValue.
                         *
                         * @attribute inputValue
                         * @type string
                         * @default ''
                         */
                        inputValue: '',

                        /**
                         * The value of the input committed by the user, either by changing the
                         * inputValue and blurring the input, or by hitting the `enter` key.
                         *
                         * @attribute value
                         * @type string
                         * @default ''
                         */
                        value: '',

                        /**
                         * Set the input type. Not supported for `multiline`.
                         *
                         * @attribute type
                         * @type string
                         * @default text
                         */
                        type: 'text',

                        /**
                         * If true, the input is invalid if its value is null.
                         *
                         * @attribute required
                         * @type boolean
                         * @default false
                         */
                        required: false,

                        /**
                         * A regular expression to validate the input value against. See
                         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation#Validation-related_attributes
                         * for more info. Not supported if `multiline` is true.
                         *
                         * @attribute pattern
                         * @type string
                         * @default '.*'
                         */
                        // FIXME(yvonne): The default is set to .* because we can't bind to pattern such
                        // that the attribute is unset if pattern is null.
                        pattern: '.*',

                        /**
                         * If set, the input is invalid if the value is less than this property. See
                         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation#Validation-related_attributes
                         * for more info. Not supported if `multiline` is true.
                         *
                         * @attribute min
                         */
                        min: null,

                        /**
                         * If set, the input is invalid if the value is greater than this property. See
                         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation#Validation-related_attributes
                         * for more info. Not supported if `multiline` is true.
                         *
                         * @attribute max
                         */
                        max: null,

                        /**
                         * If set, the input is invalid if the value is not `min` plus an integral multiple
                         * of this property. See
                         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation#Validation-related_attributes
                         * for more info. Not supported if `multiline` is true.
                         *
                         * @attribute step
                         */
                        step: null,

                        /**
                         * The maximum length of the input value.
                         *
                         * @attribute maxlength
                         * @type number
                         */
                        maxlength: null,

                        /**
                         * If this property is true, the text input's inputValue failed validation.
                         *
                         * @attribute invalid
                         * @type boolean
                         * @default false
                         */
                        invalid: false,

                        /**
                         * If this property is true, validate the input as they are entered.
                         *
                         * @attribute validateImmediately
                         * @type boolean
                         * @default true
                         */
                        validateImmediately: true
                    },

                    ready: function () {
                        this.handleTabindex(this.getAttribute('tabindex'));
                    },

                    disabledChanged: function () {
                        if (this.disabled) {
                            this.setAttribute('aria-disabled', true);
                        } else {
                            this.removeAttribute('aria-disabled');
                        }
                    },

                    invalidChanged: function () {
                        this.classList.toggle('invalid', this.invalid);
                        this.fire('input-' + (this.invalid ? 'invalid' : 'valid'), {
                            value: this.inputValue
                        });
                    },

                    inputValueChanged: function () {
                        if (this.validateImmediately) {
                            this.updateValidity_();
                        }
                    },

                    valueChanged: function () {
                        this.inputValue = this.value;
                    },

                    requiredChanged: function () {
                        if (this.validateImmediately) {
                            this.updateValidity_();
                        }
                    },

                    attributeChanged: function (attr, oldVal, curVal) {
                        if (attr === 'tabindex') {
                            this.handleTabindex(curVal);
                        }
                    },

                    handleTabindex: function (tabindex) {
                        if (tabindex > 0) {
                            this.$.input.setAttribute('tabindex', -1);
                        } else {
                            this.$.input.removeAttribute('tabindex');
                        }
                    },

                    /**
                     * Commits the inputValue to value.
                     *
                     * @method commit
                     */
                    commit: function () {
                        this.value = this.inputValue;
                    },

                    updateValidity_: function () {
                        if (this.$.input.willValidate) {
                            this.invalid = !this.$.input.validity.valid;
                        }
                    },

                    keypressAction: function (e) {
                        // disallow non-numeric input if type = number
                        if (this.type !== 'number') {
                            return;
                        }
                        var c = String.fromCharCode(e.charCode);
                        if (e.charCode !== 0 && !c.match(/[\d-\.e]/)) {
                            e.preventDefault();
                        }
                    },

                    inputChangeAction: function () {
                        this.commit();
                        if (!window.ShadowDOMPolyfill) {
                            // re-fire event that does not bubble across shadow roots
                            this.fire('change', null, this);
                        }
                    },

                    focusAction: function (e) {
                        if (this.getAttribute('tabindex') > 0) {
                            // Forward focus to the inner input if tabindex is set on the element
                            // This will not cause an infinite loop because focus will not fire on the <input>
                            // again if it's already focused.
                            this.$.input.focus();
                        }
                    },

                    inputFocusAction: function (e) {
                        if (window.ShadowDOMPolyfill) {
                            // re-fire non-bubbling event if polyfill
                            this.fire('focus', null, this, false);
                        }
                    },

                    inputBlurAction: function () {
                        if (window.ShadowDOMPolyfill) {
                            // re-fire non-bubbling event
                            this.fire('blur', null, this, false);
                        }
                    },

                    /**
                     * Forwards to the internal input / textarea element.
                     *
                     * @method blur
                     */
                    blur: function () {
                        this.$.input.blur();
                    },

                    /**
                     * Forwards to the internal input / textarea element.
                     *
                     * @method click
                     */
                    click: function () {
                        this.$.input.click();
                    },

                    /**
                     * Forwards to the internal input / textarea element.
                     *
                     * @method focus
                     */
                    focus: function () {
                        this.$.input.focus();
                    },

                    /**
                     * Forwards to the internal input / textarea element.
                     *
                     * @method select
                     */
                    select: function () {
                        this.$.input.select();
                    },

                    /**
                     * Forwards to the internal input / textarea element.
                     *
                     * @method setSelectionRange
                     * @param {number} selectionStart
                     * @param {number} selectionEnd
                     * @param {String} selectionDirection (optional)
                     */
                    setSelectionRange: function (selectionStart, selectionEnd, selectionDirection) {
                        this.$.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
                    },

                    /**
                     * Forwards to the internal input element, not implemented for multiline.
                     *
                     * @method setRangeText
                     * @param {String} replacement
                     * @param {number} start (optional)
                     * @param {number} end (optional)
                     * @param {String} selectMode (optional)
                     */
                    setRangeText: function (replacement, start, end, selectMode) {
                        if (!this.multiline) {
                            this.$.input.setRangeText(replacement, start, end, selectMode);
                        }
                    },

                    /**
                     * Forwards to the internal input, not implemented for multiline.
                     *
                     * @method stepDown
                     * @param {number} n (optional)
                     */
                    stepDown: function (n) {
                        if (!this.multiline) {
                            this.$.input.stepDown(n);
                        }
                    },

                    /**
                     * Forwards to the internal input, not implemented for multiline.
                     *
                     * @method stepUp
                     * @param {number} n (optional)
                     */
                    stepUp: function (n) {
                        if (!this.multiline) {
                            this.$.input.stepUp(n);
                        }
                    },

                    get willValidate() {
                        return this.$.input.willValidate;
                    },

                    get validity() {
                        return this.$.input.validity;
                    },

                    get validationMessage() {
                        return this.$.input.validationMessage;
                    },

                    /**
                     * Forwards to the internal input / textarea element and updates state.
                     *
                     * @method checkValidity
                     * @return {boolean}
                     */
                    checkValidity: function () {
                        var r = this.$.input.checkValidity();
                        this.updateValidity_();
                        return r;
                    },

                    /**
                     * Forwards to the internal input / textarea element and updates state.
                     *
                     * @method setCustomValidity
                     * @param {String} message
                     */
                    setCustomValidity: function (message) {
                        this.$.input.setCustomValidity(message);
                        this.updateValidity_();
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-style" hidden="" assetpath="bower_components/core-style/">
            <script>
                (function () {

                    window.CoreStyle = window.CoreStyle || {
                        g: {},
                        list: {},
                        refMap: {}
                    };

                    Polymer('core-style', {
                        /**
                         * The `id` property should be set if the `core-style` is a producer
                         * of styles. In this case, the `core-style` should have text content
                         * that is cssText.
                         *
                         * @attribute id
                         * @type string
                         * @default ''
                         */


                        publish: {
                            /**
                             * The `ref` property should be set if the `core-style` element is a
                             * consumer of styles. Set it to the `id` of the desired `core-style`
                             * element.
                             *
                             * @attribute ref
                             * @type string
                             * @default ''
                             */
                            ref: ''
                        },

                        // static
                        g: CoreStyle.g,
                        refMap: CoreStyle.refMap,

                        /**
                         * The `list` is a map of all `core-style` producers stored by `id`. It
                         * should be considered readonly. It's useful for nesting one `core-style`
                         * inside another.
                         *
                         * @attribute list
                         * @type object (readonly)
                         * @default {map of all `core-style` producers}
                         */
                        list: CoreStyle.list,

                        // if we have an id, we provide style
                        // if we have a ref, we consume/require style
                        ready: function () {
                            if (this.id) {
                                this.provide();
                            } else {
                                this.registerRef(this.ref);
                                if (!window.ShadowDOMPolyfill) {
                                    this.require();
                                }
                            }
                        },

                        // can't shim until attached if using SD polyfill because need to find host
                        attached: function () {
                            if (!this.id && window.ShadowDOMPolyfill) {
                                this.require();
                            }
                        },

                        /****** producer stuff *******/

                        provide: function () {
                            this.register();
                            // we want to do this asap, especially so we can do so before definitions
                            // that use this core-style are registered.
                            if (this.textContent) {
                                this._completeProvide();
                            } else {
                                this.async(this._completeProvide);
                            }
                        },

                        register: function () {
                            var i = this.list[this.id];
                            if (i) {
                                if (!Array.isArray(i)) {
                                    this.list[this.id] = [i];
                                }
                                this.list[this.id].push(this);
                            } else {
                                this.list[this.id] = this;
                            }
                        },

                        // stamp into a shadowRoot so we can monitor dom of the bound output
                        _completeProvide: function () {
                            this.createShadowRoot();
                            this.domObserver = new MutationObserver(this.domModified.bind(this))
                                .observe(this.shadowRoot, {
                                    subtree: true,
                                    characterData: true,
                                    childList: true
                                });
                            this.provideContent();
                        },

                        provideContent: function () {
                            this.ensureTemplate();
                            this.shadowRoot.textContent = '';
                            this.shadowRoot.appendChild(this.instanceTemplate(this.template));
                            this.cssText = this.shadowRoot.textContent;
                        },

                        ensureTemplate: function () {
                            if (!this.template) {
                                this.template = this.querySelector('template:not([repeat]):not([bind])');
                                // move content into the template
                                if (!this.template) {
                                    this.template = document.createElement('template');
                                    var n = this.firstChild;
                                    while (n) {
                                        this.template.content.appendChild(n.cloneNode(true));
                                        n = n.nextSibling;
                                    }
                                }
                            }
                        },

                        domModified: function () {
                            this.cssText = this.shadowRoot.textContent;
                            this.notify();
                        },

                        // notify instances that reference this element
                        notify: function () {
                            var s$ = this.refMap[this.id];
                            if (s$) {
                                for (var i = 0, s;
                                    (s = s$[i]); i++) {
                                    s.require();
                                }
                            }
                        },

                        /****** consumer stuff *******/

                        registerRef: function (ref) {
                            //console.log('register', ref);
                            this.refMap[this.ref] = this.refMap[this.ref] || [];
                            this.refMap[this.ref].push(this);
                        },

                        applyRef: function (ref) {
                            this.ref = ref;
                            this.registerRef(this.ref);
                            this.require();
                        },

                        require: function () {
                            var cssText = this.cssTextForRef(this.ref);
                            //console.log('require', this.ref, cssText);
                            if (cssText) {
                                this.ensureStyleElement();
                                // do nothing if cssText has not changed
                                if (this.styleElement._cssText === cssText) {
                                    return;
                                }
                                this.styleElement._cssText = cssText;
                                if (window.ShadowDOMPolyfill) {
                                    this.styleElement.textContent = cssText;
                                    cssText = Platform.ShadowCSS.shimStyle(this.styleElement,
                                        this.getScopeSelector());
                                }
                                this.styleElement.textContent = cssText;
                            }
                        },

                        cssTextForRef: function (ref) {
                            var s$ = this.byId(ref);
                            var cssText = '';
                            if (s$) {
                                if (Array.isArray(s$)) {
                                    var p = [];
                                    for (var i = 0, l = s$.length, s;
                                        (i < l) && (s = s$[i]); i++) {
                                        p.push(s.cssText);
                                    }
                                    cssText = p.join('\n\n');
                                } else {
                                    cssText = s$.cssText;
                                }
                            }
                            if (s$ && !cssText) {
                                console.warn('No styles provided for ref:', ref);
                            }
                            return cssText;
                        },

                        byId: function (id) {
                            return this.list[id];
                        },

                        ensureStyleElement: function () {
                            if (!this.styleElement) {
                                this.styleElement = window.ShadowDOMPolyfill ?
                                    this.makeShimStyle() :
                                    this.makeRootStyle();
                            }
                            if (!this.styleElement) {
                                console.warn(this.localName, 'could not setup style.');
                            }
                        },

                        makeRootStyle: function () {
                            var style = document.createElement('style');
                            this.appendChild(style);
                            return style;
                        },

                        makeShimStyle: function () {
                            var host = this.findHost(this);
                            if (host) {
                                var name = host.localName;
                                var style = document.querySelector('style[' + name + '=' + this.ref + ']');
                                if (!style) {
                                    style = document.createElement('style');
                                    style.setAttribute(name, this.ref);
                                    document.head.appendChild(style);
                                }
                                return style;
                            }
                        },

                        getScopeSelector: function () {
                            if (!this._scopeSelector) {
                                var selector = '',
                                    host = this.findHost(this);
                                if (host) {
                                    var typeExtension = host.hasAttribute('is');
                                    var name = typeExtension ? host.getAttribute('is') : host.localName;
                                    selector = Platform.ShadowCSS.makeScopeSelector(name,
                                        typeExtension);
                                }
                                this._scopeSelector = selector;
                            }
                            return this._scopeSelector;
                        },

                        findHost: function (node) {
                            while (node.parentNode) {
                                node = node.parentNode;
                            }
                            return node.host || wrap(document.documentElement);
                        },

                        /* filters! */
                        // TODO(dfreedm): add more filters!

                        cycle: function (rgb, amount) {
                            if (rgb.match('#')) {
                                var o = this.hexToRgb(rgb);
                                if (!o) {
                                    return rgb;
                                }
                                rgb = 'rgb(' + o.r + ',' + o.b + ',' + o.g + ')';
                            }

                            function cycleChannel(v) {
                                return Math.abs((Number(v) - amount) % 255);
                            }

                            return rgb.replace(/rgb\(([^,]*),([^,]*),([^,]*)\)/, function (m, a, b, c) {
                                return 'rgb(' + cycleChannel(a) + ',' + cycleChannel(b) + ', ' + cycleChannel(c) + ')';
                            });
                        },

                        hexToRgb: function (hex) {
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? {
                                r: parseInt(result[1], 16),
                                g: parseInt(result[2], 16),
                                b: parseInt(result[3], 16)
                            } : null;
                        }

                    });


                })();
            </script>
        </polymer-element>
        <core-style id="paper-input">

            :host([focused]) .floated-label { color: {{g.paperInput.focusedColor}}; } .focused-underline, .cursor { background-color: {{g.paperInput.focusedColor}}; } :host(.invalid[focused]) .floated-label, :host([focused]) .error-text, :host([focused]) .error-icon { color: {{g.paperInput.invalidColor}}; } :host(.invalid) .focused-underline, :host(.invalid) .cursor { background-color: {{g.paperInput.invalidColor}}; }

        </core-style>

        <polymer-element name="paper-input" extends="core-input" layout="" vertical="" attributes="label floatingLabel maxRows error" on-transitionend="{{transitionEndAction}}" on-webkittransitionend="{{transitionEndAction}}" assetpath="bower_components/paper-input/">

            <template>

                <!--
    Input tests:

    - set value to integer 0
    - various html5 input types
    - sizing:
      - single-line: size with CSS
      - single-line: can fit to container
      - multi-line: size with CSS
      - multi-line: size with rows
      - multi-line: can fit to container
      - multi-line: grows with typing
      - multi-line: max rows
      - multi-line: max rows, scrolls after
    -->

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: inline-block;
                        outline: none;
                        text-align: inherit;
                        color: #757575;
                        padding: 0.75em 0;
                    }
                    :host /deep/ input,
                    :host /deep/ textarea {
                        font: inherit;
                        color: #000;
                        padding: 0;
                        margin: 0;
                        background-color: transparent;
                        border: none;
                        outline: none;
                        /* see comments in template */
                        width: 100%;
                        height: 100%;
                    }
                    input:invalid,
                    textarea:invalid {
                        box-shadow: none;
                    }
                    textarea {
                        resize: none;
                    }
                    [invisible] {
                        visibility: hidden;
                    }
                    [animated] {
                        visibility: visible !important;
                        -webkit-transition: -webkit-transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    .floated-label {
                        font-size: 0.75em;
                        background: transparent;
                        white-space: nowrap;
                    }
                    .mirror-text {
                        padding: 0.5em 0 0.25em;
                        max-width: 100%;
                        white-space: nowrap;
                    }
                    :host([multiline]) .mirror-text {
                        white-space: pre-wrap;
                        word-wrap: break-word;
                    }
                    .label {
                        padding: 0.5em 0 0.25em;
                        background: transparent;
                        pointer-events: none;
                    }
                    .label-text {
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;
                        display: inline-block;
                        max-width: 100%;
                        -moz-transform-origin: 0% 0%;
                        -webkit-transform-origin: 0% 0%;
                        transform-origin: 0% 0%;
                    }
                    .cursor {
                        position: absolute;
                        top: 0.4em;
                        left: 0;
                        width: 1px;
                        height: 1.4em;
                        opacity: 0.4;
                        -moz-transform-origin: 0%;
                        -webkit-transform-origin: 0%;
                        transform-origin: 0%;
                        -webkit-transform: none;
                        transform: none;
                    }
                    .cursor[invisible] {
                        opacity: 0.75;
                        -webkit-transform: translate3d(3em, 0, 0) scale3d(50, 1, 1);
                        transform: translate3d(3em, 0, 0) scale3d(50, 1, 1);
                    }
                    .input-container {
                        position: absolute;
                        /* simulate padding so the input/textarea can use 100% width/height */
                        top: 0.5em;
                        right: 0;
                        bottom: 0.25em;
                        left: 0;
                    }
                    .underline {
                        height: 0px;
                        overflow: visible;
                    }
                    :host([disabled]) .underline {
                        border-bottom: 1px dashed;
                    }
                    .unfocused-underline {
                        height: 1px;
                        background: #757575;
                        border-bottom-color: #757575;
                    }
                    .focused-underline {
                        height: 2px;
                        -webkit-transform: none;
                        transform: none;
                    }
                    .focused-underline[invisible] {
                        -webkit-transform: scale3d(0, 1, 1);
                        transform: scale3d(0, 1, 1);
                    }
                    .error-text {
                        font-size: 0.75em;
                        padding: 0.5em 0;
                    }
                    .error-icon {
                        height: 20px;
                        width: 20px;
                    }
                </style>
                <core-style ref="paper-input"></core-style>

                <div class="floated-label" aria-hidden="true" hidden?="{{!floatingLabel}}" invisible?="{{!inputValue &amp;&amp; !(type === 'number' &amp;&amp; !validity.valid) || labelAnimated}}">
                    <!-- needed for floating label animation measurement -->
                    <span id="floatedLabelText" class="label-text">{{label}}</span>
                </div>

                <!-- <div class="input-body" flex auto relative on-down="{{downAction}}" on-up="{{upAction}}"> -->
                <div class="input-body" flex="" auto="" relative="">

                    <!-- the mirror sizes the input/textarea so it grows with typing -->
                    <div id="mirror" class="mirror-text" invisible="" aria-hidden="true"></div>

                    <div class="label" fit="" aria-hidden="true">
                        <!-- needed for floating label animation measurement -->
                        <span id="labelText" class="label-text" invisible?="{{inputValue || !inputValue &amp;&amp; type === 'number' &amp;&amp; !validity.valid}}" animated?="{{labelAnimated}}">{{label}}</span>
                    </div>

                    <div class="cursor" invisible?="{{!cursorAnimated}}" animated?="{{cursorAnimated}}"></div>

                    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->
                    <div class="input-container" on-down="{{downAction}}" on-up="{{upAction}}">
                        <shadow></shadow>
                    </div>

                </div>

                <div id="underline" class="underline" relative="">
                    <div class="unfocused-underline" fit="" invisible?="{{disabled}}"></div>
                    <div id="focusedUnderline" class="focused-underline" fit="" invisible?="{{!focused}}" animated?="{{underlineAnimated}}"></div>
                </div>

                <div layout="" horizontal="" center="" hidden?="{{!invalid}}">
                    <div class="error-text" flex="" auto="" role="alert" aria-hidden="{{!invalid}}">{{error || validationMessage}}</div>
                    <core-icon class="error-icon" icon="warning"></core-icon>
                </div>

            </template>

            <script>
                (function () {

                    var paperInput = CoreStyle.g.paperInput = CoreStyle.g.paperInput || {};
                    paperInput.focusedColor = '#4059a9';
                    paperInput.invalidColor = '#d34336';

                    Polymer('paper-input', {

                        publish: {
                            /**
                             * The label for this input. It normally appears as grey text inside
                             * the text input and disappears once the user enters text.
                             *
                             * @attribute label
                             * @type string
                             * @default ''
                             */
                            label: '',

                            /**
                             * If true, the label will "float" above the text input once the
                             * user enters text instead of disappearing.
                             *
                             * @attribute floatingLabel
                             * @type boolean
                             * @default false
                             */
                            floatingLabel: false,

                            /**
                             * (multiline only) If set to a non-zero value, the height of this
                             * text input will grow with the value changes until it is maxRows
                             * rows tall. If the maximum size does not fit the value, the text
                             * input will scroll internally.
                             *
                             * @attribute maxRows
                             * @type number
                             * @default 0
                             */
                            maxRows: 0,

                            /**
                             * The message to display if the input value fails validation. If this
                             * is unset or the empty string, a default message is displayed depending
                             * on the type of validation error.
                             *
                             * @attribute error
                             * @type string
                             */
                            error: '',

                            focused: {
                                value: false,
                                reflect: true
                            }

                        },

                        get inputValueForMirror() {
                            var tokens = this.inputValue ? String(this.inputValue).replace(/&/gm, '&amp;').replace(/"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\n') : [''];

                            // Enforce the min and max heights for a multiline input here to
                            // avoid measurement
                            if (this.multiline) {
                                if (this.maxRows && tokens.length > this.maxRows) {
                                    tokens = tokens.slice(0, this.maxRows);
                                }
                                while (this.rows && tokens.length < this.rows) {
                                    tokens.push('');
                                }
                            }

                            return tokens.join('<br>') + '&nbsp;';
                        },

                        get inputHasValue() {
                            // if type = number, the input value is the empty string until a valid number
                            // is entered so we must do some hacks here
                            return this.inputValue || (this.type === 'number' && !this.validity.valid);
                        },

                        syncInputValueToMirror: function () {
                            this.$.mirror.innerHTML = this.inputValueForMirror;
                        },

                        ready: function () {
                            this.syncInputValueToMirror();
                        },

                        prepareLabelTransform: function () {
                            var toRect = this.$.floatedLabelText.getBoundingClientRect();
                            var fromRect = this.$.labelText.getBoundingClientRect();
                            if (toRect.width !== 0) {
                                var sy = toRect.height / fromRect.height;
                                this.$.labelText.cachedTransform =
                                    'scale3d(' + (toRect.width / fromRect.width) + ',' + sy + ',1) ' +
                                    'translate3d(0,' + (toRect.top - fromRect.top) / sy + 'px,0)';
                            }
                        },

                        animateFloatingLabel: function () {
                            if (!this.floatingLabel || this.labelAnimated) {
                                return;
                            }

                            if (!this.$.labelText.cachedTransform) {
                                this.prepareLabelTransform();
                            }

                            // If there's still no cached transform, the input is invisible so don't
                            // do the animation.
                            if (!this.$.labelText.cachedTransform) {
                                return;
                            }

                            this.labelAnimated = true;
                            // Handle interrupted animation
                            this.async(function () {
                                this.transitionEndAction();
                            }, null, 250);

                            if (this.inputHasValue) {
                                this.$.labelText.style.webkitTransform = this.$.labelText.cachedTransform;
                                this.$.labelText.style.transform = this.$.labelText.cachedTransform;
                            } else {
                                // Handle if the label started out floating
                                if (!this.$.labelText.style.webkitTransform && !this.$.labelText.style.transform) {
                                    this.$.labelText.style.webkitTransform = this.$.labelText.cachedTransform;
                                    this.$.labelText.style.transform = this.$.labelText.cachedTransform;
                                    this.$.labelText.offsetTop;
                                }
                                this.$.labelText.style.webkitTransform = '';
                                this.$.labelText.style.transform = '';
                            }
                        },

                        inputValueChanged: function (old) {
                            this.super();

                            this.syncInputValueToMirror();
                            if (old && !this.inputValue || !old && this.inputValue) {
                                this.animateFloatingLabel();
                            }
                        },

                        placeholderChanged: function () {
                            this.label = this.placeholder;
                        },

                        inputFocusAction: function () {
                            this.super(arguments);
                            this.focused = true;
                        },

                        inputBlurAction: function (e) {
                            this.super(arguments);
                            this.focused = false;
                        },

                        downAction: function (e) {
                            if (this.disabled) {
                                return;
                            }

                            if (this.focused) {
                                return;
                            }

                            // The underline spills from the tap location
                            var rect = this.$.underline.getBoundingClientRect();
                            var right = e.x - rect.left;
                            this.$.focusedUnderline.style.mozTransformOrigin = right + 'px';
                            this.$.focusedUnderline.style.webkitTransformOrigin = right + 'px ';
                            this.$.focusedUnderline.style.transformOriginX = right + 'px';

                            // Animations only run when the user interacts with the input
                            this.underlineAnimated = true;

                            // Cursor animation only runs if the input is empty
                            if (!this.inputHasValue) {
                                this.cursorAnimated = true;
                            }
                            // Handle interrupted animation
                            this.async(function () {
                                this.transitionEndAction();
                            }, null, 250);
                        },

                        keydownAction: function () {
                            this.super();

                            // more type = number hacks. see core-input for more info
                            if (this.type === 'number') {
                                var valid = !this.inputValue && this.validity.valid;
                                this.async(function () {
                                    if (valid !== (!this.inputValue && this.validity.valid)) {
                                        this.animateFloatingLabel();
                                    }
                                });
                            }
                        },

                        transitionEndAction: function () {
                            this.underlineAnimated = false;
                            this.cursorAnimated = false;
                            this.labelAnimated = false;
                        }

                    });

                }());
            </script>

        </polymer-element>

        <polymer-element name="paper-item" attributes="label iconSrc icon" center="" horizontal="" layout="" assetpath="bower_components/paper-item/">

            <template>

                <paper-ripple id="ripple"></paper-ripple>

                <core-icon id="icon" hidden?="{{!iconSrc &amp;&amp; !icon}}" src="{{iconSrc}}" icon="{{icon}}"></core-icon>
                <div id="label">{{label}}</div>
                <content></content>
            </template>

            <script>
                Polymer('paper-item', {

                    publish: {

                        /**
                         * The label for the item.
                         *
                         * @attribute label
                         * @type string
                         * @default ''
                         */
                        label: '',

                        /**
                         * (optional) The URL of an image for an icon to use in the button.
                         * Should not use `icon` property if you are using this property.
                         *
                         * @attribute iconSrc
                         * @type string
                         * @default ''
                         */
                        iconSrc: '',

                        /**
                         * (optional) Specifies the icon name or index in the set of icons
                         * available in the icon set. If using this property, load the icon
                         * set separately where the icon is used. Should not use `src`
                         * if you are using this property.
                         *
                         * @attribute icon
                         * @type string
                         * @default ''
                         */
                        icon: ''

                    },

                    eventDelegates: {
                        'down': 'downAction',
                        'up': 'upAction'
                    },

                    downAction: function (e) {
                        this.$.ripple.downAction(e);
                    },

                    upAction: function (e) {
                        this.$.ripple.upAction(e);
                    }
                });
            </script>
        </polymer-element>

        <polymer-element name="core-transition-css" extends="core-transition" attributes="transitionType" assetpath="bower_components/core-transition/">
            <template>
                <style no-shim="">
                    /* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */
                    :host(.core-transition) {
                        outline: none;
                        overflow: auto;
                        opacity: 0;
                        transition: transform 0.2s ease-in-out, opacity 0.2s ease-in;
                        -webkit-transition: -webkit-transform 0.2s ease-in-out, opacity 0.2s ease-in;
                    }
                    :host(.core-transition.core-opened) {
                        opacity: 1;
                        transform: translateZ(0);
                        -webkit-transform: translateZ(0);
                    }
                    :host(.core-transition-center) {
                        transform: scale(0.5);
                        -webkit-transform: scale(0.5);
                    }
                    :host(.core-transition-top) {
                        transform: translateY(-200%);
                        -webkit-transform: translateY(-200%);
                    }
                    :host(.core-transition-bottom) {
                        transform: translateY(200%);
                        -webkit-transform: translateY(200%);
                    }
                    :host(.core-transition-left) {
                        transform: translateX(-200%);
                        -webkit-transform: translateX(-200%);
                    }
                    :host(.core-transition-right) {
                        transform: translateX(200%);
                        -webkit-transform: translateX(200%);
                    }
                </style>
            </template>
            <script>
                Polymer('core-transition-css', {

                    /**
                     * The class that will be applied to all animated nodes.
                     *
                     * @attribute baseClass
                     * @type string
                     * @default "core-transition"
                     */
                    baseClass: 'core-transition',

                    /**
                     * The class that will be applied to nodes in the opened state.
                     *
                     * @attribute openedClass
                     * @type string
                     * @default "core-opened"
                     */
                    openedClass: 'core-opened',

                    /**
                     * The class that will be applied to nodes in the closed state.
                     *
                     * @attribute closedClass
                     * @type string
                     * @default "core-closed"
                     */
                    closedClass: 'core-closed',

                    /**
                     * Event to listen to for animation completion.
                     *
                     * @attribute completeEventName
                     * @type string
                     * @default "transitionEnd"
                     */
                    completeEventName: 'transitionend',

                    publish: {
                        /**
                         * A secondary configuration attribute for the animation. The class
                         * `<baseClass>-<transitionType` is applied to the animated node during
                         * `setup`.
                         *
                         * @attribute transitionType
                         * @type string
                         */
                        transitionType: null
                    },

                    registerCallback: function (element) {
                        this.transitionStyle = element.templateContent().firstElementChild;
                    },

                    // template is just for loading styles, we don't need a shadowRoot
                    fetchTemplate: function () {
                        return null;
                    },

                    go: function (node, state) {
                        if (state.opened !== undefined) {
                            this.transitionOpened(node, state.opened);
                        }
                    },

                    setup: function (node) {
                        if (!node._hasTransitionStyle) {
                            if (!node.shadowRoot) {
                                node.createShadowRoot().innerHTML = '<content></content>';
                            }
                            this.installScopeStyle(this.transitionStyle, 'transition',
                                node.shadowRoot);
                            node._hasTransitionStyle = true;
                        }
                        node.classList.add(this.baseClass);
                        if (this.transitionType) {
                            node.classList.add(this.baseClass + '-' + this.transitionType);
                        }
                    },

                    teardown: function (node) {
                        node.classList.remove(this.baseClass);
                        if (this.transitionType) {
                            node.classList.remove(this.baseClass + '-' + this.transitionType);
                        }
                    },

                    transitionOpened: function (node, opened) {
                        this.listenOnce(node, this.completeEventName, function () {
                            node.classList.toggle(this.revealedClass, opened);
                            if (!opened) {
                                node.classList.remove(this.closedClass);
                            }
                            this.complete(node);
                        });
                        node.classList.toggle(this.openedClass, opened);
                        node.classList.toggle(this.closedClass, !opened);
                    }

                });
            </script>
        </polymer-element>

        <core-transition-css id="core-transition-fade"></core-transition-css>
        <core-transition-css id="core-transition-center" transitiontype="center"></core-transition-css>
        <core-transition-css id="core-transition-top" transitiontype="top"></core-transition-css>
        <core-transition-css id="core-transition-bottom" transitiontype="bottom"></core-transition-css>
        <core-transition-css id="core-transition-left" transitiontype="left"></core-transition-css>
        <core-transition-css id="core-transition-right" transitiontype="right"></core-transition-css>

        <polymer-element name="paper-menu-button-transition" extends="core-transition-css" attributes="duration transformOrigin" assetpath="bower_components/paper-menu-button/">
            <template>
                <style no-shim="">
                    /* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */
                    :host(.paper-menu-button-transition) {
                        outline: none;
                        opacity: 0;
                        transition: transform 0.2s ease-in-out, opacity 0.2s ease-in;
                        -webkit-transition: -webkit-transform 0.2s ease-in-out, opacity 0.2s ease-in;
                    }
                    :host(.paper-menu-button-transition.paper-menu-button-opened) {
                        opacity: 1;
                        transform: none;
                        -webkit-transform: none;
                    }
                </style>
            </template>
            <script>
                Polymer('paper-menu-button-transition', {

                    baseClass: 'paper-menu-button-transition',
                    revealedClass: 'paper-menu-button-revealed',
                    openedClass: 'paper-menu-button-opened',
                    closedClass: 'paper-menu-button-closed',
                    completeEventName: null,

                    duration: 500,

                    setup: function (node) {
                        this.super(arguments);

                        var bg = node.querySelector('.paper-menu-button-overlay-bg');
                        bg.style.transformOrigin = this.transformOrigin;
                        bg.style.webkitTransformOrigin = this.transformOrigin;
                    },

                    transitionOpened: function (node, opened) {
                        this.super(arguments);

                        if (opened) {
                            if (this.player) {
                                this.player.cancel();
                            }

                            var anims = [];

                            var size = node.getBoundingClientRect();

                            var ink = node.querySelector('.paper-menu-button-overlay-ink');
                            var offset = 40 / Math.max(size.width, size.height);
                            anims.push(new Animation(ink, [{
                                'opacity': 0.9,
                                'transform': 'scale(0)',
          }, {
                                'opacity': 0.9,
                                'transform': 'scale(1)'
          }], {
                                duration: this.duration * offset
                            }));

                            var bg = node.querySelector('.paper-menu-button-overlay-bg');
                            anims.push(new Animation(bg, [{
                                'opacity': 0.9,
                                'transform': 'scale(' + 40 / size.width + ',' + 40 / size.height + ')',
          }, {
                                'opacity': 1,
                                'transform': 'scale(0.95, 0.5)'
          }, {
                                'opacity': 1,
                                'transform': 'scale(1, 1)'
          }], {
                                delay: this.duration * offset,
                                duration: this.duration * (1 - offset),
                                fill: 'forwards'
                            }));

                            var items = node.querySelector('#menu').items;
                            var itemDelay = offset + (1 - offset) / 2;
                            var itemDuration = this.duration * (1 - itemDelay) / items.length;
                            var reverse = this.transformOrigin.split(' ')[1] === '100%';
                            items.forEach(function (item, i) {
                                if (!item.classList.contains('paper-menu-button-overlay-bg') && !item.classList.contains('paper-menu-button-overlay-ink')) {
                                    anims.push(new Animation(item, [{
                                        'opacity': 0
              }, {
                                        'opacity': 1
              }], {
                                        delay: this.duration * itemDelay + itemDuration * (reverse ? items.length - 1 - i : i),
                                        duration: itemDuration,
                                        fill: 'both'
                                    }));
                                }
                            }.bind(this));

                            var group = new AnimationGroup(anims, {
                                easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                            });
                            this.player = document.timeline.play(group);
                            this.player.onfinish = function () {
                                this.fire('core-transitionend', this, node);
                            }.bind(this);

                        } else {
                            this.listenOnce(node, 'transitionend', function () {
                                this.fire('core-transitionend', this, node);
                            }.bind(this));
                        }
                    },

                });
            </script>
        </polymer-element>

        <paper-menu-button-transition id="paper-menu-button-transition-top-left" transformorigin="0% 0%"></paper-menu-button-transition>
        <paper-menu-button-transition id="paper-menu-button-transition-top-right" transformorigin="100% 0%"></paper-menu-button-transition>
        <paper-menu-button-transition id="paper-menu-button-transition-top-right-slow" transformorigin="100% 0%" duration="10000"></paper-menu-button-transition>

        <paper-menu-button-transition id="paper-menu-button-transition-bottom-left" transformorigin="0% 100%"></paper-menu-button-transition>
        <paper-menu-button-transition id="paper-menu-button-transition-bottom-right" transformorigin="100% 100%"></paper-menu-button-transition>
        <core-style id="paper-menu-button">

            .paper-menu-button-overlay-ink { background: {{g.paperMenuButton.background}} } .paper-menu-button-overlay-bg { background: {{g.paperMenuButton.background}} }

        </core-style>

        <script>
            (function () {

                CoreStyle.g.paperMenuButton = CoreStyle.g.paperMenuButton || {
                    'background': '#fff'
                };

            })();
        </script>

        <polymer-element name="paper-menu-button" extends="paper-focusable" attributes="src icon opened halign valign slow" assetpath="bower_components/paper-menu-button/">
            <template>

                <style>
                    /*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
                    :host {
                        display: inline-block;
                        padding: 8px;
                        position: relative;
                        background-image: none;
                        outline: none;
                        user-select: none;
                        -webkit-user-select: none;
                        cursor: pointer;
                    }
                    :host([disabled]) {
                        cursor: auto;
                    }
                    core-icon {
                        position: relative;
                    }
                    core-icon::shadow svg {
                        transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        -webkit-transition: -webkit-transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        transform-origin: 50% 50%;
                        -webkit-transform-origin: 50% 50%;
                    }
                    :host(:hover) core-icon::shadow svg {
                        transform: scale(1.2);
                        -webkit-transform: scale(1.2);
                    }
                    :host([disabled]:hover) core-icon::shadow svg {
                        transform: none;
                        -webkit-transform: none;
                    }
                    :host([disabled]) core-icon::shadow path {
                        fill: #c9c9c9;
                    }
                    #dropdown {
                        background-color: transparent;
                        margin: 12px;
                        color: #000;
                    }
                    #menu {
                        padding-top: 8px;
                        padding-bottom: 8px;
                        margin: 0;
                    }
                    .paper-menu-button-overlay-ink {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 40px;
                        height: 40px;
                        border-radius: 20px;
                        opacity: 0;
                        transform: scale(0);
                        -webkit-transform: scale(0);
                    }
                    :host([halign="right"]) .paper-menu-button-overlay-ink {
                        left: auto;
                        right: 0;
                    }
                    :host([valign="bottom"]) .paper-menu-button-overlay-ink {
                        top: auto;
                        bottom: 0;
                    }
                    .paper-menu-button-overlay-bg {
                        position: absolute;
                        top: 0;
                        left: 0;
                        bottom: 0;
                        right: 0;
                        border-radius: 3px;
                        opacity: 0;
                        z-index: -1;
                    }
                    :host([noTransition]) .paper-menu-button-overlay-bg {
                        opacity: 1;
                    }
                    .paper-menu-button-menu-container {
                        overflow: auto;
                        max-height: 100%;
                        max-width: 100%;
                    }
                </style>
                <core-style ref="paper-menu-button"></core-style>

                <core-icon src="{{src}}" icon="{{icon}}" on-tap="{{tapAction}}"></core-icon>

                <core-dropdown id="dropdown" relatedtarget="{{}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}" transition="{{noTransition ? '' : transition}}" on-core-transitionend="{{transitionEndAction}}">

                    <paper-shadow id="shadow" z="1" target="{{$.dropdown}}"></paper-shadow>

                    <div class="paper-menu-button-overlay-ink"></div>
                    <div id="overlayBg" class="paper-menu-button-overlay-bg"></div>

                    <div class="paper-menu-button-menu-container">
                        <core-menu id="menu" selected="{{selected}}" selecteditem="{{selectedItem}}" selectedclass="{{selectedClass}}" valueattr="{{valueattr}}" selectedproperty="{{selectedProperty}}" selectedattribute="{{selectedAttribute}}" on-core-select="{{selectAction}}" on-core-activate="{{activateAction}}">
                            <content></content>
                        </core-menu>
                    </div>

                </core-dropdown>

            </template>
            <script>
                Polymer('paper-menu-button', {

                    publish: {

                        /**
                         * If true, this menu is currently visible.
                         *
                         * @attribute opened
                         * @type boolean
                         * @default false
                         */
                        opened: false,

                        /**
                         * The horizontal alignment of the menu relative to the button.
                         *
                         * @attribute halign
                         * @type 'left' | 'right'
                         * @default 'left'
                         */
                        halign: 'left',

                        /**
                         * The vertical alignment of the menu relative to the button.
                         *
                         * @attribute valign
                         * @type 'bottom' | 'top'
                         * @default 'top'
                         */
                        valign: 'top',

                        /**
                         * Set to true to disable the transition.
                         *
                         * @attribute noTransition
                         * @type boolean
                         * @default false
                         */
                        noTransition: false

                    },

                    computed: {
                        transition: '"paper-menu-button-transition-" + valign + "-" + halign'
                    },

                    /**
                     * The URL of an image for the icon. Should not use `icon` property
                     * if you are using this property.
                     *
                     * @attribute src
                     * @type string
                     * @default ''
                     */
                    src: '',

                    /**
                     * Specifies the icon name or index in the set of icons available in
                     * the icon set.  Should not use `src` property if you are using this
                     * property.
                     *
                     * @attribute icon
                     * @type string
                     * @default ''
                     */
                    icon: '',

                    tapAction: function () {
                        if (this.disabled) {
                            return;
                        }

                        this.super();
                        this.toggle();
                        if (this.opened && !this.noTransition) {
                            this.$.shadow.z = 0;
                        }
                    },

                    transitionEndAction: function () {
                        this.$.shadow.z = 1;
                    },

                    activateAction: function () {
                        this.opened = false;
                    },

                    /**
                     * Toggle the opened state of the menu.
                     *
                     * @method toggle
                     */
                    toggle: function () {
                        this.opened = !this.opened;
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-range" attributes="value min max step ratio" assetpath="bower_components/core-range/">
            <script>
                Polymer('core-range', {

                    /**
                     * The number that represents the current value.
                     *
                     * @attribute value
                     * @type number
                     * @default 0
                     */
                    value: 0,

                    /**
                     * The number that indicates the minimum value of the range.
                     *
                     * @attribute min
                     * @type number
                     * @default 0
                     */
                    min: 0,

                    /**
                     * The number that indicates the maximum value of the range.
                     *
                     * @attribute max
                     * @type number
                     * @default 100
                     */
                    max: 100,

                    /**
                     * Specifies the value granularity of the range's value.
                     *
                     * @attribute step
                     * @type number
                     * @default 1
                     */
                    step: 1,

                    /**
                     * Returns the ratio of the value.
                     *
                     * @attribute ratio
                     * @type number
                     * @default 0
                     */
                    ratio: 0,

                    observe: {
                        'value min max step': 'update'
                    },

                    calcRatio: function (value) {
                        return (this.clampValue(value) - this.min) / (this.max - this.min);
                    },

                    clampValue: function (value) {
                        return Math.min(this.max, Math.max(this.min, this.calcStep(value)));
                    },

                    calcStep: function (value) {
                        return this.step ? (Math.round(value / this.step) / (1 / this.step)) : value;
                    },

                    validateValue: function () {
                        var v = this.clampValue(this.value);
                        this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
                        return this.value !== v;
                    },

                    update: function () {
                        this.validateValue();
                        this.ratio = this.calcRatio(this.value) * 100;
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-progress" extends="core-range" attributes="secondaryProgress" assetpath="bower_components/paper-progress/">

            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                        width: 200px;
                        height: 4px;
                    }
                    #progressContainer {
                        position: relative;
                        height: 100%;
                        background-color: #c8c8c8;
                    }
                    #activeProgress,
                    #secondaryProgress {
                        position: absolute;
                        top: 0;
                        left: 0;
                        bottom: 0;
                    }
                    #activeProgress {
                        background-color: #0f9d58;
                    }
                    #secondaryProgress {
                        background-color: #87ceac;
                    }
                </style>

                <div id="progressContainer" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="{{min}}" aria-valuemax="{{max}}">

                    <div id="secondaryProgress" _style="width: {{secondaryRatio}}%;"></div>
                    <div id="activeProgress" _style="width: {{ratio}}%;"></div>

                </div>

            </template>

            <script>
                Polymer('paper-progress', {

                    /**
                     * The number that represents the current secondary progress.
                     *
                     * @attribute secondaryProgress
                     * @type number
                     * @default 0
                     */
                    secondaryProgress: 0,

                    step: 0,

                    observe: {
                        'value secondaryProgress min max': 'update'
                    },

                    update: function () {
                        this.super();
                        this.secondaryProgress = this.clampValue(this.secondaryProgress);
                        this.secondaryRatio = this.calcRatio(this.secondaryProgress) * 100;
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="paper-radio-group" extends="core-selector" role="radiogroup" assetpath="bower_components/paper-radio-group/">

            <template>

                <style>
                    :host {
                        display: inline-block;
                    }
                    polyfill-next-selector {
                        content: ':host > *';
                    }
                    ::content > * {
                        padding: 12px;
                    }
                </style>

                <shadow></shadow>

            </template>

            <script>
                Polymer('paper-radio-group', {

                    selectedAttribute: 'checked',
                    activateEvent: 'change'

                });
            </script>

        </polymer-element>

        <polymer-element name="paper-slider" extends="core-range" attributes="snaps pin disabled secondaryProgress editable immediateValue" role="slider" tabindex="0" aria-valuemin="0" aria-valuemax="100" assetpath="bower_components/paper-slider/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                        width: 200px;
                        cursor: default;
                    }
                    :host(:focus) {
                        outline: none;
                    }
                    #sliderContainer {
                        position: relative;
                        width: calc(100% - 32px);
                        height: 32px;
                    }
                    #sliderContainer.editable {
                        float: left;
                        width: calc(100% - 72px);
                        margin: 12px 0;
                    }
                    .bar-container {
                        position: absolute;
                        top: 0;
                        left: 16px;
                        height: 100%;
                        width: 100%;
                        overflow: hidden;
                    }
                    .ring > .bar-container {
                        left: 20px;
                        width: calc(100% - 4px);
                        transition: left 0.18s ease, width 0.18s ease;
                    }
                    .ring.expand:not(.pin) > .bar-container {
                        left: 30px;
                        width: calc(100% - 14px);
                    }
                    .ring.expand.dragging > .bar-container {
                        transition: none;
                    }
                    #sliderBar {
                        position: absolute;
                        top: 15px;
                        left: 0;
                        height: 2px;
                        width: 100%;
                        padding: 8px 0;
                        margin: -8px 0;
                    }
                    .ring #sliderBar {
                        left: -4px;
                        width: calc(100% + 4px);
                    }
                    .ring.expand:not(.pin) #sliderBar {
                        left: -14px;
                        width: calc(100% + 14px);
                    }
                    .slider-markers {
                        position: absolute;
                        top: 15px;
                        left: 15px;
                        height: 2px;
                        width: calc(100% + 2px);
                        box-sizing: border-box;
                        pointer-events: none;
                    }
                    .slider-markers::after,
                    .slider-marker::after {
                        content: "";
                        display: block;
                        width: 2px;
                        height: 2px;
                        border-radius: 50%;
                        background-color: black;
                    }
                    #sliderBar::shadow #activeProgress {
                        background-color: #3f51b5;
                    }
                    .transiting #sliderBar::shadow #activeProgress {
                        transition: width 0.08s ease;
                    }
                    #sliderKnob {
                        position: absolute;
                        left: 0;
                        top: 0;
                        width: 32px;
                        height: 32px;
                    }
                    .transiting > #sliderKnob {
                        transition: left 0.08s ease;
                    }
                    #sliderKnob:focus {
                        outline: none;
                    }
                    #sliderKnob.dragging {
                        transition: none;
                    }
                    .snaps > #sliderKnob.dragging {
                        transition: -webkit-transform 0.08s ease;
                        transition: transform 0.08s ease;
                    }
                    #sliderKnobInner {
                        width: 12px;
                        height: 12px;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                        border-radius: 50%;
                        background-color: #3f51b5;
                        /* FIXME(ffu): can't use the following. https://github.com/Polymer/platform/issues/53 */
                        /* transition-property: height, width, background-color, border;
  transition-duration: 0.1s;
  transition-timing-function: ease; */
                        transition: height 0.18s ease, width 0.18s ease;
                    }
                    .expand:not(.pin) > #sliderKnob > #sliderKnobInner {
                        width: 100%;
                        height: 100%;
                        -webkit-transform: translateZ(0);
                        transform: translateZ(0);
                    }
                    .ring > #sliderKnob > #sliderKnobInner {
                        background-color: transparent;
                        border: 2px solid #c8c8c8;
                    }
                    #sliderKnobInner::before {
                        background-color: #3f51b5;
                    }
                    .pin > #sliderKnob > #sliderKnobInner::before {
                        content: "";
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 26px;
                        height: 26px;
                        margin-left: 3px;
                        border-radius: 50% 50% 50% 0;
                        -webkit-transform: rotate(-45deg) scale(0) translate(0);
                        transform: rotate(-45deg) scale(0) translate(0);
                    }
                    #sliderKnobInner::before,
                    #sliderKnobInner::after {
                        transition: -webkit-transform .2s ease, background-color .18s ease;
                        transition: transform .2s ease, background-color .18s ease;
                    }
                    .pin.ring > #sliderKnob > #sliderKnobInner::before {
                        background-color: #c8c8c8;
                    }
                    .pin.expand > #sliderKnob > #sliderKnobInner::before {
                        -webkit-transform: rotate(-45deg) scale(1) translate(17px, -17px);
                        transform: rotate(-45deg) scale(1) translate(17px, -17px);
                    }
                    .pin > #sliderKnob > #sliderKnobInner::after {
                        content: attr(value);
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 32px;
                        height: 26px;
                        text-align: center;
                        color: #fff;
                        font-size: 10px;
                        -webkit-transform: scale(0) translate(0);
                        transform: scale(0) translate(0);
                    }
                    .pin.expand > #sliderKnob > #sliderKnobInner::after {
                        -webkit-transform: scale(1) translate(0, -17px);
                        transform: scale(1) translate(0, -17px);
                    }
                    /* editable: paper-input */
                    .slider-input {
                        width: 40px;
                        float: right;
                        overflow: hidden;
                    }
                    .slider-input::shadow input {
                        /* FIXME(ffu): should one be able set text-align directly on paper-input? */
                        text-align: center;
                    }
                    /* disabled state */
                    #sliderContainer.disabled {
                        pointer-events: none;
                    }
                    .disabled > #sliderKnob > #sliderKnobInner {
                        width: 8px;
                        height: 8px;
                        background-color: #c8c8c8;
                    }
                    .disabled.ring > #sliderKnob > #sliderKnobInner {
                        background-color: transparent;
                    }
                    #sliderContainer.disabled #sliderBar::shadow #activeProgress {
                        background-color: #c8c8c8;
                    }
                </style>

                <template if="{{!disabled}}">
                    <core-a11y-keys target="{{}}" keys="left down pagedown home" on-keys-pressed="{{decrementKey}}"></core-a11y-keys>
                    <core-a11y-keys target="{{}}" keys="right up pageup end" on-keys-pressed="{{incrementKey}}"></core-a11y-keys>
                </template>

                <div id="sliderContainer" class="{{ {disabled: disabled, pin: pin, snaps: snaps, ring: immediateValue <= min, expand: expand, dragging: dragging, transiting: transiting, editable: editable} | tokenList }}">

                    <div class="bar-container">
                        <paper-progress id="sliderBar" aria-hidden="true" min="{{min}}" max="{{max}}" value="{{immediateValue}}" secondaryprogress="{{secondaryProgress}}" on-down="{{bardown}}" on-up="{{resetKnob}}" on-trackstart="{{trackStart}}" on-trackx="{{trackx}}" on-trackend="{{trackEnd}}"></paper-progress>
                    </div>

                    <template if="{{snaps &amp;&amp; !disabled}}">
                        <div class="slider-markers" horizontal="" layout="">
                            <template repeat="{{markers}}">
                                <div flex="" class="slider-marker"></div>
                            </template>
                        </div>
                    </template>

                    <div id="sliderKnob" on-down="{{expandKnob}}" on-up="{{resetKnob}}" on-trackstart="{{trackStart}}" on-trackx="{{trackx}}" on-trackend="{{trackEnd}}" on-transitionend="{{knobTransitionEnd}}" center-justified="" center="" horizontal="" layout="">

                        <div id="sliderKnobInner" value="{{immediateValue}}"></div>

                    </div>

                </div>

                <template if="{{editable}}">
                    <paper-input id="input" class="slider-input" value="{{immediateValue}}" disabled?="{{disabled}}" on-change="{{inputChange}}"></paper-input>
                </template>

            </template>
            <script>
                Polymer('paper-slider', {

                    /**
                     * Fired when the slider's value changes.
                     *
                     * @event core-change
                     */

                    /**
                     * Fired when the slider's value changes due to user interaction.
                     *
                     * Changes to the slider's value due to changes in an underlying
                     * bound variable will not trigger this event.
                     *
                     * @event change
                     */

                    /**
                     * If true, the slider thumb snaps to tick marks evenly spaced based
                     * on the `step` property value.
                     *
                     * @attribute snaps
                     * @type boolean
                     * @default false
                     */
                    snaps: false,

                    /**
                     * If true, a pin with numeric value label is shown when the slider thumb
                     * is pressed.  Use for settings for which users need to know the exact
                     * value of the setting.
                     *
                     * @attribute pin
                     * @type boolean
                     * @default false
                     */
                    pin: false,

                    /**
                     * If true, this slider is disabled.  A disabled slider cannot be tapped
                     * or dragged to change the slider value.
                     *
                     * @attribute disabled
                     * @type boolean
                     * @default false
                     */
                    disabled: false,

                    /**
                     * The number that represents the current secondary progress.
                     *
                     * @attribute secondaryProgress
                     * @type number
                     * @default 0
                     */
                    secondaryProgress: 0,

                    /**
                     * If true, an input is shown and user can use it to set the slider value.
                     *
                     * @attribute editable
                     * @type boolean
                     * @default false
                     */
                    editable: false,

                    /**
                     * The immediate value of the slider.  This value is updated while the user
                     * is dragging the slider.
                     *
                     * @attribute immediateValue
                     * @type number
                     * @default 0
                     */

                    observe: {
                        'step snaps': 'update'
                    },

                    ready: function () {
                        this.update();
                    },

                    update: function () {
                        this.positionKnob(this.calcRatio(this.value));
                        this.updateMarkers();
                    },

                    minChanged: function () {
                        this.update();
                        this.setAttribute('aria-valuemin', this.min);
                    },

                    maxChanged: function () {
                        this.update();
                        this.setAttribute('aria-valuemax', this.max);
                    },

                    valueChanged: function () {
                        this.update();
                        this.setAttribute('aria-valuenow', this.value);
                        this.fire('core-change');
                    },

                    disabledChanged: function () {
                        if (this.disabled) {
                            this.removeAttribute('tabindex');
                        } else {
                            this.tabIndex = 0;
                        }
                    },

                    immediateValueChanged: function () {
                        if (!this.dragging) {
                            this.value = this.immediateValue;
                        }
                    },

                    expandKnob: function () {
                        this.expand = true;
                    },

                    resetKnob: function () {
                        this.expandJob && this.expandJob.stop();
                        this.expand = false;
                    },

                    positionKnob: function (ratio) {
                        this.immediateValue = this.calcStep(this.calcKnobPosition(ratio)) || 0;
                        this._ratio = this.snaps ? this.calcRatio(this.immediateValue) : ratio;
                        this.$.sliderKnob.style.left = this._ratio * 100 + '%';
                    },

                    inputChange: function () {
                        this.value = this.$.input.value;
                        this.fire('change');
                    },

                    calcKnobPosition: function (ratio) {
                        return (this.max - this.min) * ratio + this.min;
                    },

                    trackStart: function (e) {
                        this._w = this.$.sliderBar.offsetWidth;
                        this._x = this._ratio * this._w;
                        this._startx = this._x || 0;
                        this._minx = -this._startx;
                        this._maxx = this._w - this._startx;
                        this.$.sliderKnob.classList.add('dragging');
                        this.dragging = true;
                        e.preventTap();
                    },

                    trackx: function (e) {
                        var x = Math.min(this._maxx, Math.max(this._minx, e.dx));
                        this._x = this._startx + x;
                        this.immediateValue = this.calcStep(
                            this.calcKnobPosition(this._x / this._w)) || 0;
                        var s = this.$.sliderKnob.style;
                        s.transform = s.webkitTransform = 'translate3d(' + (this.snaps ?
                            (this.calcRatio(this.immediateValue) * this._w) - this._startx : x) + 'px, 0, 0)';
                    },

                    trackEnd: function () {
                        var s = this.$.sliderKnob.style;
                        s.transform = s.webkitTransform = '';
                        this.$.sliderKnob.classList.remove('dragging');
                        this.dragging = false;
                        this.resetKnob();
                        this.value = this.immediateValue;
                        this.fire('change');
                    },

                    bardown: function (e) {
                        this.transiting = true;
                        this._w = this.$.sliderBar.offsetWidth;
                        var rect = this.$.sliderBar.getBoundingClientRect();
                        var ratio = (e.x - rect.left) / this._w;
                        this.positionKnob(ratio);
                        this.expandJob = this.job(this.expandJob, this.expandKnob, 60);
                        this.fire('change');
                    },

                    knobTransitionEnd: function (e) {
                        if (e.target === this.$.sliderKnob) {
                            this.transiting = false;
                        }
                    },

                    updateMarkers: function () {
                        this.markers = [], l = (this.max - this.min) / this.step;
                        for (var i = 0; i < l; i++) {
                            this.markers.push('');
                        }
                    },

                    increment: function () {
                        this.value = this.clampValue(this.value + this.step);
                    },

                    decrement: function () {
                        this.value = this.clampValue(this.value - this.step);
                    },

                    incrementKey: function (ev, keys) {
                        if (keys.key === "end") {
                            this.value = this.max;
                        } else {
                            this.increment();
                        }
                        this.fire('change');
                    },

                    decrementKey: function (ev, keys) {
                        if (keys.key === "home") {
                            this.value = this.min;
                        } else {
                            this.decrement();
                        }
                        this.fire('change');
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="paper-tab" attributes="noink" role="tab" assetpath="bower_components/paper-tabs/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                        overflow: hidden;
                    }
                    #tabContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                    }
                    .tab-content {
                        transition: opacity .1s cubic-bezier(0.4, 0.0, 1, 1), color .1s cubic-bezier(0.4, 0.0, 1, 1);
                        cursor: default;
                        pointer-events: none;
                    }
                    :host(:not(.core-selected)) .tab-content {
                        opacity: 0.6;
                    }
                    #ink {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        color: #ffff8d;
                    }
                    :host[noink] #ink {
                        pointer-events: none;
                    }
                    :host-context(paper-tabs[noink]) #ink {
                        pointer-events: none;
                    }
                </style>

                <div id="tabContainer" center-justified="" center="" horizontal="" layout="">

                    <div class="tab-content">
                        <content></content>
                    </div>
                    <paper-ripple id="ink" initialopacity="0.95" opacitydecayvelocity="0.98"></paper-ripple>

                </div>

            </template>
            <script>
                Polymer('paper-tab', {

                    /**
                     * If true, ink ripple effect is disabled.
                     *
                     * @attribute noink
                     * @type boolean
                     * @default false
                     */
                    noink: false

                });
            </script>
        </polymer-element>
        <polymer-element name="paper-tabs" extends="core-selector" attributes="noink nobar" role="tablist" assetpath="bower_components/paper-tabs/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                        font-size: 14px;
                        font-weight: 500;
                        height: 48px;
                        overflow: hidden;
                    }
                    #tabsContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        white-space: nowrap;
                    }
                    #selectionBar {
                        position: absolute;
                        height: 2px;
                        bottom: 0;
                        left: 0;
                        width: 0;
                        background-color: #ffff8d;
                        transition: width, left;
                    }
                    #selectionBar[hidden] {
                        display: hidden;
                    }
                    #selectionBar.expand {
                        transition-duration: 0.15s;
                        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
                    }
                    #selectionBar.contract {
                        transition-duration: 0.18s;
                        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
                    }
                    polyfill-next-selector {
                        content: '#tabsContainer > *:not(#selectionBar)';
                    }
                    ::content > * {
                        -ms-flex: 1;
                        -webkit-flex: 1;
                        flex: 1;
                    }
                </style>

                <div id="tabsContainer" horizontal="" layout="">

                    <shadow></shadow>
                    <div id="selectionBar" hidden?="{{nobar}}" on-transitionend="{{barTransitionEnd}}"></div>

                </div>

            </template>
            <script>
                Polymer('paper-tabs', {

                    /**
                     * If true, ink effect is disabled.
                     *
                     * @attribute noink
                     * @type boolean
                     * @default false
                     */
                    noink: false,

                    /**
                     * If true, the bottom bar to indicate the selected tab will not be shown.
                     *
                     * @attribute nobar
                     * @type boolean
                     * @default false
                     */
                    nobar: false,

                    activateEvent: 'down',

                    nostretch: false,

                    selectedIndexChanged: function (old) {
                        var s = this.$.selectionBar.style;

                        if (!this.selectedItem) {
                            s.width = 0;
                            s.left = 0;
                            return;
                        }

                        var w = 100 / this.items.length;

                        if (this.nostretch || old === null || old === -1) {
                            s.width = w + '%';
                            s.left = this.selectedIndex * w + '%';
                            return;
                        }

                        var m = 5;
                        this.$.selectionBar.classList.add('expand');
                        if (old < this.selectedIndex) {
                            s.width = w + w * (this.selectedIndex - old) - m + '%';
                            this._transitionCounter = 1;
                        } else {
                            s.width = w + w * (old - this.selectedIndex) - m + '%';
                            s.left = this.selectedIndex * w + m + '%';
                            this._transitionCounter = 2;
                        }
                    },

                    barTransitionEnd: function (e) {
                        this._transitionCounter--;
                        var cl = this.$.selectionBar.classList;
                        if (cl.contains('expand') && !this._transitionCounter) {
                            cl.remove('expand');
                            cl.add('contract');
                            var s = this.$.selectionBar.style;
                            var w = 100 / this.items.length;
                            s.width = w + '%';
                            s.left = this.selectedIndex * w + '%';
                        } else if (cl.contains('contract')) {
                            cl.remove('contract');
                        }
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-media-query" attributes="query queryMatches" assetpath="bower_components/core-media-query/">
            <template>
                <style>
                    :host {
                        display: none;
                    }
                </style>
            </template>
            <script>
                Polymer('core-media-query', {

                    /**
                     * The Boolean return value of the media query
                     *
                     * @attribute queryMatches
                     * @type Boolean
                     * @default false
                     */
                    queryMatches: false,

                    /**
                     * The CSS media query to evaulate
                     *
                     * @attribute query
                     * @type string
                     * @default ''
                     */
                    query: '',
                    ready: function () {
                        this._mqHandler = this.queryHandler.bind(this);
                        this._mq = null;
                    },
                    queryChanged: function () {
                        if (this._mq) {
                            this._mq.removeListener(this._mqHandler);
                        }
                        var query = this.query;
                        if (query[0] !== '(') {
                            query = '(' + this.query + ')';
                        }
                        this._mq = window.matchMedia(query);
                        this._mq.addListener(this._mqHandler);
                        this.queryHandler(this._mq);
                    },
                    queryHandler: function (mq) {
                        this.queryMatches = mq.matches;
                        this.asyncFire('core-media-change', mq);
                    }
                });
            </script>
        </polymer-element>
        <polymer-element name="paper-toast" attributes="text duration opened responsiveWidth swipeDisabled" role="status" assetpath="bower_components/paper-toast/">

            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                        background: #323232;
                        color: #f1f1f1;
                        min-height: 48px;
                        min-width: 288px;
                        padding: 16px 24px 12px;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
                        border-radius: 2px;
                        bottom: 12px;
                        left: 12px;
                        font-size: 14px;
                        cursor: default;
                    }
                    :host(.capsule) {
                        border-radius: 24px;
                    }
                    :host(.fit-bottom) {
                        bottom: 0;
                        left: 0;
                        width: 100%;
                        min-width: 0;
                        border-radius: 0;
                    }
                    :host(.core-transition.dragging) {
                        transition: none;
                    }
                    :host(.core-transition.fade-out-down),
                    :host(.core-transition.fade-out-up),
                    :host(.core-transition.fade-out-right),
                    :host(.core-transition.fade-out-left) {
                        opacity: 0;
                        transition: -webkit-transform 0.08s ease-in-out, opacity 0.08s ease-in-out;
                        transition: transform 0.08s ease-in-out, opacity 0.08s ease-in-out;
                    }
                    :host(.core-transition.fade-out-down) {
                        -webkit-transform: translate(0, 100%);
                        transform: translate(0, 100%);
                    }
                    :host(.core-transition.fade-out-up) {
                        -webkit-transform: translate(0, -100%);
                        transform: translate(0, -100%);
                    }
                    :host(.core-transition.fade-out-right) {
                        -webkit-transform: translate(100%, 0);
                        transform: translate(100%, 0);
                    }
                    :host(.core-transition.fade-out-left) {
                        -webkit-transform: translate(-100%, 0);
                        transform: translate(-100%, 0);
                    }
                    .toast-container {
                        overflow: hidden;
                    }
                    .toast-action {
                        padding-left: 24px;
                        cursor: pointer;
                        text-transform: uppercase;
                    }
                </style>

                <core-overlay autofocusdisabled="" opened="{{opened}}" target="{{}}" sizingtarget="{{$.container}}" transition="core-transition-bottom"></core-overlay>

                <div class="toast-container" horizontal="" layout="">

                    <div class="toast-text" flex="">{{text}}</div>

                    <div class="toast-text toast-action" on-tap="{{dismiss}}">
                        <content></content>
                    </div>

                </div>

                <core-media-query query="max-width: {{responsiveWidth}}" querymatches="{{narrowMode}}"></core-media-query>

            </template>
            <script>
                (function () {

                    var currentToast;

                    Polymer('paper-toast', {

                        /**
                         * The text shows in a toast.
                         *
                         * @attribute text
                         * @type string
                         * @default ''
                         */
                        text: '',

                        /**
                         * The duration in milliseconds to show the toast.
                         *
                         * @attribute duration
                         * @type number
                         * @default 3000
                         */
                        duration: 3000,

                        /**
                         * Set opened to true to show the toast and to false to hide it.
                         *
                         * @attribute opened
                         * @type boolean
                         * @default false
                         */
                        opened: false,

                        /**
                         * Min-width when the toast changes to narrow layout.  In narrow layout,
                         * the toast fits at the bottom of the screen when opened.
                         *
                         * @attribute responsiveWidth
                         * @type string
                         * @default '480px'
                         */
                        responsiveWidth: '480px',

                        /**
                         * If true, the toast can't be swiped.
                         *
                         * @attribute swipeDisabled
                         * @type boolean
                         * @default false
                         */
                        swipeDisabled: false,

                        eventDelegates: {
                            trackstart: 'trackStart',
                            track: 'track',
                            trackend: 'trackEnd',
                            transitionend: 'transitionEnd'
                        },

                        narrowModeChanged: function () {
                            this.classList.toggle('fit-bottom', this.narrowMode);
                        },

                        openedChanged: function () {
                            if (this.opened) {
                                this.dismissJob = this.job(this.dismissJob, this.dismiss, this.duration);
                            } else {
                                this.dismissJob && this.dismissJob.stop();
                                this.dismiss();
                            }
                        },

                        /**
                         * Toggle the opened state of the toast.
                         * @method toggle
                         */
                        toggle: function () {
                            this.opened = !this.opened;
                        },

                        /**
                         * Show the toast for the specified duration
                         * @method show
                         */
                        show: function () {
                            if (currentToast) {
                                currentToast.dismiss();
                            }
                            currentToast = this;
                            this.opened = true;
                        },

                        /**
                         * Dismiss the toast and hide it.
                         * @method dismiss
                         */
                        dismiss: function () {
                            if (this.dragging) {
                                this.shouldDismiss = true;
                            } else {
                                this.opened = false;
                                if (currentToast === this) {
                                    currentToast = null;
                                }
                            }
                        },

                        trackStart: function (e) {
                            if (!this.swipeDisabled) {
                                e.preventTap();
                                this.vertical = e.yDirection;
                                this.w = this.offsetWidth;
                                this.h = this.offsetHeight;
                                this.dragging = true;
                                this.classList.add('dragging');
                            }
                        },

                        track: function (e) {
                            if (this.dragging) {
                                var s = this.style;
                                if (this.vertical) {
                                    var y = e.dy;
                                    s.opacity = (this.h - Math.abs(y)) / this.h;
                                    s.webkitTransform = s.transform = 'translate3d(0, ' + y + 'px, 0)';
                                } else {
                                    var x = e.dx;
                                    s.opacity = (this.w - Math.abs(x)) / this.w;
                                    s.webkitTransform = s.transform = 'translate3d(' + x + 'px, 0, 0)';
                                }
                            }
                        },

                        trackEnd: function (e) {
                            if (this.dragging) {
                                this.classList.remove('dragging');
                                this.style.opacity = null;
                                this.style.webkitTransform = this.style.transform = null;
                                var cl = this.classList;
                                if (this.vertical) {
                                    cl.toggle('fade-out-down', e.yDirection === 1 && e.dy > 0);
                                    cl.toggle('fade-out-up', e.yDirection === -1 && e.dy < 0);
                                } else {
                                    cl.toggle('fade-out-right', e.xDirection === 1 && e.dx > 0);
                                    cl.toggle('fade-out-left', e.xDirection === -1 && e.dx < 0);
                                }
                                this.dragging = false;
                            }
                        },

                        transitionEnd: function () {
                            var cl = this.classList;
                            if (cl.contains('fade-out-right') || cl.contains('fade-out-left') ||
                                cl.contains('fade-out-down') || cl.contains('fade-out-up')) {
                                this.dismiss();
                                cl.remove('fade-out-right', 'fade-out-left',
                                    'fade-out-down', 'fade-out-up');
                            } else if (this.shouldDismiss) {
                                this.dismiss();
                            }
                            this.shouldDismiss = false;
                        }

                    });

                })();
            </script>
        </polymer-element>

        <polymer-element name="paper-toggle-button" attributes="checked" role="button" aria-pressed="false" tabindex="0" assetpath="bower_components/paper-toggle-button/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: inline-block;
                    }
                    :host(:focus) {
                        outline: none;
                    }
                    #toggleContainer {
                        position: relative;
                        width: 64px;
                        height: 16px;
                    }
                    #toggleBar {
                        position: absolute;
                        top: 8px;
                        left: 16px;
                        height: 1px;
                        width: 32px;
                        background-color: #5a5a5a;
                        pointer-events: none;
                    }
                    #toggleBar[checked] {
                        background-color: #0f9d58;
                    }
                    #toggleContainer[checked] #checkedBar {
                        width: 100%;
                    }
                    #toggleRadio {
                        position: absolute;
                        left: 0;
                        padding: 8px 48px 8px 0;
                        margin: -8px -48px -8px 0;
                        transition: -webkit-transform linear .08s;
                        transition: transform linear .08s;
                    }
                    #toggleRadio[checked] {
                        -webkit-transform: translate(48px, 0);
                        transform: translate(48px, 0);
                        padding: 8px 0 8px 48px;
                        margin: -8px 0 -8px -48px;
                    }
                    #toggleRadio.dragging {
                        -webkit-transition: none;
                        transition: none;
                    }
                </style>

                <div id="toggleContainer">

                    <div id="toggleBar" checked?="{{checked}}"></div>

                    <paper-radio-button id="toggleRadio" toggles="" checked="{{checked}}" on-change="{{changeAction}}" on-core-change="{{stopPropagation}}" on-trackstart="{{trackStart}}" on-trackx="{{trackx}}" on-trackend="{{trackEnd}}"></paper-radio-button>

                </div>

            </template>
            <script>
                Polymer('paper-toggle-button', {

                    /**
                     * Fired when the checked state changes due to user interaction.
                     *
                     * @event change
                     */

                    /**
                     * Fired when the checked state changes.
                     *
                     * @event core-change
                     */

                    /**
                     * Gets or sets the state, `true` is checked and `false` is unchecked.
                     *
                     * @attribute checked
                     * @type boolean
                     * @default false
                     */
                    checked: false,

                    trackStart: function (e) {
                        this._w = this.$.toggleBar.offsetLeft + this.$.toggleBar.offsetWidth;
                        e.preventTap();
                    },

                    trackx: function (e) {
                        this._x = Math.min(this._w,
                            Math.max(0, this.checked ? this._w + e.dx : e.dx));
                        this.$.toggleRadio.classList.add('dragging');
                        var s = this.$.toggleRadio.style;
                        s.webkitTransform = s.transform = 'translate3d(' + this._x + 'px,0,0)';
                    },

                    trackEnd: function () {
                        var s = this.$.toggleRadio.style;
                        s.transform = s.webkitTransform = '';
                        this.$.toggleRadio.classList.remove('dragging');
                        var old = this.checked;
                        this.checked = Math.abs(this._x) > this._w / 2;
                        if (this.checked !== old) {
                            this.fire('change');
                        }
                    },

                    checkedChanged: function () {
                        this.setAttribute('aria-pressed', Boolean(this.checked));
                        this.fire('core-change');
                    },

                    changeAction: function (e) {
                        e.stopPropagation();
                        this.fire('change');
                    },

                    stopPropagation: function (e) {
                        e.stopPropagation();
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-xhr" hidden="" assetpath="bower_components/core-ajax/">

            <script>
                Polymer('core-xhr', {

                    /**
                     * Sends a HTTP request to the server and returns the XHR object.
                     *
                     * @method request
                     * @param {Object} inOptions
                     *    @param {String} inOptions.url The url to which the request is sent.
                     *    @param {String} inOptions.method The HTTP method to use, default is GET.
                     *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously. To send synchronous requests, set to true.
                     *    @param {Object} inOptions.params Data to be sent to the server.
                     *    @param {Object} inOptions.body The content for the request body for POST method.
                     *    @param {Object} inOptions.headers HTTP request headers.
                     *    @param {String} inOptions.responseType The response type. Default is 'text'.
                     *    @param {boolean} inOptions.withCredentials Whether or not to send credentials on the request. Default is false.
                     *    @param {Object} inOptions.callback Called when request is completed.
                     * @returns {Object} XHR object.
                     */
                    request: function (options) {
                        var xhr = new XMLHttpRequest();
                        var url = options.url;
                        var method = options.method || 'GET';
                        var async = !options.sync;
                        //
                        var params = this.toQueryString(options.params);
                        if (params && method == 'GET') {
                            url += (url.indexOf('?') > 0 ? '&' : '?') + params;
                        }
                        var xhrParams = this.isBodyMethod(method) ? (options.body || params) : null;
                        //
                        xhr.open(method, url, async);
                        if (options.responseType) {
                            xhr.responseType = options.responseType;
                        }
                        if (options.withCredentials) {
                            xhr.withCredentials = true;
                        }
                        this.makeReadyStateHandler(xhr, options.callback);
                        this.setRequestHeaders(xhr, options.headers);
                        xhr.send(xhrParams);
                        if (!async) {
                            xhr.onreadystatechange(xhr);
                        }
                        return xhr;
                    },

                    toQueryString: function (params) {
                        var r = [];
                        for (var n in params) {
                            var v = params[n];
                            n = encodeURIComponent(n);
                            r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
                        }
                        return r.join('&');
                    },

                    isBodyMethod: function (method) {
                        return this.bodyMethods[(method || '').toUpperCase()];
                    },

                    bodyMethods: {
                        POST: 1,
                        PUT: 1,
                        DELETE: 1
                    },

                    makeReadyStateHandler: function (xhr, callback) {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == 4) {
                                callback && callback.call(null, xhr.response, xhr);
                            }
                        };
                    },

                    setRequestHeaders: function (xhr, headers) {
                        if (headers) {
                            for (var name in headers) {
                                xhr.setRequestHeader(name, headers[name]);
                            }
                        }
                    }

                });
            </script>

        </polymer-element>
        <polymer-element name="core-ajax" hidden="" attributes="url handleAs auto params response error method headers body contentType withCredentials" assetpath="bower_components/core-ajax/">
            <script>
                Polymer('core-ajax', {
                    /**
                     * Fired when a response is received.
                     *
                     * @event core-response
                     */

                    /**
                     * Fired when an error is received.
                     *
                     * @event core-error
                     */

                    /**
                     * Fired whenever a response or an error is received.
                     *
                     * @event core-complete
                     */

                    /**
                     * The URL target of the request.
                     *
                     * @attribute url
                     * @type string
                     * @default ''
                     */
                    url: '',

                    /**
                     * Specifies what data to store in the `response` property, and
                     * to deliver as `event.response` in `response` events.
                     *
                     * One of:
                     *
                     *    `text`: uses `XHR.responseText`.
                     *
                     *    `xml`: uses `XHR.responseXML`.
                     *
                     *    `json`: uses `XHR.responseText` parsed as JSON.
                     *
                     *    `arraybuffer`: uses `XHR.response`.
                     *
                     *    `blob`: uses `XHR.response`.
                     *
                     *    `document`: uses `XHR.response`.
                     *
                     * @attribute handleAs
                     * @type string
                     * @default 'text'
                     */
                    handleAs: '',

                    /**
                     * If true, automatically performs an Ajax request when either `url` or `params` changes.
                     *
                     * @attribute auto
                     * @type boolean
                     * @default false
                     */
                    auto: false,

                    /**
                     * Parameters to send to the specified URL, as JSON.
                     *
                     * @attribute params
                     * @type string (JSON)
                     * @default ''
                     */
                    params: '',

                    /**
                     * The response for the most recently made request, or null if it hasn't
                     * completed yet or the request resulted in error.
                     *
                     * @attribute response
                     * @type Object
                     * @default null
                     */
                    response: null,

                    /**
                     * The error for the most recently made request, or null if it hasn't
                     * completed yet or the request resulted in success.
                     *
                     * @attribute error
                     * @type Object
                     * @default null
                     */
                    error: null,

                    /**
                     * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
                     * Default is 'GET'.
                     *
                     * @attribute method
                     * @type string
                     * @default ''
                     */
                    method: '',

                    /**
                     * HTTP request headers to send.
                     *
                     * Example:
                     *
                     *     <core-ajax
                     *         auto
                     *         url="http://somesite.com"
                     *         headers='{"X-Requested-With": "XMLHttpRequest"}'
                     *         handleAs="json"
                     *         on-core-response="{{handleResponse}}"></core-ajax>
                     *
                     * @attribute headers
                     * @type Object
                     * @default null
                     */
                    headers: null,

                    /**
                     * Optional raw body content to send when method === "POST".
                     *
                     * Example:
                     *
                     *     <core-ajax method="POST" auto url="http://somesite.com"
                     *         body='{"foo":1, "bar":2}'>
                     *     </core-ajax>
                     *
                     * @attribute body
                     * @type Object
                     * @default null
                     */
                    body: null,

                    /**
                     * Content type to use when sending data.
                     *
                     * @attribute contentType
                     * @type string
                     * @default 'application/x-www-form-urlencoded'
                     */
                    contentType: 'application/x-www-form-urlencoded',

                    /**
                     * Set the withCredentials flag on the request.
                     *
                     * @attribute withCredentials
                     * @type boolean
                     * @default false
                     */
                    withCredentials: false,

                    /**
                     * Additional properties to send to core-xhr.
                     *
                     * Can be set to an object containing default properties
                     * to send as arguments to the `core-xhr.request()` method
                     * which implements the low-level communication.
                     *
                     * @property xhrArgs
                     * @type Object
                     * @default null
                     */
                    xhrArgs: null,

                    ready: function () {
                        this.xhr = document.createElement('core-xhr');
                    },

                    receive: function (response, xhr) {
                        if (this.isSuccess(xhr)) {
                            this.processResponse(xhr);
                        } else {
                            this.processError(xhr);
                        }
                        this.complete(xhr);
                    },

                    isSuccess: function (xhr) {
                        var status = xhr.status || 0;
                        return !status || (status >= 200 && status < 300);
                    },

                    processResponse: function (xhr) {
                        var response = this.evalResponse(xhr);
                        if (xhr === this.activeRequest) {
                            this.response = response;
                        }
                        this.fire('core-response', {
                            response: response,
                            xhr: xhr
                        });
                    },

                    processError: function (xhr) {
                        var response = xhr.status + ': ' + xhr.responseText;
                        if (xhr === this.activeRequest) {
                            this.error = response;
                        }
                        this.fire('core-error', {
                            response: response,
                            xhr: xhr
                        });
                    },

                    complete: function (xhr) {
                        this.fire('core-complete', {
                            response: xhr.status,
                            xhr: xhr
                        });
                    },

                    evalResponse: function (xhr) {
                        return this[(this.handleAs || 'text') + 'Handler'](xhr);
                    },

                    xmlHandler: function (xhr) {
                        return xhr.responseXML;
                    },

                    textHandler: function (xhr) {
                        return xhr.responseText;
                    },

                    jsonHandler: function (xhr) {
                        var r = xhr.responseText;
                        try {
                            return JSON.parse(r);
                        } catch (x) {
                            console.warn('core-ajax caught an exception trying to parse response as JSON:');
                            console.warn('url:', this.url);
                            console.warn(x);
                            return r;
                        }
                    },

                    documentHandler: function (xhr) {
                        return xhr.response;
                    },

                    blobHandler: function (xhr) {
                        return xhr.response;
                    },

                    arraybufferHandler: function (xhr) {
                        return xhr.response;
                    },

                    urlChanged: function () {
                        if (!this.handleAs) {
                            var ext = String(this.url).split('.').pop();
                            switch (ext) {
                            case 'json':
                                this.handleAs = 'json';
                                break;
                            }
                        }
                        this.autoGo();
                    },

                    paramsChanged: function () {
                        this.autoGo();
                    },

                    autoChanged: function () {
                        this.autoGo();
                    },

                    // TODO(sorvell): multiple side-effects could call autoGo
                    // during one micro-task, use a job to have only one action
                    // occur
                    autoGo: function () {
                        if (this.auto) {
                            this.goJob = this.job(this.goJob, this.go, 0);
                        }
                    },

                    /**
                     * Performs an Ajax request to the specified URL.
                     *
                     * @method go
                     */
                    go: function () {
                        var args = this.xhrArgs || {};
                        // TODO(sjmiles): we may want XHR to default to POST if body is set
                        args.body = this.body || args.body;
                        args.params = this.params || args.params;
                        if (args.params && typeof (args.params) == 'string') {
                            args.params = JSON.parse(args.params);
                        }
                        args.headers = this.headers || args.headers || {};
                        if (args.headers && typeof (args.headers) == 'string') {
                            args.headers = JSON.parse(args.headers);
                        }
                        var hasContentType = Object.keys(args.headers).some(function (header) {
                            return header.toLowerCase() === 'content-type';
                        });
                        if (!hasContentType && this.contentType) {
                            args.headers['Content-Type'] = this.contentType;
                        }
                        if (this.handleAs === 'arraybuffer' || this.handleAs === 'blob' ||
                            this.handleAs === 'document') {
                            args.responseType = this.handleAs;
                        }
                        args.withCredentials = this.withCredentials;
                        args.callback = this.receive.bind(this);
                        args.url = this.url;
                        args.method = this.method;

                        this.response = this.error = null;
                        this.activeRequest = args.url && this.xhr.request(args);
                        return this.activeRequest;
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-transition-pages" extends="core-transition" assetpath="bower_components/core-animated-pages/transitions/">
            <script>
                (function () {

                    // create some basic transition styling data.
                    var transitions = CoreStyle.g.transitions = CoreStyle.g.transitions || {};
                    transitions.duration = '500ms';
                    transitions.heroDelay = '50ms';
                    transitions.scaleDelay = '500ms';
                    transitions.cascadeFadeDuration = '250ms';

                    Polymer('core-transition-pages', {

                        publish: {
                            /**
                             * This class will be applied to the scope element in the `prepare` function.
                             * It is removed in the `complete` function. Used to activate a set of CSS
                             * rules that need to apply before the transition runs, e.g. a default opacity
                             * or transform for the non-active pages.
                             *
                             * @attribute scopeClass
                             * @type string
                             * @default ''
                             */
                            scopeClass: '',

                            /**
                             * This class will be applied to the scope element in the `go` function. It is
                             * remoived in the `complete' function. Generally used to apply a CSS transition
                             * rule only during the transition.
                             *
                             * @attribute activeClass
                             * @type string
                             * @default ''
                             */
                            activeClass: '',

                            /**
                             * Specifies which CSS property to look for when it receives a `transitionEnd` event
                             * to determine whether the transition is complete. If not specified, the first
                             * transitionEnd event received will complete the transition.
                             *
                             * @attribute transitionProperty
                             * @type string
                             * @default ''
                             */
                            transitionProperty: ''
                        },

                        /**
                         * True if this transition is complete.
                         *
                         * @attribute completed
                         * @type boolean
                         * @default false
                         */
                        completed: false,

                        prepare: function (scope, options) {
                            this.boundCompleteFn = this.complete.bind(this, scope);
                            if (this.scopeClass) {
                                scope.classList.add(this.scopeClass);
                            }
                        },

                        go: function (scope, options) {
                            this.completed = false;
                            if (this.activeClass) {
                                scope.classList.add(this.activeClass);
                            }
                            scope.addEventListener('transitionend', this.boundCompleteFn, false);
                        },

                        setup: function (scope) {
                            if (!scope._pageTransitionStyles) {
                                scope._pageTransitionStyles = {};
                            }

                            var name = this.calcStyleName();

                            if (!scope._pageTransitionStyles[name]) {
                                this.installStyleInScope(scope, name);
                                scope._pageTransitionStyles[name] = true;
                            }
                        },

                        calcStyleName: function () {
                            return this.id || this.localName;
                        },

                        installStyleInScope: function (scope, id) {
                            if (!scope.shadowRoot) {
                                scope.createShadowRoot().innerHTML = '<content></content>';
                            }
                            var root = scope.shadowRoot;
                            var scopeStyle = document.createElement('core-style');
                            root.insertBefore(scopeStyle, root.firstChild);
                            scopeStyle.applyRef(id);
                        },

                        complete: function (scope, e) {
                            // TODO(yvonne): hack, need to manage completion better
                            if (e.propertyName !== 'box-shadow' && (!this.transitionProperty || e.propertyName.indexOf(this.transitionProperty) !== -1)) {
                                this.completed = true;
                                this.fire('core-transitionend', this, scope);
                            }
                        },

                        // TODO(sorvell): ideally we do this in complete.
                        ensureComplete: function (scope) {
                            scope.removeEventListener('transitionend', this.boundCompleteFn, false);
                            if (this.scopeClass) {
                                scope.classList.remove(this.scopeClass);
                            }
                            if (this.activeClass) {
                                scope.classList.remove(this.activeClass);
                            }
                        }

                    });

                })();
            </script>
        </polymer-element>
        <core-style id="hero-transition">
            /* Hide heroes that are not currently transitioning */ polyfill-next-selector { content: ':host &gt; [animate]:not(.core-selected) [hero]'; } ::content &gt; [animate]:not(.core-selected) /deep/ [hero] { opacity: 0; } polyfill-next-selector { content: ':host &gt; .core-selected[animate] [hero]'; } ::content &gt; .core-selected[animate] /deep/ [hero] { opacity: 1; z-index: 10000; } polyfill-next-selector { content: ':host &gt; * [hero-p]'; } ::content &gt; * /deep/ [hero-p] { -webkit-transition: box-shadow 100ms ease-out; transition: box-shadow 100ms ease-out; } polyfill-next-selector { content: ':host &gt; [animate] [hero-p]'; } ::content &gt; [animate] /deep/ [hero-p] { box-shadow: none !important; }
        </core-style>


        <!--

`hero-transition` transforms two elements in different pages such that they appear
to be shared across the pages.

Example:

    <core-animated-pages transition="hero-transition">
      <section layout horizontal>
        <div id="div1" flex></div>
        <div id="div2" flex hero-id="shared" hero></div>
      </section>
      <section>
      <section layout horizontal>
        <div id="div3" flex hero-id="shared" hero></div>
        <div id="div4" flex></div>
      </section>
      </section>
    </core-animated-pages>

In the above example, the elements `#div2` and `#div3` shares the same `hero-id`
attribute and a single element appears to translate and scale smoothly between
the two positions during a page transition.

Both elements from the source and destination pages must share the same `hero-id`
and must both contain the `hero` attribute to trigger the transition. The separate
`hero` attribute allows you to use binding to configure the transition:

Example:

    <core-animated-pages transition="hero-transition">
      <section layout horizontal>
        <div id="div1" flex hero-id="shared" hero?="{{selected == 0}}"></div>
        <div id="div2" flex hero-id="shared" hero?="{{selected == 1}}"></div>
      </section>
      <section>
      <section layout horizontal>
        <div id="div3" flex hero-id="shared" hero></div>
      </section>
      </section>
    </core-animated-pages>

In the above example, either `#div1` or `#div2` scales to `#div3` during a page transition,
depending on the value of `selected`.

Because it is common to share elements with different `border-radius` values, by default
this transition will also animate the `border-radius` property.

You can configure the duration of the hero transition with the global variable
`CoreStyle.g.transitions.heroDuration`.

@class hero-transition
@extends core-transition-pages
@status beta
@homepage github.io
-->
        <polymer-element name="hero-transition" extends="core-transition-pages" assetpath="bower_components/core-animated-pages/transitions/">
            <script>
                (function () {

                    var webkitStyles = '-webkit-transition' in document.documentElement.style
                    var TRANSITION_CSSNAME = webkitStyles ? '-webkit-transition' : 'transition';
                    var TRANSFORM_CSSNAME = webkitStyles ? '-webkit-transform' : 'transform';
                    var TRANSITION_NAME = webkitStyles ? 'webkitTransition' : 'transition';
                    var TRANSFORM_NAME = webkitStyles ? 'webkitTransform' : 'transform';

                    var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

                    Polymer('hero-transition', {

                        go: function (scope, options) {
                            var props = [
        'border-radius',
        'width',
        'height',
        TRANSFORM_CSSNAME
      ];

                            var duration = options && options.duration ||
                                (CoreStyle.g.transitions.heroDuration ||
                                    CoreStyle.g.transitions.duration);

                            scope._heroes.forEach(function (h) {
                                var d = h.h0.hasAttribute('hero-delayed') ? CoreStyle.g.transitions.heroDelay : '';
                                var wt = [];
                                props.forEach(function (p) {
                                    wt.push(p + ' ' + duration + ' ' + options.easing + ' ' + d);
                                });

                                h.h1.style[TRANSITION_NAME] = wt.join(', ');
                                h.h1.style.borderRadius = h.r1;
                                h.h1.style[TRANSFORM_NAME] = '';
                            });

                            this.super(arguments);

                            if (!scope._heroes.length) {
                                this.completed = true;
                            }
                        },

                        prepare: function (scope, options) {
                            this.super(arguments);
                            var src = options.src,
                                dst = options.dst;

                            if (scope._heroes && scope._heroes.length) {
                                this.ensureComplete(scope);
                            } else {
                                scope._heroes = [];
                            }

                            // FIXME(yvonne): basic support for nested pages.
                            // Look for heroes in the light DOM and one level of shadow DOM of the src and dst,
                            // and also in src.selectedItem or dst.selectedItem, then transform the dst hero to src
                            var ss = '[hero]';
                            var h$ = this.findAllInShadows(src, ss);
                            if (src.selectedItem) {
                                hs$ = this.findAllInShadows(src.selectedItem, ss);
                                hsa$ = [];
                                // De-duplicate items
                                Array.prototype.forEach.call(hs$, function (hs) {
                                    if (h$.indexOf(hs) === -1) {
                                        hsa$.push(hs);
                                    }
                                })
                                h$ = h$.concat(hsa$);
                            }

                            for (var i = 0, h0; h0 = h$[i]; i++) {
                                var v = h0.getAttribute('hero-id');
                                var ds = '[hero][hero-id="' + v + '"]';
                                var h1 = this.findInShadows(dst, ds);

                                if (!h1 && dst.selectedItem) {
                                    h1 = this.findInShadows(dst.selectedItem, ds);
                                }

                                // console.log('src', src);
                                // console.log('dst', dst, dst.selectedItem);
                                // console.log(v, h0, h1);
                                if (v && h1) {
                                    var c0 = getComputedStyle(h0);
                                    var c1 = getComputedStyle(h1);
                                    var h = {
                                        h0: h0,
                                        b0: h0.getBoundingClientRect(),
                                        r0: c0.borderRadius,
                                        h1: h1,
                                        b1: h1.getBoundingClientRect(),
                                        r1: c1.borderRadius
                                    };

                                    var dl = h.b0.left - h.b1.left;
                                    var dt = h.b0.top - h.b1.top;
                                    var sw = h.b0.width / h.b1.width;
                                    var sh = h.b0.height / h.b1.height;

                                    // h.scaley = h.h0.hasAttribute('scaley');
                                    // if (!h.scaley && (sw !== 1 || sh !== 1)) {
                                    //   sw = sh = 1;
                                    //   h.h1.style.width = h.b0.width + 'px';
                                    //   h.h1.style.height = h.b0.height + 'px';
                                    // }

                                    // Also animate the border-radius for the circle-to-square transition
                                    if (h.r0 !== h.r1) {
                                        h.h1.style.borderRadius = h.r0;
                                    }

                                    // console.log(h);

                                    h.h1.style[TRANSFORM_NAME] = 'translate(' + dl + 'px,' + dt + 'px)' + ' scale(' + sw + ',' + sh + ')';
                                    h.h1.style[TRANSFORM_NAME + 'Origin'] = '0 0';

                                    scope._heroes.push(h);
                                }
                            }

                        },

                        // carefully look into ::shadow with polyfill specific hack
                        findInShadows: function (node, selector) {
                            return node.querySelector(selector) || (hasShadowDOMPolyfill ?
                                Platform.queryAllShadows(node, selector) :
                                node.querySelector('::shadow ' + selector));
                        },

                        findAllInShadows: function (node, selector) {
                            if (hasShadowDOMPolyfill) {
                                var nodes = node.querySelectorAll(selector).array();
                                var shadowNodes = Platform.queryAllShadows(node, selector, true);
                                return nodes.concat(shadowNodes);
                            } else {
                                return node.querySelectorAll(selector).array().concat(node.shadowRoot ? node.shadowRoot.querySelectorAll(selector).array() : []);
                            }
                        },

                        ensureComplete: function (scope) {
                            this.super(arguments);
                            if (scope._heroes) {
                                scope._heroes.forEach(function (h) {
                                    h.h1.style[TRANSITION_NAME] = '';
                                    h.h1.style[TRANSFORM_NAME] = '';
                                });
                                scope._heroes = [];
                            }
                        },

                        complete: function (scope, e) {
                            // if (e.propertyName === TRANSFORM_CSSNAME) {
                            var done = false;
                            scope._heroes.forEach(function (h) {
                                if (h.h1 === e.path[0]) {
                                    done = true;
                                }
                            });

                            if (done) {
                                this.super(arguments);
                            }
                            // }
                        }

                    });

                })();
            </script>
        </polymer-element>

        <hero-transition id="hero-transition"></hero-transition>

        <core-style id="cross-fade">
            polyfill-next-selector { content: ':host &gt; * [cross-fade]'; } ::content &gt; * /deep/ [cross-fade] { -webkit-transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); } polyfill-next-selector { content: ':host &gt; * [cross-fade][bg]'; } ::content &gt; * /deep/ [cross-fade][bg] { -webkit-transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); } polyfill-next-selector { content: ':host &gt; * [cross-fade][hero-p]'; } ::content &gt; * /deep/ [cross-fade][hero-p] { -webkit-transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} cubic-bezier(0.4, 0, 0.2, 1); } polyfill-next-selector { content: ':host &gt; .core-selected [cross-fade]'; } ::content &gt; .core-selected /deep/ [cross-fade] { opacity: 1; } polyfill-next-selector { content: ':host &gt; [animate]:not(.core-selected) [cross-fade]:not([hero-p]):not([bg])'; } ::content &gt; [animate]:not(.core-selected) /deep/ [cross-fade]:not([hero-p]):not([bg]) { opacity: 0; } polyfill-next-selector { content: ':host &gt; [animate]:not(.core-selected) [cross-fade][bg]'; } ::content &gt; [animate]:not(.core-selected) /deep/ [cross-fade][bg] { background-color: rgba(0, 0, 0, 0); } polyfill-next-selector { content: ':host &gt; [animate]:not(.core-selected) [cross-fade][hero-p]'; } ::content &gt; [animate]:not(.core-selected) /deep/ [cross-fade][hero-p] { background-color: rgba(0, 0, 0, 0); }
        </core-style>

        <core-style id="cross-fade-delayed">
            polyfill-next-selector { content: ':host &gt; * [cross-fade-delayed]'; } ::content &gt; * /deep/ [cross-fade-delayed] { -webkit-transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; } polyfill-next-selector { content: ':host &gt; .core-selected [cross-fade-delayed]'; } ::content &gt; .core-selected /deep/ [cross-fade-delayed] { -webkit-transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out {{g.transitions.xfadeDelay || g.transitions.xfadeDuration || g.transitions.duration}}; transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out {{g.transitions.xfadeDelay || g.transitions.xfadeDuration || g.transitions.duration}}; } polyfill-next-selector { content: ':host &gt; [animate]:not(.core-selected) [cross-fade-delayed]'; } ::content &gt; [animate]:not(.core-selected) /deep/ [cross-fade-delayed] { opacity: 0; } polyfill-next-selector { content: ':host &gt; .core-selected [cross-fade-delayed]'; } ::content &gt; .core-selected /deep/ [cross-fade-delayed] { opacity: 1; }

        </core-style>

        <core-style id="cross-fade-all">
            /* cross-fade-all: cross fade everything except for heroes and their parents */ polyfill-next-selector { content: ':host(.cross-fade-all) &gt; * *:not([hero]):not([hero-p]):not([cross-fade])'; } :host(.cross-fade-all) ::content &gt; * /deep/ *:not([hero]):not([hero-p]):not([cross-fade]) { -webkit-transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; transition: opacity {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; } polyfill-next-selector { content: ':host(.cross-fade-all) &gt; [animate]:not(.core-selected) *:not([hero]):not([hero-p]):not([cross-fade])'; } :host(.cross-fade-all) ::content &gt; [animate]:not(.core-selected) /deep/ *:not([hero]):not([hero-p]):not([cross-fade]) { opacity: 0; } polyfill-next-selector { content: ':host(.cross-fade-all) &gt; .core-selected *:not([hero])'; } .host(.cross-fade-all) ::content &gt; .core-selected /deep/ * { opacity: 1; } /* Only background-color is allowed for the hero's parents, no opacity transitions */ polyfill-next-selector { content: ':host(.cross-fade-all) &gt; * [hero-p]'; } :host(.cross-fade-all) ::content &gt; * /deep/ [hero-p] { -webkit-transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; transition: background-color {{g.transitions.xfadeDuration || g.transitions.duration}} ease-out; opacity: 1; } polyfill-next-selector { content: ':host(.cross-fade-all) &gt; [animate]:not(.core-selected) [hero-p]'; } :host(.cross-fade-all) ::content &gt; [animate]:not(.core-selected) /deep/ [hero-p] { background-color: rgba(0, 0, 0, 0); }
        </core-style>

        <!--

`cross-fade` fades out elements in the outgoing page and fades in elements in the
incoming page during a page transition. You can configure the duration of the
transition with the global variable `CoreStyle.g.transitions.xfadeDuration`.

Example:

    <core-animated-pages transition="cross-fade">
      <section>
        <div id="div1" cross-fade></div>
      </section>
      <section>
        <div id="div2" cross-fade bg>
          <div id="div3" cross-fade></div>
          <div id="div4"></div>
        </div>
      </section>
    </core-animated-pages>

In the above example, `#div1` and `#div3` has the `cross-fade` attribute. `#div1`
will fade out and `#div3` will fade in with opacity transitions when the page switches
from 0 to 1. Sometimes, you may want to only fade the background color of an element
but not its children, and you can use the `bg` attribute along with the `#div1`
attribute as in `#div2`.

@class cross-fade
@extends core-transition-pages
@status beta
@homepage github.io

-->

        <!--

`cross-fade-delayed` performs a cross-fade after some delay, either specified in
the global variable `CoreStyle.g.transitions.xfadeDelay` or the duration of the
transition.

Example:

    <core-animated-pages transition="hero-transition cross-fade-delayed">
      <section>
        <div id="div1" hero-id hero></div>
      </section>
      <section>
        <div id="div2" hero-id hero>
          <div id="div3" cross-fade-delayed></div>
        </div>
      </section>
    </core-animated-pages>

In the above example, `#div3` fades in after the hero transition from `#div1` to
`#div2` completes.

@class cross-fade-delayed
@extends core-transition-pages
@status beta
@homepage github.io

-->

        <core-transition-pages id="cross-fade"></core-transition-pages>
        <core-transition-pages id="cross-fade-delayed"></core-transition-pages>
        <core-transition-pages id="cross-fade-all" scopeclass="cross-fade-all"></core-transition-pages>
        <polymer-element name="core-animated-pages" extends="core-selector" notap="" attributes="transitions" assetpath="bower_components/core-animated-pages/">

            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: block;
                        position: relative;
                    }
                    polyfill-next-selector {
                        content: ':host > *';
                    }
                    ::content > * {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                    }
                    polyfill-next-selector {
                        content: ':host > *:not(.core-selected):not([animate])';
                    }
                    ::content > *:not(.core-selected):not([animate]) {
                        display: none !important;
                    }
                </style>

                <shadow></shadow>

            </template>

            <script>
                Polymer('core-animated-pages', {

                    eventDelegates: {
                        'core-transitionend': 'transitionEnd'
                    },

                    /**
                     * A space-delimited string of transitions to use when switching between pages in this element.
                     * The strings are `id`s of `core-transition-pages` elements included elsewhere. See the
                     * individual transition's document for specific details.
                     *
                     * @attribute transitions
                     * @type string
                     * @default ''
                     */
                    transitions: '',

                    selected: 0,

                    /**
                     * The last page selected. This property is useful to dynamically set transitions based
                     * on incoming and outgoing pages.
                     *
                     * @attribute lastSelected
                     * @type Object
                     * @default null
                     */
                    lastSelected: null,

                    registerCallback: function () {
                        this.tmeta = document.createElement('core-transition');
                    },

                    created: function () {
                        this._transitions = [];
                        this.transitioning = [];
                    },

                    transitionsChanged: function () {
                        this._transitions = this.transitions.split(' ');
                    },

                    _transitionsChanged: function (old) {
                        if (this._transitionElements) {
                            this._transitionElements.forEach(function (t) {
                                t.teardown(this);
                            }, this);
                        }
                        this._transitionElements = [];
                        this._transitions.forEach(function (transitionId) {
                            var t = this.getTransition(transitionId);
                            if (t) {
                                this._transitionElements.push(t);
                                t.setup(this);
                            }
                        }, this);
                    },

                    getTransition: function (transitionId) {
                        return this.tmeta.byId(transitionId);
                    },

                    selectionSelect: function (e, detail) {
                        this.updateSelectedItem();
                        // Wait to call applySelection when we run the transition
                    },

                    applyTransition: function (src, dst) {
                        if (this.animating) {
                            this.cancelAsync(this.animating);
                            this.animating = null;
                        }

                        Platform.flush();

                        if (this.transitioning.indexOf(src) === -1) {
                            this.transitioning.push(src);
                        }
                        if (this.transitioning.indexOf(dst) === -1) {
                            this.transitioning.push(dst);
                        }
                        // force src, dst to display
                        src.setAttribute('animate', '');
                        dst.setAttribute('animate', '');
                        //
                        var options = {
                            src: src,
                            dst: dst,
                            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                        }

                        // fire an event so clients have a chance to do something when the
                        // new page becomes visible but before it draws.
                        this.fire('core-animated-pages-transition-prepare');

                        //
                        // prepare transition
                        this._transitionElements.forEach(function (transition) {
                            transition.prepare(this, options);
                        }, this);
                        //
                        // force layout!
                        src.offsetTop;

                        //
                        // apply selection
                        this.applySelection(dst, true);
                        this.applySelection(src, false);
                        //
                        // start transition
                        this._transitionElements.forEach(function (transition) {
                            transition.go(this, options);
                        }, this);

                        if (!this._transitionElements.length) {
                            this.complete();
                        } else {
                            this.animating = this.async(this.complete.bind(this), null, 5000);
                        }
                    },

                    complete: function () {
                        if (this.animating) {
                            this.cancelAsync(this.animating);
                            this.animating = null;
                        }

                        this.transitioning.forEach(function (t) {
                            t.removeAttribute('animate');
                        });
                        this.transitioning = [];

                        this._transitionElements.forEach(function (transition) {
                            transition.ensureComplete(this);
                        }, this);

                        this.fire('core-animated-pages-transition-end');
                    },

                    transitionEnd: function (e) {
                        if (this.transitioning.length) {
                            var completed = true;
                            this._transitionElements.forEach(function (transition) {
                                if (!transition.completed) {
                                    completed = false;
                                }
                            });
                            if (completed) {
                                this.job('transitionWatch', function () {
                                    this.complete();
                                }, 100);
                            }
                        }
                    },

                    selectedChanged: function (old) {
                        this.lastSelected = old;
                        this.super(arguments);
                    },

                    selectedItemChanged: function (oldItem) {
                        this.super(arguments);

                        if (!oldItem) {
                            this.applySelection(this.selectedItem, true);
                            return;
                        }

                        if (this.hasAttribute('no-transition') || !this._transitionElements || !this._transitionElements.length) {
                            this.applySelection(oldItem, false);
                            this.applySelection(this.selectedItem, true);
                            return;
                        }

                        if (oldItem && this.selectedItem) {
                            // TODO(sorvell): allow bindings to update first?
                            var self = this;
                            Platform.flush();
                            Platform.endOfMicrotask(function () {
                                self.applyTransition(oldItem, self.selectedItem);
                            });
                        }
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-collapse" attributes="target horizontal opened duration fixedSize" assetpath="bower_components/core-collapse/">
            <template>

                <content></content>

            </template>
            <script>
                Polymer('core-collapse', {

                    /**
                     * Fired when the `core-collapse`'s `opened` property changes.
                     *
                     * @event core-collapse-open
                     */

                    /**
                     * Fired when the target element has been resized as a result of the opened
                     * state changing.
                     *
                     * @event core-resize
                     */

                    /**
                     * The target element.
                     *
                     * @attribute target
                     * @type object
                     * @default null
                     */
                    target: null,

                    /**
                     * If true, the orientation is horizontal; otherwise is vertical.
                     *
                     * @attribute horizontal
                     * @type boolean
                     * @default false
                     */
                    horizontal: false,

                    /**
                     * Set opened to true to show the collapse element and to false to hide it.
                     *
                     * @attribute opened
                     * @type boolean
                     * @default false
                     */
                    opened: false,

                    /**
                     * Collapsing/expanding animation duration in second.
                     *
                     * @attribute duration
                     * @type number
                     * @default 0.33
                     */
                    duration: 0.33,

                    /**
                     * If true, the size of the target element is fixed and is set
                     * on the element.  Otherwise it will try to
                     * use auto to determine the natural size to use
                     * for collapsing/expanding.
                     *
                     * @attribute fixedSize
                     * @type boolean
                     * @default false
                     */
                    fixedSize: false,

                    created: function () {
                        this.transitionEndListener = this.transitionEnd.bind(this);
                    },

                    ready: function () {
                        this.target = this.target || this;
                    },

                    domReady: function () {
                        this.async(function () {
                            this.afterInitialUpdate = true;
                        });
                    },

                    detached: function () {
                        if (this.target) {
                            this.removeListeners(this.target);
                        }
                    },

                    targetChanged: function (old) {
                        if (old) {
                            this.removeListeners(old);
                        }
                        if (!this.target) {
                            return;
                        }
                        this.isTargetReady = !!this.target;
                        this.classList.toggle('core-collapse-closed', this.target !== this);
                        this.target.style.overflow = 'hidden';
                        this.horizontalChanged();
                        this.addListeners(this.target);
                        // set core-collapse-closed class initially to hide the target
                        this.toggleClosedClass(true);
                        this.update();
                    },

                    addListeners: function (node) {
                        node.addEventListener('transitionend', this.transitionEndListener);
                    },

                    removeListeners: function (node) {
                        node.removeEventListener('transitionend', this.transitionEndListener);
                    },

                    horizontalChanged: function () {
                        this.dimension = this.horizontal ? 'width' : 'height';
                    },

                    openedChanged: function () {
                        this.update();
                        this.fire('core-collapse-open', this.opened);
                    },

                    /**
                     * Toggle the opened state.
                     *
                     * @method toggle
                     */
                    toggle: function () {
                        this.opened = !this.opened;
                    },

                    setTransitionDuration: function (duration) {
                        var s = this.target.style;
                        s.transition = duration ? (this.dimension + ' ' + duration + 's') : null;
                        if (duration === 0) {
                            this.async('transitionEnd');
                        }
                    },

                    transitionEnd: function () {
                        if (this.opened && !this.fixedSize) {
                            this.updateSize('auto', null);
                        }
                        this.setTransitionDuration(null);
                        this.toggleClosedClass(!this.opened);
                        this.asyncFire('core-resize', null, this.target);
                    },

                    toggleClosedClass: function (closed) {
                        this.hasClosedClass = closed;
                        this.target.classList.toggle('core-collapse-closed', closed);
                    },

                    updateSize: function (size, duration, forceEnd) {
                        this.setTransitionDuration(duration);
                        this.calcSize();
                        var s = this.target.style;
                        var nochange = s[this.dimension] === size;
                        s[this.dimension] = size;
                        // transitonEnd will not be called if the size has not changed
                        if (forceEnd && nochange) {
                            this.transitionEnd();
                        }
                    },

                    update: function () {
                        if (!this.target) {
                            return;
                        }
                        if (!this.isTargetReady) {
                            this.targetChanged();
                        }
                        this.horizontalChanged();
                        this[this.opened ? 'show' : 'hide']();
                    },

                    calcSize: function () {
                        return this.target.getBoundingClientRect()[this.dimension] + 'px';
                    },

                    getComputedSize: function () {
                        return getComputedStyle(this.target)[this.dimension];
                    },

                    show: function () {
                        this.toggleClosedClass(false);
                        // for initial update, skip the expanding animation to optimize
                        // performance e.g. skip calcSize
                        if (!this.afterInitialUpdate) {
                            this.transitionEnd();
                            return;
                        }
                        if (!this.fixedSize) {
                            this.updateSize('auto', null);
                            var s = this.calcSize();
                            if (s == '0px') {
                                this.transitionEnd();
                                return;
                            }
                            this.updateSize(0, null);
                        }
                        this.async(function () {
                            this.updateSize(this.size || s, this.duration, true);
                        });
                    },

                    hide: function () {
                        // don't need to do anything if it's already hidden
                        if (this.hasClosedClass && !this.fixedSize) {
                            return;
                        }
                        if (this.fixedSize) {
                            // save the size before hiding it
                            this.size = this.getComputedSize();
                        } else {
                            this.updateSize(this.calcSize(), null);
                        }
                        this.async(function () {
                            this.updateSize(0, this.duration);
                        });
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-icon-button" attributes="src icon active" assetpath="bower_components/core-icon-button/">

            <template>
                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
*/
                    :host {
                        display: inline-block;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                        user-select: none;
                        -moz-user-select: none;
                        -webkit-user-select: none;
                        border-radius: 2px;
                        padding: 7px;
                        margin: 2px;
                        vertical-align: middle;
                        font-size: 1rem;
                        cursor: pointer;
                    }
                    :host([disabled]) {
                        opacity: 0.6;
                        pointer-events: none;
                    }
                    :host(.outline) {
                        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
                    }
                    :host(:hover:not([disabled])) {
                        box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.1);
                    }
                    :host(.selected:not([disabled])) {
                        background-color: rgba(0, 0, 0, 0.05);
                        box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.12);
                    }
                    :host(:active:not([disabled]),
                    .selected:active:not([disabled])) {
                        background-color: rgba(0, 0, 0, 0.05);
                        box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.12);
                    }
                    :host(.core-dark-theme.outline) {
                        background-color: rgba(200, 200, 200, 0.05);
                        box-shadow: 0 0 0 1px rgba(200, 200, 200, 0.1);
                    }
                    :host(.core-dark-theme:hover) {
                        background-color: rgba(200, 200, 200, 0.05);
                        box-shadow: 0 1px 0 0 rgba(200, 200, 200, 0.12), 0 0 0 1px rgba(200, 200, 200, 0.1);
                    }
                    :host(.core-dark-theme.selected) {
                        background-color: rgba(220, 220, 220, 0.05);
                        box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.05), 0 0 0 1px rgba(200, 200, 200, 0.12);
                    }
                    :host(.core-dark-theme:active,
                    .core-dark-theme.selected:active) {
                        background-color: rgba(200, 200, 200, 0.05);
                        box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.1), 0 0 0 1px rgba(200, 200, 200, 0.12);
                    }
                    core-icon {
                        pointer-events: none;
                    }
                    /* note: this is a polyfill aware selector */
                    :host::content >:not(core-icon) {
                        margin-left: 4px;
                    }
                </style>
                <core-icon src="{{src}}" icon="{{icon}}"></core-icon>
                <content></content>
            </template>

            <script>
                Polymer('core-icon-button', {

                    /**
                     * The URL of an image for the icon.  Should not use `icon` property
                     * if you are using this property.
                     *
                     * @attribute src
                     * @type string
                     * @default ''
                     */
                    src: '',

                    /**
                     * If true, border is placed around the button to indicate it's
                     * active state.
                     *
                     * @attribute active
                     * @type boolean
                     * @default false
                     */
                    active: false,

                    /**
                     * Specifies the icon name or index in the set of icons available in
                     * the icon set.  Should not use `src` property if you are using this
                     * property.
                     *
                     * @attribute icon
                     * @type string
                     * @default ''
                     */
                    icon: '',

                    activeChanged: function () {
                        this.classList.toggle('selected', this.active);
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-toolbar" assetpath="bower_components/core-toolbar/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        /* technical */
                        display: block;
                        position: relative;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                        /* size */
                        height: 64px;
                        /* typography */
                        font-size: 1.3em;
                        /* background */
                        background-color: #CFD8DC;
                    }
                    :host(.animate) {
                        /* transition */
                        transition: height 0.18s ease-in;
                    }
                    :host(.medium-tall) {
                        height: 128px;
                    }
                    :host(.tall) {
                        height: 192px;
                    }
                    .toolbar-tools {
                        position: relative;
                        height: 64px;
                        padding: 0 8px;
                        pointer-events: none;
                    }
                    /* narrow layout */
                    :host(.core-narrow),
                    :host-context(.core-narrow) {
                        height: 56px;
                    }
                    polyfill-next-selector {
                        content: ':host.core-narrow.medium-tall, .core-narrow :host.medium-tall';
                    }
                    :host(.core-narrow.medium-tall),
                    :host-context(.core-narrow):host(.medium-tall) {
                        height: 112px;
                    }
                    polyfill-next-selector {
                        content: ':host.core-narrow.tall, .core-narrow :host.tall';
                    }
                    :host(.core-narrow.tall),
                    :host-context(.core-narrow):host(.tall) {
                        height: 168px;
                    }
                    polyfill-next-selector {
                        content: ':host.core-narrow .toolbar-tools, .core-narrow :host .toolbar-tools';
                    }
                    :host(.core-narrow) .toolbar-tools,
                    :host-context(.core-narrow) .toolbar-tools {
                        height: 56px;
                        padding: 0;
                    }
                    /* middle bar */
                    #middleBar {
                        position: absolute;
                        top: 0;
                        right: 0;
                        left: 0;
                    }
                    :host(.tall,
                    .medium-tall) #middleBar {
                        -webkit-transform: translateY(100%);
                        transform: translateY(100%);
                    }
                    /* bottom bar */
                    #bottomBar {
                        position: absolute;
                        right: 0;
                        bottom: 0;
                        left: 0;
                    }
                    /* make elements (e.g. buttons) respond to mouse/touch events */
                    polyfill-next-selector {
                        content: '.toolbar-tools > *';
                    }
                    ::content > * {
                        pointer-events: auto;
                    }
                    /* elements spacing */
                    polyfill-next-selector {
                        content: '.toolbar-tools > *';
                    }
                    ::content > * {
                        margin: 0 8px;
                    }
                    /* misc helpers */
                    polyfill-next-selector {
                        content: '.toolbar-tools > .fit';
                    }
                    ::content > .fit {
                        position: absolute;
                        top: auto;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        width: auto;
                        margin: 0;
                    }
                    polyfill-next-selector {
                        content: ':host .indent';
                    }
                    ::content > .indent {
                        margin-left: 60px;
                    }
                </style>

                <div id="bottomBar" class="toolbar-tools" center="" horizontal="" layout="">
                    <content select=".bottom"></content>
                </div>

                <div id="middleBar" class="toolbar-tools" center="" horizontal="" layout="">
                    <content select=".middle"></content>
                </div>

                <div id="topBar" class="toolbar-tools" center="" horizontal="" layout="">
                    <content></content>
                </div>

            </template>
            <script>
                Polymer('core-toolbar');
            </script>
        </polymer-element>

        <polymer-element name="core-header-panel" assetpath="bower_components/core-header-panel/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                    }
                    #outerContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                    }
                    #mainPanel {
                        position: relative;
                    }
                    #mainContainer {
                        position: relative;
                        overflow-y: auto;
                        overflow-x: hidden;
                        -webkit-overflow-scrolling: touch;
                    }
                    #dropShadow {
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 6px;
                        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
                    }
                    #dropShadow.hidden {
                        display: none;
                    }
                    /*
mode: scroll
*/
                    :host([mode=scroll]) #mainContainer {
                        overflow: visible;
                    }
                    :host([mode=scroll]) #outerContainer {
                        overflow-y: auto;
                        overflow-x: hidden;
                        -webkit-overflow-scrolling: touch;
                    }
                    /*
mode: cover
*/
                    :host([mode=cover]) #mainPanel {
                        position: static;
                    }
                    :host([mode=cover]) #mainContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                    }
                    :host([mode=cover]) #dropShadow {
                        position: static;
                        width: 100%;
                    }
                </style>

                <div id="outerContainer" vertical="" layout="">

                    <content id="headerContent" select="core-toolbar, .core-header"></content>

                    <div id="mainPanel" flex="" vertical="" layout="">

                        <div id="mainContainer" flex?="{{mode !== 'cover'}}">
                            <content id="mainContent" select="*"></content>
                        </div>

                        <div id="dropShadow"></div>

                    </div>

                </div>

            </template>
            <script>
                Polymer('core-header-panel', {

                    /**
                     * Fired when the content has been scrolled.  `event.detail.target` returns
                     * the scrollable element which you can use to access scroll info such as
                     * `scrollTop`.
                     *
                     *     <core-header-panel on-scroll="{{scrollHandler}}">
                     *       ...
                     *     </core-header-panel>
                     *
                     *
                     *     scrollHandler: function(event) {
                     *       var scroller = event.detail.target;
                     *       console.log(scroller.scrollTop);
                     *     }
                     *
                     * @event scroll
                     */

                    publish: {
                        /**
                         * Controls header and scrolling behavior. Options are
                         * `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
                         * `cover`. Default is `standard`.
                         *
                         * `standard`: The header is a step above the panel. The header will consume the
                         * panel at the point of entry, preventing it from passing through to the
                         * opposite side.
                         *
                         * `seamed`: The header is presented as seamed with the panel.
                         *
                         * `waterfall`: Similar to standard mode, but header is initially presented as
                         * seamed with panel, but then separates to form the step.
                         *
                         * `waterfall-tall`: The header is initially taller (`tall` class is added to
                         * the header).  As the user scrolls, the header separates (forming an edge)
                         * while condensing (`tall` class is removed from the header).
                         *
                         * `scroll`: The header keeps its seam with the panel, and is pushed off screen.
                         *
                         * `cover`: The panel covers the whole `core-header-panel` including the
                         * header. This allows user to style the panel in such a way that the panel is
                         * partially covering the header.
                         *
                         *     <style>
                         *       core-header-panel[mode=cover]::shadow #mainContainer {
                         *         left: 80px;
                         *       }
                         *       .content {
                         *         margin: 60px 60px 60px 0;
                         *       }
                         *     </style>
                         *
                         *     <core-header-panel mode="cover">
                         *       <core-appbar class="tall">
                         *         <core-icon-button icon="menu"></core-icon-button>
                         *       </core-appbar>
                         *       <div class="content"></div>
                         *     </core-header-panel>
                         *
                         * @attribute mode
                         * @type string
                         * @default ''
                         */
                        mode: {
                            value: '',
                            reflect: true
                        },

                        /**
                         * The class used in waterfall-tall mode.  Change this if the header
                         * accepts a different class for toggling height, e.g. "medium-tall"
                         *
                         * @attribute tallClass
                         * @type string
                         * @default 'tall'
                         */
                        tallClass: 'tall',

                        /**
                         * If true, the drop-shadow is always shown no matter what mode is set to.
                         *
                         * @attribute shadow
                         * @type boolean
                         * @default false
                         */
                        shadow: false
                    },

                    animateDuration: 200,

                    modeConfigs: {
                        shadowMode: {
                            'waterfall': 1,
                            'waterfall-tall': 1
                        },
                        noShadow: {
                            'seamed': 1,
                            'cover': 1,
                            'scroll': 1
                        },
                        tallMode: {
                            'waterfall-tall': 1
                        },
                        outerScroll: {
                            'scroll': 1
                        }
                    },

                    ready: function () {
                        this.scrollHandler = this.scroll.bind(this);
                        this.addListener();
                    },

                    detached: function () {
                        this.removeListener(this.mode);
                    },

                    addListener: function () {
                        this.scroller.addEventListener('scroll', this.scrollHandler);
                    },

                    removeListener: function (mode) {
                        var s = this.getScrollerForMode(mode);
                        s.removeEventListener('scroll', this.scrollHandler);
                    },

                    domReady: function () {
                        this.async('scroll');
                    },

                    modeChanged: function (old) {
                        var header = this.header;
                        if (header) {
                            var configs = this.modeConfigs;
                            // in tallMode it may add tallClass to the header; so do the cleanup
                            // when mode is changed from tallMode to not tallMode
                            if (configs.tallMode[old] && !configs.tallMode[this.mode]) {
                                header.classList.remove(this.tallClass);
                                this.async(function () {
                                    header.classList.remove('animate');
                                }, null, this.animateDuration);
                            } else {
                                header.classList.toggle('animate', configs.tallMode[this.mode]);
                            }
                        }
                        if (configs.outerScroll[this.mode] || configs.outerScroll[old]) {
                            this.removeListener(old);
                            this.addListener();
                        }
                        this.scroll();
                    },

                    get header() {
                        return this.$.headerContent.getDistributedNodes()[0];
                    },

                    getScrollerForMode: function (mode) {
                        return this.modeConfigs.outerScroll[mode] ?
                            this.$.outerContainer : this.$.mainContainer;
                    },

                    /**
                     * Returns the scrollable element.
                     *
                     * @property scroller
                     * @type Object
                     */
                    get scroller() {
                        return this.getScrollerForMode(this.mode);
                    },

                    scroll: function () {
                        var configs = this.modeConfigs;
                        var main = this.$.mainContainer;
                        var header = this.header;

                        var sTop = main.scrollTop;
                        var atTop = sTop === 0;

                        this.$.dropShadow.classList.toggle('hidden', !this.shadow &&
                            (atTop && configs.shadowMode[this.mode] || configs.noShadow[this.mode]));

                        if (header && configs.tallMode[this.mode]) {
                            header.classList.toggle(this.tallClass, atTop ||
                                header.classList.contains(this.tallClass) &&
                                main.scrollHeight < this.$.outerContainer.offsetHeight);
                        }

                        this.fire('scroll', {
                            target: this.scroller
                        }, this, false);
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="marked-element" attributes="text" assetpath="bower_components/marked-element/">
            <script>
                Polymer('marked-element', {

                    text: '',

                    attached: function () {
                        marked.setOptions({
                            highlight: this.highlight.bind(this)
                        });
                        if (!this.text) {
                            this.text = this.innerHTML;
                        }
                    },

                    textChanged: function () {
                        this.innerHTML = marked(this.text);
                    },

                    highlight: function (code, lang) {
                        var event = this.fire('marked-js-highlight', {
                            code: code,
                            lang: lang
                        });
                        return event.detail.code || code;
                    }

                });
            </script>
        </polymer-element>



        <polymer-element name="context-free-parser" attributes="url text data" assetpath="bower_components/context-free-parser/">
            <template>

                <core-ajax url="{{url}}" response="{{text}}" auto=""></core-ajax>

            </template>
            <script>
                Polymer('context-free-parser', {

                    text: null,

                    textChanged: function () {
                        if (this.text) {
                            var entities = ContextFreeParser.parse(this.text);
                            if (!entities || entities.length === 0) {
                                entities = [
                                    {
                                        name: this.url.split('/').pop(),
                                        description: '**Undocumented**'
                                    }
          ];
                            }
                            this.data = {
                                classes: entities
                            };
                        }
                    },

                    dataChanged: function () {
                        this.fire('data-ready');
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="core-doc-page" attributes="data" relative="" assetpath="bower_components/core-doc-viewer/elements/">

            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: block;
                    }
                    .main {
                        padding: 0 72px;
                        max-width: 832px;
                        margin: 0 auto;
                    }
                    marked-element {
                        display: block;
                    }
                    h1 {
                        color: #E91E63;
                        font-size: 52px;
                        line-height: 60px;
                        font-weight: inherit;
                    }
                    .box {
                        margin-bottom: 40px;
                    }
                    .box:not(.top) .details {
                        padding: 16px;
                    }
                    .box:not(.top) .details .params {
                        margin-top: 40px;
                    }
                    .box:not(.top) h3 {
                        padding: 16px;
                        color: white;
                        font-weight: inherit;
                        font-size: 20px;
                        line-height: 48px;
                        margin: 0;
                    }
                    .box:not(.top) pre {
                        padding: initial;
                        background-color: transparent;
                        margin: initial;
                        font-size: 12px;
                    }
                    .box code {
                        color: currentcolor;
                        font-weight: 500;
                    }
                    .top pre {
                        background-color: rgb(250, 250, 250);
                        padding: 16px;
                    }
                    pre {
                        max-width: 832px;
                        white-space: pre-wrap;
                        overflow: hidden;
                        border: none;
                    }
                    .attribute-box .details {
                        background-color: #ffcbbb;
                        border-bottom: 1px solid rgba(255, 86, 33, 0.5);
                    }
                    .attribute-box h3 {
                        background-color: #ff5621;
                    }
                    .property-box .details {
                        background-color: #fbe7b1;
                        border-bottom: 1px solid rgba(243, 179, 0, 0.5);
                    }
                    .property-box h3 {
                        background-color: #f3b300;
                    }
                    .method-box .details {
                        background-color: #a6ffea;
                        border-bottom: 1px solid rgba(0, 190, 164, 0.5);
                    }
                    .method-box h3 {
                        background-color: #00bea4;
                    }
                    .event-box .details {
                        background-color: #c5d9fb;
                        border-bottom: 1px solid rgba(65, 132, 243, 0.5);
                    }
                    .event-box h3 {
                        background-color: #4184f3;
                    }
                    .badge {
                        color: currentcolor;
                    }
                    code,
                    pre {
                        color: #9f499b;
                        font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
                    }
                    pre .typ,
                    pre .inline,
                    .prettyprint .typ,
                    .prettyprint .inline {
                        color: #6b499f
                    }
                    pre .pun,
                    .prettyprint .pun {
                        color: #5c6bc0
                    }
                    pre .str,
                    pre .string,
                    .prettyprint .str,
                    .prettyprint .string {
                        color: #ff4081
                    }
                    pre .pln,
                    .prettyprint .pln {
                        color: #7986cb
                    }
                    pre .kwd,
                    .prettyprint .kwd {
                        color: #d61a7f
                    }
                    pre .atn,
                    pre .attribute-name,
                    .prettyprint .atn,
                    .prettyprint .attribute-name {
                        color: #6b499f
                    }
                    pre .atv,
                    pre .attribute-value,
                    .prettyprint .atv,
                    .prettyprint .attribute-value {
                        color: #7986cb
                    }
                    pre .com,
                    pre .comment,
                    .prettyprint .com,
                    .prettyprint .comment {
                        color: #8a8a8a
                    }
                </style>

                <core-header-panel id="panel" mode="waterfall" fit="">

                    <!--<core-toolbar>
        <span style="margin: 0 72px;">{{data.name}}</span>
      </core-toolbar>-->

                    <div class="main" on-marked-js-highlight="{{hilight}}">

                        <h1>{{data.name}}</h1>

                        <p>
                            <core-icon icon="home"></core-icon>&nbsp;<a href="{{data | homepageFilter}}">Home Page</a>
                        </p>

                        <template if="{{data.extends}}">
                            <section class="top">
                                <h3 id="{{data.name}}.extends">Extends: <a href="#{{data.extends}}">{{data.extends}}</a></h3>
                            </section>
                        </template>

                        <template if="{{data.description}}">
                            <section class="box top">
                                <h3 id="{{data.name}}.summary">Summary</h3>
                                <marked-element text="{{data.description}}"></marked-element>
                            </section>
                        </template>

                        <template if="{{data.attributes.length}}">
                            <section class="box attribute-box">
                                <h3 id="{{data.name}}.attributes">Attributes</h3>
                                <template repeat="{{attribute in data.attributes}}">
                                    <div class="details" horizontal="" layout="">
                                        <div class="details-name" flex="" id="{{data.name}}.attributes.{{attribute.name}}">
                                            <p><code>{{attribute.name}}</code>
                                            </p>
                                        </div>
                                        <div class="details-info" flex="" three="">
                                            <p layout="" horizontal="" center="" justified="">
                                                <code>&lt;<em>{{attribute.type}}</em>&gt;</code><span class="default" hidden?="{{!attribute.default}}">default: <code>{{attribute.default}}</code></span>
                                            </p>
                                            <marked-element text="{{attribute.description}}"></marked-element>
                                        </div>
                                    </div>
                                </template>
                            </section>
                        </template>

                        <template if="{{data.properties.length}}">
                            <section class="box property-box">
                                <h3 id="{{data.name}}.properties">Properties</h3>
                                <template repeat="{{property in data.properties}}">
                                    <div class="details" horizontal="" layout="">
                                        <div class="details-name" flex="" id="{{data.name}}.properties.{{property.name}}">
                                            <p><code>{{property.name}}</code>
                                            </p>
                                        </div>
                                        <div class="details-info" flex="" three="">
                                            <p layout="" horizontal="" center="" justified="">
                                                <code>&lt;<em>{{property.type}}</em>&gt;</code><span class="default" hidden?="{{!property.default}}">default: <code>{{property.default}}</code></span>
                                            </p>
                                            <marked-element text="{{property.description}}"></marked-element>
                                        </div>
                                    </div>
                                </template>
                            </section>
                        </template>

                        <template if="{{data.events.length}}">
                            <section class="box event-box">
                                <h3 id="{{data.name}}.events">Events</h3>
                                <template repeat="{{event in data.events}}">
                                    <div class="details" horizontal="" layout="">
                                        <div class="details-name" flex="" id="{{data.name}}.events.{{event.name}}">
                                            <p><code>{{event.name}}</code>
                                            </p>
                                        </div>
                                        <div class="details-info" flex="" three="">
                                            <marked-element text="{{event.description}}"></marked-element>
                                            <template if="{{event.params.length}}">
                                                <div class="params">
                                                    <p>Event details:</p>
                                                    <template repeat="{{param in event.params}}">
                                                        <p><code>&lt;<em>{{param.type}}</em>&gt; {{param.name}}</code>
                                                        </p>
                                                        <p><span>{{param.description}}</span>
                                                        </p>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                </template>
                            </section>
                        </template>

                        <template if="{{data.methods.length}}">
                            <section class="box method-box">
                                <h3 id="{{data.name}}.methods">Methods</h3>
                                <template repeat="{{method in data.methods}}">
                                    <div class="details" horizontal="" layout="">
                                        <div class="details-name" flex="" id="{{data.name}}.methods.{{method.name}}">
                                            <p><code>{{method.name}}</code>
                                            </p>
                                        </div>
                                        <div class="details-info" flex="" three="">
                                            <marked-element text="{{method.description}}"></marked-element>
                                            <template if="{{method.params.length}}">
                                                <div class="params">
                                                    <p>Method parameters:</p>
                                                    <template repeat="{{param in method.params}}">
                                                        <p><code>&lt;<em>{{param.type}}</em>&gt; {{param.name}}</code>
                                                        </p>
                                                        <p><span>{{param.description}}</span>
                                                        </p>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                </template>
                            </section>
                        </template>

                    </div>

                </core-header-panel>

            </template>

            <script>
                Polymer('core-doc-page', {

                    hilight: function (event, detail, sender) {
                        detail.code = prettyPrintOne((detail.code || '').replace(/</g, '&lt;').replace(/>/g, '&gt;'));
                    },

                    homepageFilter: function (data) {
                        if (!data) {
                            return '';
                        }
                        if (!data.homepage || data.homepage === 'github.io') {
                            return '//polymer.github.io/' + data.name;
                        } else {
                            return data.homepage;
                        }
                    },

                    dataChanged: function () {
                        // Wrap in async() to delay execution until the next animation frame,
                        // since the <template> contents won't be stamped at the time this is executed.
                        this.async(function () {
                            var elementToFocus = this.shadowRoot.getElementById(window.location.hash.slice(1));
                            if (elementToFocus) {
                                elementToFocus.scrollIntoView();
                            }
                        });
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-item" attributes="label icon src" horizontal="" center="" layout="" assetpath="bower_components/core-item/">
            <template>
                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                        min-height: 40px;
                        white-space: nowrap;
                    }
                    :host(.font-scalable) {
                        min-height: 2.5em;
                    }
                    :host(.core-selected) {
                        font-weight: bold;
                    }
                    #icon {
                        margin: 0 16px 0 4px;
                    }
                    :host(.font-scalable) #icon {
                        margin: 0 1em 0 0.25em;
                        height: 1.5em;
                        width: 1.5em;
                    }
                    polyfill-next-selector {
                        content: ':host > a';
                    }
                    ::content > a {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        /* IE10 styling to ensure link is clickable. Cannot be completely
  transparent or minifiers change it to `transparent` which does not work. */
                        background-color: rgba(0, 0, 0, 0.000001);
                    }
                </style>
                <template if="{{icon || src}}">
                    <core-icon src="{{src}}" id="icon" icon="{{icon}}" hidden?="{{!src &amp;&amp; !icon}}"></core-icon>
                </template>
                <div id="label">{{label}}</div>
                <content></content>
            </template>
            <script>
                Polymer('core-item', {

                    /**
                     * The URL of an image for the icon.
                     *
                     * @attribute src
                     * @type string
                     * @default ''
                     */

                    /**
                     * Specifies the icon from the Polymer icon set.
                     *
                     * @attribute icon
                     * @type string
                     * @default ''
                     */

                    /**
                     * Specifies the label for the menu item.
                     *
                     * @attribute label
                     * @type string
                     * @default ''
                     */

                });
            </script>
        </polymer-element>
        <polymer-element name="core-doc-toc" attributes="data selected" assetpath="bower_components/core-doc-viewer/elements/">

            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: block;
                        position: relative;
                        border-right: 1px solid silver;
                    }
                    core-header-panel {
                        position: absolute;
                        top: 0;
                        left: 0;
                        height: 100%;
                        width: 100%;
                    }
                    core-toolbar {
                        background-color: #eeeeee;
                    }
                </style>

                <core-header-panel mode="waterfall">

                    <!--      <core-toolbar theme="core-light-theme">
        <core-icon-button icon="menu"></core-icon-button>
        <span core-flex>Topics</span>
        <core-icon-button icon="search" on-tap="{{searchAction}}"></core-icon-button>
      </core-toolbar>

      <core-toolbar id="searchBar" style="background-color: #C2185B; position: absolute; top: 0; left: 0; right: 0; opacity: 0; display: none;" class="seamed" theme="core-dark-theme">
        <core-icon-button icon="search"></core-icon-button>
        <core-icon-button icon="close" on-tap="{{closeSearchAction}}"></core-icon-button>
      </core-toolbar>-->

                    <core-menu selected="{{selected}}">
                        <template repeat="{{data}}">
                            <core-item><a href="#{{name}}">{{name}}</a>
                            </core-item>
                        </template>
                    </core-menu>

                </core-header-panel>

            </template>

            <script>
                Polymer('core-doc-toc', {

                    searchAction: function () {
                        this.$.searchBar.style.opacity = 1;
                        this.$.searchBar.style.display = '';
                    },

                    closeSearchAction: function () {
                        this.$.searchBar.style.opacity = 0;
                        this.$.searchBar.style.display = 'none';
                    }

                });
            </script>

        </polymer-element>
        <polymer-element name="core-doc-viewer" attributes="sources route url" horizontal="" layout="" assetpath="bower_components/core-doc-viewer/">

            <template>

                <style>
                    core-doc-toc {
                        display: none;
                        width: 332px;
                        overflow-x: hidden;
                    }
                </style>

                <context-free-parser url="{{url}}" on-data-ready="{{parserDataReady}}"></context-free-parser>

                <template repeat="{{sources}}">
                    <context-free-parser url="{{}}" on-data-ready="{{parserDataReady}}"></context-free-parser>
                </template>

                <core-doc-toc id="toc" data="{{classes}}" selected="{{selected}}"></core-doc-toc>
                <core-doc-page flex="" data="{{data}}"></core-doc-page>

            </template>

            <script>
                Polymer('core-doc-viewer', {
                    /**
                     * A single file to parse for docs
                     *
                     * @attribute url
                     * @type String
                     * @default ''
                     */

                    /**
                     * Class documentation extracted from the parser
                     *
                     * @property classes
                     * @type Array
                     * @default []
                     */
                    classes: [],

                    /**
                     * Files to parse for docs
                     *
                     * @attribute sources
                     * @type Array
                     * @default []
                     */
                    sources: [],

                    ready: function () {
                        window.addEventListener('hashchange', this.parseLocationHash.bind(this));
                        this.parseLocationHash();
                    },

                    parseLocationHash: function () {
                        this.route = window.location.hash.slice(1);
                    },

                    routeChanged: function () {
                        this.validateRoute();
                    },

                    validateRoute: function () {
                        if (this.route) {
                            this.classes.some(function (c) {
                                // The URL fragment might be just a class name,
                                // or it might be a class name followed by a '.' and then
                                // a section of the page.
                                // We want to match on class names here, so split on '.'.
                                // E.g.: 'core-ajax.properties.xhrArgs' -> 'core-ajax'
                                //       'core-xhr' -> 'core-xhr'
                                if (c.name === this.route.split('.')[0]) {
                                    this.data = c;
                                    this.route = '';
                                    return;
                                }
                            }, this);
                        }
                    },

                    selectedChanged: function () {
                        this.data = this.classes[this.selected];
                    },

                    parserDataReady: function (event) {
                        this.assimilateData(event.target.data);
                    },

                    assimilateData: function (data) {
                        this.classes = this.classes.concat(data.classes);
                        this.classes.sort(function (a, b) {
                            var na = a && a.name.toLowerCase(),
                                nb = b && b.name.toLowerCase();
                            return (na < nb) ? -1 : (na == nb) ? 0 : 1;
                        });
                        if (!this.data && !this.route && this.classes.length) {
                            this.data = this.classes[0];
                        }
                        if (this.classes.length > 1) {
                            this.$.toc.style.display = 'block';
                        }
                        this.validateRoute();
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-drag-drop" assetpath="bower_components/core-drag-drop/">
            <script>
                (function () {
                    var avatar;

                    Polymer('core-drag-drop', {

                        observe: {
                            'x y': 'coordinatesChanged'
                        },

                        ready: function () {
                            if (!avatar) {
                                avatar = document.createElement('core-drag-avatar');
                                document.body.appendChild(avatar);
                            }
                            this.avatar = avatar;
                            this.dragging = false;
                        },

                        draggingChanged: function () {
                            this.avatar.style.display = this.dragging ? '' : 'none';
                        },

                        coordinatesChanged: function () {
                            var x = this.x,
                                y = this.y;
                            this.avatar.style.transform =
                                this.avatar.style.webkitTransform =
                                'translate(' + x + 'px, ' + y + 'px)';
                        },

                        attached: function () {
                            var listen = function (event, handler) {
                                Polymer.addEventListener(this.parentNode, event, this[handler].bind(this));
                            }.bind(this);
                            //
                            listen('trackstart', 'trackStart');
                            listen('track', 'track');
                            listen('trackend', 'trackEnd');
                            //
                            var host = this.parentNode.host || this.parentNode;
                            host.style.cssText += '; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;';
                        },

                        trackStart: function (event) {
                            this.avatar.style.cssText = '';
                            this.dragInfo = {
                                event: event,
                                avatar: this.avatar
                            };
                            this.fire('drag-start', this.dragInfo);
                            // flaw #1: what if user doesn't need `drag()`?
                            this.dragging = Boolean(this.dragInfo.drag);
                        },

                        track: function (event) {
                            if (this.dragging) {
                                this.x = event.pageX;
                                this.y = event.pageY;
                                this.dragInfo.event = event;
                                this.dragInfo.p = {
                                    x: this.x,
                                    y: this.y
                                };
                                this.dragInfo.drag(this.dragInfo);
                            }
                        },

                        trackEnd: function (event) {
                            if (this.dragging) {
                                this.dragging = false;
                                if (this.dragInfo.drop) {
                                    this.dragInfo.framed = this.framed(event.relatedTarget);
                                    this.dragInfo.event = event;
                                    this.dragInfo.drop(this.dragInfo);
                                }
                            }
                            this.dragInfo = null;
                        },

                        framed: function (node) {
                            var local = node.getBoundingClientRect();
                            return {
                                x: this.x - local.left,
                                y: this.y - local.top
                            };
                        }

                    });

                })();
            </script>
        </polymer-element>

        <polymer-element name="core-drawer-panel" touch-action="auto" assetpath="bower_components/core-drawer-panel/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        overflow: hidden;
                    }
                    core-selector > #drawer {
                        position: absolute;
                        top: 0;
                        left: 0;
                        height: 100%;
                        will-change: transform;
                        box-sizing: border-box;
                        -mox-box-sizing: border-box;
                    }
                    .transition > #drawer {
                        transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s;
                        transition: transform ease-in-out 0.3s, width ease-in-out 0.3s;
                    }
                    /*
right-drawer: make drawer on the right side
*/
                    .right-drawer > #drawer {
                        left: auto;
                        right: 0;
                    }
                    .right-drawer.transition > #drawer {
                        transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s;
                        transition: transform ease-in-out 0.3s, width ease-in-out 0.3s;
                    }
                    polyfill-next-selector {
                        content: ':host [drawer]';
                    }
                    ::content[select="[drawer]"] > * {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                    }
                    core-selector > #main {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                    }
                    .transition > #main {
                        transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
                    }
                    .right-drawer > #main {
                        left: 0;
                    }
                    .right-drawer.transition > #main {
                        transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
                    }
                    polyfill-next-selector {
                        content: '#main > [main]';
                    }
                    ::content[select="[main]"] > * {
                        height: 100%;
                    }
                    #scrim {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        background-color: rgba(0, 0, 0, 0.3);
                        visibility: hidden;
                        opacity: 0;
                        transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
                    }
                    /*
narrow layout
*/
                    .narrow-layout > #drawer.core-selected {
                        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
                    }
                    .right-drawer.narrow-layout > #drawer.core-selected {
                        box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
                    }
                    polyfill-next-selector {
                        content: ':host .narrow-layout > #drawer > [drawer]';
                    }
                    .narrow-layout > #drawer >::content[select="[drawer]"] > * {
                        border: 0;
                    }
                    .narrow-layout > #drawer:not(.core-selected) {
                        -webkit-transform: translateX(-100%);
                        transform: translateX(-100%);
                    }
                    .right-drawer.narrow-layout > #drawer:not(.core-selected) {
                        left: auto;
                        -webkit-transform: translateX(100%);
                        transform: translateX(100%);
                    }
                    .narrow-layout > #main {
                        left: 0 !important;
                        padding: 0;
                    }
                    .right-drawer.narrow-layout > #main {
                        left: 0;
                        right: 0;
                        padding: 0;
                    }
                    .narrow-layout > #main:not(.core-selected) > #scrim,
                    .dragging #scrim {
                        visibility: visible;
                        opacity: 1;
                    }
                    polyfill-next-selector {
                        content: ':host .narrow-layout > #main > [main]';
                    }
                    .narrow-layout > #main >::content[select="[main]"] > * {
                        margin: 0;
                        min-height: 100%;
                        left: 0;
                        right: 0;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                    }
                </style>

                <core-media-query query="max-width: {{responsiveWidth}}" querymatches="{{queryMatches}}"></core-media-query>

                <core-selector class="{{ {'narrow-layout' : queryMatches, transition : transition, dragging : dragging, 'right-drawer': rightDrawer} | tokenList }}" valueattr="id" selected="{{selected}}">

                    <div id="main" _style="left: {{ narrow || rightDrawer ? '0' : drawerWidth }}; right: {{ rightDrawer ? (narrow ? '' : drawerWidth) : '' }};">
                        <content select="[main]"></content>
                        <div id="scrim" on-tap="{{togglePanel}}"></div>
                    </div>

                    <div id="drawer" _style="width: {{ drawerWidth }}">
                        <content select="[drawer]"></content>
                    </div>

                </core-selector>

            </template>
            <script>
                Polymer('core-drawer-panel', {

                    /**
                     * Fired when the narrow layout changes.
                     *
                     * @event core-responsive-change
                     * @param {Object} detail
                     * @param {boolean} detail.narrow true if the panel is in narrow layout.
                     */

                    publish: {

                        /**
                         * Width of the drawer panel.
                         *
                         * @attribute drawerWidth
                         * @type string
                         * @default '256px'
                         */
                        drawerWidth: '256px',

                        /**
                         * Max-width when the panel changes to narrow layout.
                         *
                         * @attribute responsiveWidth
                         * @type string
                         * @default '640px'
                         */
                        responsiveWidth: '640px',

                        /**
                         * The panel that is being selected. `drawer` for the drawer panel and
                         * `main` for the main panel.
                         *
                         * @attribute selected
                         * @type string
                         * @default null
                         */
                        selected: {
                            value: null,
                            reflect: true
                        },

                        /**
                         * The panel to be selected when `core-drawer-panel` changes to narrow
                         * layout.
                         *
                         * @attribute defaultSelected
                         * @type string
                         * @default 'main'
                         */
                        defaultSelected: 'main',

                        /**
                         * Returns true if the panel is in narrow layout.  This is useful if you
                         * need to show/hide elements based on the layout.
                         *
                         * @attribute narrow
                         * @type boolean
                         * @default false
                         */
                        narrow: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * If true, position the drawer to the right.
                         *
                         * @attribute rightDrawer
                         * @type boolean
                         * @default false
                         */
                        rightDrawer: false,

                        /**
                         * If true, swipe to open/close the drawer is disabled.
                         *
                         * @attribute disableSwipe
                         * @type boolean
                         * @default false
                         */
                        disableSwipe: false
                    },

                    eventDelegates: {
                        trackstart: 'trackStart',
                        trackx: 'trackx',
                        trackend: 'trackEnd',
                        down: 'touchStart',
                        up: 'touchEnd'
                    },

                    // Whether the transition is enabled.
                    transition: false,

                    // How many pixels on the side of the screen are sensitive to edge swipes and peek.
                    edgeSwipeSensitivity: 15,

                    // Whether the drawer is peeking out from the edge.
                    peeking: false,

                    // Whether the user is dragging the drawer interactively.
                    dragging: false,

                    // Whether the browser has support for the transform CSS property.
                    hasTransform: true,

                    // Whether the browser has support for the will-change CSS property.
                    hasWillChange: true,

                    created: function () {
                        this.hasTransform = 'transform' in this.style;
                        this.hasWillChange = 'willChange' in this.style;
                    },

                    domReady: function () {
                        // to avoid transition at the beginning e.g. page loads
                        // NOTE: domReady is already raf delayed and delaying another frame
                        // ensures a layout has occurred.
                        this.async(function () {
                            this.transition = true;
                        });
                    },

                    /**
                     * Toggles the panel open and closed.
                     *
                     * @method togglePanel
                     */
                    togglePanel: function () {
                        this.selected = this.selected === 'main' ? 'drawer' : 'main';
                    },

                    /**
                     * Opens the drawer.
                     *
                     * @method openDrawer
                     */
                    openDrawer: function () {
                        this.selected = 'drawer';
                    },

                    /**
                     * Closes the drawer.
                     *
                     * @method closeDrawer
                     */
                    closeDrawer: function () {
                        this.selected = 'main';
                    },

                    queryMatchesChanged: function () {
                        if (this.queryMatches) {
                            this.selected = this.defaultSelected;
                        }
                        this.narrow = this.queryMatches;
                        this.setAttribute('touch-action', this.swipeAllowed() ? 'pan-y' : '');
                        this.fire('core-responsive-change', {
                            narrow: this.narrow
                        });
                    },

                    swipeAllowed: function () {
                        return this.narrow && !this.disableSwipe;
                    },

                    startEdgePeek: function () {
                        this.width = this.$.drawer.offsetWidth;
                        this.moveDrawer(this.translateXForDeltaX(this.rightDrawer ?
                            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
                        this.peeking = true;
                    },

                    stopEdgePeak: function () {
                        if (this.peeking) {
                            this.peeking = false;
                            this.moveDrawer(null);
                        }
                    },

                    touchStart: function (e) {
                        if (!this.dragging && this.selected === 'main' && this.isEdgeTouch(e))
                            this.startEdgePeek();
                    },

                    touchEnd: function (e) {
                        this.stopEdgePeak();
                    },

                    isEdgeTouch: function (e) {
                        return this.swipeAllowed() && (this.rightDrawer ?
                            e.pageX >= this.offsetWidth - this.edgeSwipeSensitivity :
                            e.pageX <= this.edgeSwipeSensitivity);
                    },

                    // swipe support for the drawer, inspired by
                    // https://github.com/Polymer/core-drawer-panel/pull/6
                    trackStart: function (e) {
                        if (this.swipeAllowed()) {
                            this.dragging = true;

                            if (this.selected === 'main')
                                this.dragging = this.peeking || this.isEdgeTouch(e);

                            if (this.dragging) {
                                this.width = this.$.drawer.offsetWidth;
                                this.transition = false;
                                e.preventTap();
                            }
                        }
                    },

                    translateXForDeltaX: function (deltaX) {
                        if (this.rightDrawer) {
                            return Math.max(0, (this.selected === 'main') ? this.width + deltaX : deltaX);
                        } else {
                            return Math.min(0, (this.selected === 'main') ? deltaX - this.width : deltaX);
                        }
                    },

                    trackx: function (e) {
                        if (this.dragging) {
                            if (this.peeking) {
                                if (Math.abs(e.dx) <= this.edgeSwipeSensitivity)
                                    return; // Ignore trackx until we move past the edge peek.
                                this.peeking = false;
                            }
                            this.moveDrawer(this.translateXForDeltaX(e.dx));
                        }
                    },

                    trackEnd: function (e) {
                        if (this.dragging) {
                            this.dragging = false;
                            this.transition = true;
                            this.moveDrawer(null);

                            if (this.rightDrawer) {
                                this.selected = e.xDirection > 0 ? 'main' : 'drawer';
                            } else {
                                this.selected = e.xDirection > 0 ? 'drawer' : 'main';
                            }
                        }
                    },

                    transformForTranslateX: function (translateX) {
                        if (translateX === null)
                            return '';
                        return this.hasWillChange ? 'translateX(' + translateX + 'px)' : 'translate3d(' + translateX + 'px, 0, 0)';
                    },

                    moveDrawer: function (translateX) {
                        var s = this.$.drawer.style;

                        if (this.hasTransform) {
                            s.transform = this.transformForTranslateX(translateX);
                        } else {
                            s.webkitTransform = this.transformForTranslateX(translateX);
                        }
                    },

                });
            </script>
        </polymer-element>

        <polymer-element name="core-dropdown-menu" assetpath="bower_components/core-dropdown-menu/">
            <template>

                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        position: relative;
                        display: inline-block;
                        background-color: #fff;
                    }
                    #control core-item {
                        margin-left: 12px;
                        max-width: inherit;
                    }
                    #control core-item::shadow #label {
                        overflow: hidden;
                        /* FIXME not working for some reason */
                        white-space: nowrap;
                        text-overflow: ellipsis;
                    }
                    #arrow {
                        margin: 0 12px;
                    }
                    #dropdown {
                        margin: 12px;
                    }
                </style>

                <div id="control" layout="" horizontal="" center="" on-tap="{{toggle}}">
                    <core-item flex="" src="{{selectedItem.src}}" icon="{{selectedItem.icon}}" label="{{selectedItem ? (selectedItem.label || selected) : label}}"></core-item>
                    <core-icon id="arrow" icon="{{opened ? 'arrow-drop-up' : 'arrow-drop-down'}}"></core-icon>
                </div>

                <core-dropdown id="dropdown" relatedtarget="{{$.control}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}">
                    <core-menu selected="{{selected}}" valueattr="{{valueattr}}" selecteditem="{{selectedItem}}" on-core-activate="{{activateAction}}">
                        <content></content>
                    </core-menu>
                </core-dropdown>

            </template>
            <script>
                Polymer('core-dropdown-menu', {

                    publish: {

                        /**
                         * True if the menu is open.
                         *
                         * @attribute opened
                         * @type boolean
                         * @default false
                         */
                        opened: false,

                        /**
                         * A label for the control. The label is displayed if no item is selected.
                         *
                         * @attribute label
                         * @type string
                         * @default 'Select an item'
                         */
                        label: 'Select an item',

                        /**
                         * The currently selected element. By default this is the index of the item element.
                         * If you want a specific attribute value of the element to be used instead of the
                         * index, set `valueattr` to that attribute name.
                         *
                         * @attribute selected
                         * @type Object
                         * @default null
                         */
                        selected: null,

                        /**
                         * Specifies the attribute to be used for "selected" attribute.
                         *
                         * @attribute valueattr
                         * @type string
                         * @default 'name'
                         */
                        valueattr: 'name',

                        /**
                         * Specifies the CSS class to be used to add to the selected element.
                         *
                         * @attribute selectedClass
                         * @type string
                         * @default 'core-selected'
                         */
                        selectedClass: 'core-selected',

                        /**
                         * Specifies the property to be used to set on the selected element
                         * to indicate its active state.
                         *
                         * @attribute selectedProperty
                         * @type string
                         * @default ''
                         */
                        selectedProperty: '',

                        /**
                         * Specifies the attribute to set on the selected element to indicate
                         * its active state.
                         *
                         * @attribute selectedAttribute
                         * @type string
                         * @default 'active'
                         */
                        selectedAttribute: 'selected',

                        /**
                         * The currently selected element.
                         *
                         * @attribute selectedItem
                         * @type Object
                         * @default null
                         */
                        selectedItem: null,

                        /**
                         * Horizontally align the overlay with the control.
                         *
                         * @attribute halign
                         * @type "left" | "right"
                         * @default "left"
                         */
                        halign: 'left',

                        /**
                         * Vertically align the dropdown menu with the control.
                         *
                         * @attribute valign
                         * @type "top" | "bottom"
                         * @default "bottom"
                         */
                        valign: 'top'

                    },

                    activateAction: function () {
                        this.opened = false;
                    },

                    toggle: function () {
                        this.opened = !this.opened;
                    }

                });
            </script>
        </polymer-element>
        <polymer-element name="core-field" center="" horizontal="" layout="" assetpath="bower_components/core-field/">
            <template>

                <style>
                    /* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */
                    :host {
                        display: block;
                        color: #333;
                        font-size: 14px;
                    }
                    polyfill-next-selector {
                        content: ':host > core-icon';
                    }
                    ::content > core-icon {
                        margin: 8px;
                    }
                    polyfill-next-selector {
                        content: ':host input';
                    }
                    ::content input {
                        background: transparent;
                        border: 0;
                        padding: 0;
                        margin: 0 4px;
                        color: #333;
                        font-size: 14px;
                    }
                    polyfill-next-selector {
                        content: ':host input:focus';
                    }
                    ::content input:focus {
                        outline: none;
                    }
                    polyfill-next-selector {
                        content: ':host input::placeholder';
                    }
                    ::content input::placeholder {
                        color: #b3b3b3;
                    }
                </style>

                <content select="*"></content>

            </template>
            <script>
                Polymer('core-field');
            </script>
        </polymer-element>

        <polymer-element name="core-layout-grid" attributes="nodes layout auto" assetpath="bower_components/core-layout-grid/">
            <script>
                (function () {

                    Polymer('core-layout-grid', {

                        nodes: null,
                        layout: null,
                        auto: false,

                        created: function () {
                            this.layout = [];
                        },

                        nodesChanged: function () {
                            this.invalidate();
                        },

                        layoutChanged: function () {
                            this.invalidate();
                        },

                        autoNodes: function () {
                            this.nodes = this.parentNode.children.array().filter(
                                function (node) {
                                    switch (node.localName) {
                                    case 'core-layout-grid':
                                    case 'style':
                                        return false;
                                    }
                                    return true;
                                }
                            );
                        },

                        invalidate: function () {
                            if (this.layout && this.layout.length) {
                                // job debounces layout, only letting it occur every N ms
                                this.layoutJob = this.job(this.layoutJob, this.relayout);
                            }
                        },

                        relayout: function () {
                            if (!this.nodes || this.auto) {
                                this.autoNodes();
                            }
                            layout(this.layout, this.nodes);
                            this.asyncFire('core-layout');
                        }

                    });

                    //

                    var lineParent;

                    function line(axis, p, d) {
                        var l = document.createElement('line');
                        var extent = (axis === 'left' ? 'width' :
                            (axis === 'top' ? 'height' : axis));
                        l.setAttribute('extent', extent);
                        if (d < 0) {
                            axis = (axis === 'left' ? 'right' :
                                (axis === 'top' ? 'bottom' : axis));
                        }
                        p = Math.abs(p);
                        l.style[axis] = p + 'px';
                        l.style[extent] = '0px';
                        lineParent.appendChild(l);
                    }

                    var colCount, colOwners, rowCount, rowOwners;

                    function matrixillate(matrix) {
                        // mesaure the matrix, must be rectangular
                        rowCount = matrix.length;
                        colCount = rowCount && matrix[0].length || 0;
                        // transpose matrix
                        var transpose = [];
                        for (var i = 0; i < colCount; i++) {
                            var c = [];
                            for (var j = 0; j < rowCount; j++) {
                                c.push(matrix[j][i]);
                            }
                            transpose.push(c);
                        }
                        // assign sizing control
                        colOwners = findOwners(matrix);
                        rowOwners = findOwners(transpose);
                        //console.log('colOwners', colOwners);
                        //console.log('rowOwners', rowOwners);
                    }

                    function findOwners(matrix) {
                        var majCount = matrix.length;
                        var minCount = majCount && matrix[0].length || 0;
                        var owners = [];
                        // for each column (e.g.)
                        for (var i = 0; i < minCount; i++) {
                            // array of contained areas
                            var contained = {};
                            // look at each row to find a containing area
                            for (var j = 0; j < majCount; j++) {
                                // get the row vector
                                var vector = matrix[j]
                                    // node index at [i,j]
                                var nodei = vector[i];
                                // if a node is there
                                if (nodei) {
                                    // determine if it bounds this column
                                    var owns = false;
                                    if (i === 0) {
                                        owns = (i === minCount - 1) || (nodei !== vector[i + 1]);
                                    } else if (i === minCount - 1) {
                                        owns = (i === 0) || (nodei !== vector[i - 1]);
                                    } else {
                                        owns = nodei !== vector[i - 1] && nodei !== vector[i + 1];
                                    }
                                    if (owns) {
                                        contained[nodei] = 1;
                                    }
                                }
                                // store the owners for this column
                                owners[i] = contained;
                            }
                        }
                        return owners;
                    }

                    var nodes;

                    function colWidth(i) {
                        for (var col in colOwners[i]) {
                            col = Number(col);
                            if (col === 0) {
                                return 96;
                            }
                            var node = nodes[col - 1];
                            if (node.hasAttribute('h-flex') || node.hasAttribute('flex')) {
                                return -1;
                            }
                            var w = node.offsetWidth;
                            //console.log('colWidth(' + i + ') ==', w);
                            return w;
                        }
                        return -1;
                    }

                    function rowHeight(i) {
                        for (var row in rowOwners[i]) {
                            row = Number(row);
                            if (row === 0) {
                                return 96;
                            }
                            var node = nodes[row - 1];
                            if (node.hasAttribute('v-flex') || node.hasAttribute('flex')) {
                                return -1;
                            }
                            var h = node.offsetHeight;
                            //console.log('rowHeight(' + i + ') ==', h);
                            return h;
                        }
                        return -1;
                    }

                    var m = 0;

                    function railize(count, sizeFn) {
                        //
                        // create rails for `count` tracks using
                        // sizing function `sizeFn(trackNo)`
                        //
                        // for n tracks there are (n+1) rails
                        //
                        //   |track|track|track|
                        //  0|->sz0|->sz1|<-sz2|0
                        //
                        //   |track|track|track|
                        //  0|->sz0|     |<-sz2|0
                        //
                        // there can be one elastic track per set
                        //
                        //   |track|track|track|track|
                        //  0|-->s0|-->s1|<--s1|<--s2|0
                        //
                        // sz1 spans multiple  tracks which makes
                        // it elastic (it's underconstrained)
                        //
                        var rails = [];
                        var a = 0;
                        for (var i = 0, x; i < count; i++) {
                            rails[i] = {
                                p: a,
                                s: 1
                            };
                            x = sizeFn(i) + m + m;
                            if (x == -1) {
                                break;
                            }
                            a += x;
                        }
                        if (i === count) {
                            rails[i] = {
                                p: 0,
                                s: -1
                            };
                        }
                        var b = 0;
                        for (var ii = count, x; ii > i; ii--) {
                            rails[ii] = {
                                p: b,
                                s: -1
                            };
                            x = sizeFn(ii - 1) + m + m;
                            if (x !== -1) {
                                b += x;
                            }
                        }
                        return rails;
                    }

                    // TODO(sjmiles): this code tries to preserve actual position,
                    // so 'unposition' is really 'naturalize' or something
                    function unposition(box) {
                        var style = box.style;
                        //style.right = style.bottom = style.width = style.height = '';
                        style.position = 'absolute';
                        style.display = 'inline-block';
                        style.boxSizing = style.mozBoxSizing = 'border-box';
                    }

                    function _position(style, maj, min, ext, a, b) {
                        style[maj] = style[min] = '';
                        style[ext] = 'auto';
                        if (a.s < 0 && b.s < 0) {
                            var siz = a.p - b.p - m - m;
                            style[ext] = siz + 'px';
                            var c = 'calc(100% - ' + (b.p + siz + m) + 'px' + ')';
                            style[maj] = '-webkit-' + c;
                            style[maj] = c;
                        } else if (b.s < 0) {
                            style[maj] = a.p + m + 'px';
                            style[min] = b.p + m + 'px';
                        } else {
                            style[maj] = a.p + m + 'px';
                            style[ext] = b.p - a.p - m - m + 'px';
                        }
                    }

                    function position(elt, left, right, top, bottom) {
                        _position(elt.style, 'top', 'bottom', 'height', rows[top],
                            rows[bottom]);
                        _position(elt.style, 'left', 'right', 'width', columns[left],
                            columns[right]);
                    }

                    function layout(matrix, anodes, alineParent) {
                        //console.group('layout');

                        lineParent = alineParent;
                        nodes = anodes;
                        matrixillate(matrix);

                        nodes.forEach(unposition);

                        columns = railize(colCount, colWidth);
                        rows = railize(rowCount, rowHeight);

                        if (alineParent) {
                            //console.group('column rails');
                            columns.forEach(function (c) {
                                //console.log(c.p, c.s);
                                line('left', c.p, c.s);
                            });
                            //console.groupEnd();

                            //console.group('row rails');
                            rows.forEach(function (r) {
                                //console.log(r.p, r.s);
                                line('top', r.p, r.s);
                            });
                            //console.groupEnd();
                        }

                        //console.group('rail boundaries');
                        nodes.forEach(function (node, i) {
                            // node indices are 1-based
                            var n = i + 1;
                            // boundary rails
                            var l, r, t = 1e10,
                                b = -1e10;
                            matrix.forEach(function (vector, i) {
                                var f = vector.indexOf(n);
                                if (f > -1) {
                                    l = f;
                                    r = vector.lastIndexOf(n) + 1;
                                    t = Math.min(t, i);
                                    b = Math.max(b, i) + 1;
                                }
                            });
                            if (l == undefined) {
                                //console.log('unused');
                                node.style.position = 'absolute';
                                var offscreen = node.getAttribute('offscreen');
                                switch (offscreen) {
                                case 'basement':
                                    node.style.zIndex = 0;
                                    break;
                                case 'left':
                                case 'top':
                                    node.style[offscreen] = node.offsetWidth * -2 + 'px';
                                    break;
                                case 'right':
                                    node.style.left = node.offsetParent.offsetWidth + node.offsetWidth + 'px';
                                    break;
                                case 'bottom':
                                    node.style.top = node.parentNode.offsetHeight + node.offsetHeight + 'px';
                                    break;
                                default:
                                    node.style[Math.random() >= 0.5 ? 'left' : 'top'] = '-110%';
                                }
                                //node.style.opacity = 0;
                                node.style.pointerEvents = 'none';
                            } else {
                                node.style.pointerEvents = '';
                                //node.style.opacity = '';
                                //console.log(l, r, t, b);
                                position(node, l, r, t, b);
                            }
                        });
                        //console.groupEnd();
                        //console.groupEnd();
                    }

                })();
            </script>
        </polymer-element>
        <polymer-element name="core-layout-trbl" attributes="vertical" assetpath="bower_components/core-layout-trbl/">

            <template>

                <style>
                    :host {
                        display: none;
                    }
                </style>

            </template>

            <script>
                Polymer('core-layout-trbl', {

                    vertical: false,

                    ready: function () {
                        this.setAttribute('nolayout', '');
                    },

                    attached: function () {
                        this.asyncMethod(function () {
                            this.prepare();
                            this.layout();
                        });
                    },

                    prepare: function () {
                        var parent = this.parentNode.host || this.parentNode;
                        // explicit position harmful on <body>
                        if (parent.localName !== 'body') {
                            // may recalc
                            var cs = window.getComputedStyle(parent);
                            if (cs.position === 'static') {
                                parent.style.position = 'relative';
                            }
                            //parent.style.overflow = 'hidden';
                        }
                        // changes will cause another recalc at next validation step
                        var stylize = this.stylize,
                            vertical;
                        this.parentNode.childNodes.array().forEach(function (c, i) {
                            if (c.nodeType === Node.ELEMENT_NODE && !c.hasAttribute('nolayout')) {
                                stylize(c, {
                                    position: 'absolute',
                                    boxSizing: 'border-box',
                                    MozBoxSizing: 'border-box',
                                });
                                // test for auto-vertical
                                if (vertical === undefined) {
                                    vertical = (c.offsetWidth == 0 && c.offsetHeight !== 0);
                                }
                            }
                        });
                        this.vertical = this.vertical || vertical;
                    },

                    /**
                     * Arrange sibling nodes end-to-end in one dimension.
                     *
                     * Arrangement is horizontal unless the `vertical`
                     * attribute is applied on this node.
                     *
                     * @method layout
                     */
                    layout: function () {
                        var parent = this.parentNode.host || this.parentNode;
                        var vertical = this.vertical;
                        var ww = 0,
                            hh = 0,
                            pre = [],
                            fit, post = [];
                        var list = pre;
                        // gather element information (at most one recalc)
                        this.parentNode.childNodes.array().forEach(function (c, i) {
                            if (c.nodeType === Node.ELEMENT_NODE && !c.hasAttribute('nolayout')) {
                                var info = {
                                    element: c,
                                    w: c.offsetWidth,
                                    h: c.offsetHeight
                                };
                                if (!c.hasAttribute('fit') && !c.hasAttribute('flex')) {
                                    ww += c.offsetWidth;
                                    hh += c.offsetHeight;
                                    list.push(info);
                                } else {
                                    fit = c;
                                    list = post;
                                    ww = hh = 0;
                                }
                            }
                        });
                        // update layout styles (invalidate, no recalc)
                        var v = 0;
                        var mxp = 0,
                            myp = 0;
                        var stylize = this.stylize;
                        pre.forEach(function (info) {
                            if (vertical) {
                                stylize(info.element, {
                                    top: v + 'px',
                                    right: mxp,
                                    height: info.h + 'px',
                                    left: mxp
                                });
                            } else {
                                stylize(info.element, {
                                    top: myp,
                                    width: info.w + 'px',
                                    bottom: myp,
                                    left: v + 'px'
                                });
                            }
                            v += vertical ? info.h : info.w;
                        });
                        if (fit) {
                            if (vertical) {
                                stylize(fit, {
                                    top: v + 'px',
                                    right: mxp,
                                    bottom: hh + 'px',
                                    left: mxp
                                });
                            } else {
                                stylize(fit, {
                                    top: myp,
                                    right: ww + 'px',
                                    bottom: myp,
                                    left: v + 'px'
                                });
                            }
                            v = vertical ? hh : ww;
                            post.forEach(function (info) {
                                v -= vertical ? info.h : info.w;
                                if (vertical) {
                                    stylize(info.element, {
                                        height: info.h + 'px',
                                        right: mxp,
                                        bottom: v + 'px',
                                        left: mxp
                                    });
                                } else {
                                    stylize(info.element, {
                                        top: myp,
                                        right: v + 'px',
                                        bottom: myp,
                                        width: info.w + 'px'
                                    });
                                }
                            });
                        }
                    },

                    stylize: function (element, styles) {
                        var style = element.style;
                        Object.keys(styles).forEach(function (k) {
                            style[k] = styles[k];
                        });
                    }

                });
            </script>

        </polymer-element>

        <polymer-element name="core-list" on-tap="{{tapHandler}}" tabindex="-1" assetpath="bower_components/core-list/">
            <template>
                <core-selection id="selection" multi="{{multi}}" on-core-select="{{selectedHandler}}"></core-selection>
                <style>
                    /*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
                    :host {
                        display: block;
                        overflow: auto;
                        outline: none;
                    }
                    .core-list-viewport > * {
                        overflow: hidden;
                    }
                    .core-list-viewport.horizontal {
                        height: 100%;
                        white-space: nowrap;
                    }
                    .core-list-viewport.horizontal > * {
                        display: inline-block;
                    }
                    /* Setting will-change: transform on the #viewport makes the viewport a
   stacking context, which causes all the composited layers inside the
   viewport to actually be stacked underneath the viewport. */
                    #viewport {
                        will-change: transform;
                    }
                </style>
                <div id="viewport" class="core-list-viewport">
                    <content></content>
                </div>
            </template>
            <script>
                (function () {

                    Polymer('core-list', {

                        publish: {
                            /**
                             * Fired when an item element is tapped.
                             *
                             * @event core-activate
                             * @param {Object} detail
                             *   @param {Object} detail.item the item element
                             */

                            /**
                             *
                             * An array of source data for the list to display.
                             *
                             * @attribute data
                             * @type array
                             * @default null
                             */
                            data: null,

                            /**
                             *
                             * An optional element on which to listen for scroll events.
                             *
                             * @attribute scrollTarget
                             * @type Element
                             * @default core-list
                             */
                            scrollTarget: null,

                            /**
                             *
                             * The height of a list item. `core-list` currently supports only fixed-height
                             * list items. This height must be specified via the height property.
                             *
                             * @attribute height
                             * @type number
                             * @default 80
                             */
                            height: 80,

                            /**
                             *
                             * The number of extra items rendered above the minimum set required to
                             * fill the list's height.
                             *
                             * @attribute extraItems
                             * @type number
                             * @default 30
                             */
                            extraItems: 30,

                            /**
                             *
                             * When true, tapping a row will select the item, placing its data model
                             * in the set of selected items retrievable via the `selection` property.
                             *
                             * Note that tapping focusable elements within the list item will not
                             * result in selection, since they are presumed to have their own action.
                             *
                             * @attribute selectionEnabled
                             * @type {boolean}
                             * @default true
                             */
                            selectionEnabled: true,

                            /**
                             *
                             * Set to true to support multiple selection.  Note, existing selection
                             * state is maintained only when changing `multi` from `false` to `true`;
                             * it is cleared when changing from `true` to `false`.
                             *
                             * @attribute multi
                             * @type boolean
                             * @default false
                             */
                            multi: false,

                            /**
                             *
                             * Data record (or array of records, if `multi: true`) corresponding to
                             * the currently selected set of items.
                             *
                             * @attribute selection
                             * @type {any}
                             * @default null
                             */
                            selection: null
                        },

                        // Local cache of scrollTop
                        _scrollTop: 0,

                        observe: {
                            'data template scrollTarget': 'initialize',
                            'multi selectionEnabled': '_resetSelection'
                        },

                        ready: function () {
                            this._boundScrollHandler = this.scrollHandler.bind(this);
                            this._oldMulti = this.multi;
                            this._oldSelectionEnabled = this.selectionEnabled;
                        },

                        attached: function () {
                            this.template = this.querySelector('template');
                            if (!this.template.bindingDelegate) {
                                this.template.bindingDelegate = this.element.syntax;
                            }
                        },

                        _resetSelection: function () {
                            if (((this._oldMulti != this.multi) && !this.multi) ||
                                ((this._oldSelectionEnabled != this.selectionEnabled) &&
                                    !this.selectionEnabled)) {
                                this._clearSelection();
                                this.refresh(true);
                            } else {
                                this.selection = this.$.selection.getSelection();
                            }
                            this._oldMulti = this.multi;
                            this._oldSelectionEnabled = this.selectionEnabled;
                        },

                        // TODO(sorvell): it'd be nice to dispense with 'data' and just use
                        // template repeat's model. However, we need tighter integration
                        // with TemplateBinding for this.
                        initialize: function () {
                            if (!this.template) {
                                return;
                            }

                            // TODO(kschaaf): This is currently the only way to know that the array
                            // was mutated as opposed to newly assigned; to be updated with better API
                            if (arguments.length == 1) {
                                var splices = arguments[0];
                                for (var i = 0; i < splices.length; i++) {
                                    var s = splices[i];
                                    for (var j = 0; j < s.removed.length; j++) {
                                        var d = s.removed[j];
                                        this.$.selection.setItemSelected(d, false);
                                    }
                                }
                            } else {
                                this._clearSelection();
                            }

                            var target = this.scrollTarget || this;
                            if (this._target !== target) {
                                if (this._target) {
                                    this._target.removeEventListener('scroll', this._boundScrollHandler, false);
                                }
                                this._target = target;
                                this._target.addEventListener('scroll', this._boundScrollHandler, false);
                            }
                            // Only use -webkit-overflow-touch from iOS8+, where scroll events are fired
                            var ios = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
                            if (ios && ios[1] >= 8) {
                                target.style.webkitOverflowScrolling = 'touch';
                            }

                            this.initializeData();
                        },

                        initializeData: function () {
                            var currentCount = this._physicalCount || 0;
                            var dataLen = this.data && this.data.length || 0;
                            this._visibleCount = Math.ceil(this._target.offsetHeight / this.height);
                            this._physicalCount = Math.min(this._visibleCount + this.extraItems, dataLen);
                            this._physicalCount = Math.max(currentCount, this._physicalCount);
                            this._physicalData = this._physicalData || new Array(this._physicalCount);
                            var needItemInit = false;
                            while (currentCount < this._physicalCount) {
                                this._physicalData[currentCount++] = {};
                                needItemInit = true;
                            }
                            this.template.model = this._physicalData;
                            this.template.setAttribute('repeat', '');
                            if (needItemInit) {
                                this.onMutation(this, this.initializeItems);
                            } else {
                                this.refresh(true);
                            }
                        },

                        initializeItems: function () {
                            var currentCount = this._physicalItems && this._physicalItems.length || 0;
                            this._physicalItems = this._physicalItems || new Array(this._physicalCount);
                            for (var i = 0, item = this.template.nextElementSibling; item && i < this._physicalCount;
                                ++i, item = item.nextElementSibling) {
                                this._physicalItems[i] = item;
                                item._transformValue = 0;
                            }
                            this.refresh(true);
                        },

                        updateItem: function (virtualIndex, physicalIndex) {
                            var virtualDatum = this.data && this.data[virtualIndex];
                            var physicalDatum = this._physicalData[physicalIndex];
                            physicalDatum.model = virtualDatum;
                            physicalDatum.physicalIndex = physicalIndex;
                            physicalDatum.index = virtualIndex;
                            physicalDatum.selected = this.selectionEnabled && virtualDatum ?
                                this._selectedData.get(virtualDatum) : null;
                            var physicalItem = this._physicalItems[physicalIndex];
                            physicalItem.hidden = !virtualDatum;
                        },

                        scrollHandler: function (e, detail) {
                            this._scrollTop = e.detail ? e.detail.target.scrollTop : e.target.scrollTop;
                            this.refresh(false);
                        },

                        /**
                         * Refresh the list at the current scroll position.
                         *
                         * @method refresh
                         */
                        refresh: function (force) {
                            // Check that the array hasn't gotten longer since data was initialized
                            var dataLen = this.data && this.data.length || 0;
                            if (force) {
                                if (this._physicalCount <
                                    Math.min(this._visibleCount + this.extraItems, dataLen)) {
                                    // Need to add more items; once new data & items are initialized,
                                    // refresh will be run again
                                    this.initializeData();
                                    return;
                                }
                                this._physicalHeight = this.height * this._physicalCount;
                                this.$.viewport.style.height = this.height * dataLen + 'px';
                            }

                            var firstVisibleIndex = Math.floor(this._scrollTop / this.height);
                            var visibleMidpoint = firstVisibleIndex + this._visibleCount / 2;

                            var firstReifiedIndex = Math.max(0, Math.floor(visibleMidpoint -
                                this._physicalCount / 2));
                            firstReifiedIndex = Math.min(firstReifiedIndex, dataLen -
                                this._physicalCount);
                            firstReifiedIndex = (firstReifiedIndex < 0) ? 0 : firstReifiedIndex;

                            var firstPhysicalIndex = firstReifiedIndex % this._physicalCount;
                            var baseVirtualIndex = firstReifiedIndex - firstPhysicalIndex;

                            var baseTransformValue = Math.floor(this.height * baseVirtualIndex);
                            var nextTransformValue = Math.floor(baseTransformValue +
                                this._physicalHeight);

                            var baseTransformString = 'translate3d(0,' + baseTransformValue + 'px,0)';
                            var nextTransformString = 'translate3d(0,' + nextTransformValue + 'px,0)';

                            this.firstPhysicalIndex = firstPhysicalIndex;
                            this.baseVirtualIndex = baseVirtualIndex;

                            for (var i = 0; i < firstPhysicalIndex; ++i) {
                                var item = this._physicalItems[i];
                                if (force || item._transformValue != nextTransformValue) {
                                    this.updateItem(baseVirtualIndex + this._physicalCount + i, i);
                                    setTransform(item, nextTransformString, nextTransformValue);
                                }
                            }
                            for (var i = firstPhysicalIndex; i < this._physicalCount; ++i) {
                                var item = this._physicalItems[i];
                                if (force || item._transformValue != baseTransformValue) {
                                    this.updateItem(baseVirtualIndex + i, i);
                                    setTransform(item, baseTransformString, baseTransformValue);
                                }
                            }
                        },

                        // list selection
                        tapHandler: function (e) {
                            var n = e.target;
                            var p = e.path;
                            if (!this.selectionEnabled || (n === this)) {
                                return;
                            }
                            requestAnimationFrame(function () {
                                // Gambit: only select the item if the tap wasn't on a focusable child
                                // of the list (since anything with its own action should be focusable
                                // and not result in result in list selection).  To check this, we
                                // asynchronously check that shadowRoot.activeElement is null, which
                                // means the tapped item wasn't focusable. On polyfill where
                                // activeElement doesn't follow the data-hinding part of the spec, we
                                // can check that document.activeElement is the list itself, which will
                                // catch focus in lieu of the tapped item being focusable, as we make
                                // the list focusable (tabindex="-1") for this purpose.  Note we also
                                // allow the list items themselves to be focusable if desired, so those
                                // are excluded as well.
                                var active = window.ShadowDOMPolyfill ?
                                    wrap(document.activeElement) : this.shadowRoot.activeElement;
                                if (active && (active != this) && (active.parentElement != this) &&
                                    (document.activeElement != document.body)) {
                                    return;
                                }
                                // Unfortunately, Safari does not focus certain form controls via mouse,
                                // so we also blacklist input, button, & select
                                // (https://bugs.webkit.org/show_bug.cgi?id=118043)
                                if ((p[0].localName == 'input') ||
                                    (p[0].localName == 'button') ||
                                    (p[0].localName == 'select')) {
                                    return;
                                }

                                var model = n.templateInstance && n.templateInstance.model;
                                if (model) {
                                    var vi = model.index,
                                        pi = model.physicalIndex;
                                    var data = this.data[vi],
                                        item = this._physicalItems[pi];
                                    this.$.selection.select(data);
                                    this.asyncFire('core-activate', {
                                        data: data,
                                        item: item
                                    });
                                }
                            }.bind(this));
                        },

                        selectedHandler: function (e, detail) {
                            this.selection = this.$.selection.getSelection();
                            var i$ = this.indexesForData(detail.item);
                            // TODO(sorvell): we should be relying on selection to store the
                            // selected data but we want to optimize for lookup.
                            this._selectedData.set(detail.item, detail.isSelected);
                            if (i$.physical >= 0) {
                                this.updateItem(i$.virtual, i$.physical);
                            }
                        },

                        /**
                         * Select the list item at the given index.
                         *
                         * @method selectItem
                         * @param {number} index
                         */
                        selectItem: function (index) {
                            if (!this.selectionEnabled) {
                                return;
                            }
                            var data = this.data[index];
                            if (data) {
                                this.$.selection.select(data);
                            }
                        },

                        /**
                         * Set the selected state of the list item at the given index.
                         *
                         * @method setItemSelected
                         * @param {number} index
                         * @param {boolean} isSelected
                         */
                        setItemSelected: function (index, isSelected) {
                            var data = this.data[index];
                            if (data) {
                                this.$.selection.setItemSelected(data, isSelected);
                            }
                        },

                        indexesForData: function (data) {
                            var virtual = this.data.indexOf(data);
                            var physical = this.virtualToPhysicalIndex(virtual);
                            return {
                                virtual: virtual,
                                physical: physical
                            };
                        },

                        virtualToPhysicalIndex: function (index) {
                            for (var i = 0, l = this._physicalData.length; i < l; i++) {
                                if (this._physicalData[i].index === index) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        /**
                         * Clears the current selection state of the list.
                         *
                         * @method clearSelection
                         */
                        clearSelection: function () {
                            this._clearSelection();
                            this.refresh(true);
                        },

                        _clearSelection: function () {
                            this._selectedData = new WeakMap();
                            this.$.selection.clear();
                            this.selection = this.$.selection.getSelection();
                        },

                        scrollToItem: function (index) {
                            this.scrollTop = index * this.height;
                        }

                    });

                    // determine proper transform mechanizm
                    if (document.documentElement.style.transform !== undefined) {
                        var setTransform = function (element, string, value) {
                            element.style.transform = string;
                            element._transformValue = value;
                        }
                    } else {
                        var setTransform = function (element, string, value) {
                            element.style.webkitTransform = string;
                            element._transformValue = value;
                        }
                    }

                })();
            </script>
        </polymer-element>

        <polymer-element name="core-localstorage" attributes="name value useRaw autoSaveDisabled" hidden="" assetpath="bower_components/core-localstorage/">
            <script>
                Polymer('core-localstorage', {

                    /**
                     * Fired when a value is loaded from localStorage.
                     * @event core-localstorage-load
                     */

                    /**
                     * The key to the data stored in localStorage.
                     *
                     * @attribute name
                     * @type string
                     * @default null
                     */
                    name: '',

                    /**
                     * The data associated with the specified name.
                     *
                     * @attribute value
                     * @type object
                     * @default null
                     */
                    value: null,

                    /**
                     * If true, the value is stored and retrieved without JSON processing.
                     *
                     * @attribute useRaw
                     * @type boolean
                     * @default false
                     */
                    useRaw: false,

                    /**
                     * If true, auto save is disabled.
                     *
                     * @attribute autoSaveDisabled
                     * @type boolean
                     * @default false
                     */
                    autoSaveDisabled: false,

                    attached: function () {
                        // wait for bindings are all setup
                        this.async('load');
                    },

                    valueChanged: function () {
                        if (this.loaded && !this.autoSaveDisabled) {
                            this.save();
                        }
                    },

                    load: function () {
                        var v = localStorage.getItem(this.name);
                        if (this.useRaw) {
                            this.value = v;
                        } else {
                            // localStorage has a flaw that makes it difficult to determine
                            // if a key actually exists or not (getItem returns null if the
                            // key doesn't exist, which is not distinguishable from a stored
                            // null value)
                            // however, if not `useRaw`, an (unparsed) null value unambiguously
                            // signals that there is no value in storage (a stored null value would
                            // be escaped, i.e. "null")
                            // in this case we save any non-null current (default) value
                            if (v === null) {
                                if (this.value != null) {
                                    this.save();
                                }
                            } else {
                                try {
                                    v = JSON.parse(v);
                                } catch (x) {}
                                this.value = v;
                            }
                        }
                        this.loaded = true;
                        this.asyncFire('core-localstorage-load');
                    },

                    /**
                     * Saves the value to localStorage.
                     *
                     * @method save
                     */
                    save: function () {
                        var v = this.useRaw ? this.value : JSON.stringify(this.value);
                        localStorage.setItem(this.name, v);
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-submenu" attributes="selected selectedItem label icon src valueattr" assetpath="bower_components/core-menu/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
*/
                    :host {
                        display: block;
                        height: auto;
                    }
                    :host(.core-selected,
                    [active]) {
                        font-weight: initial;
                    }
                    core-item {
                        cursor: default;
                    }
                    ::content > core-item {
                        cursor: default;
                    }
                    :host(.font-scalable) > core-item {
                        min-height: 2.5em;
                    }
                    :host(.font-scalable) > core-item::shadow core-icon {
                        margin: 0 1em 0 0.25em;
                        height: 1.5em;
                        width: 1.5em;
                    }
                    #submenu {
                        margin: 0 0 0 44px;
                    }
                    :host(.font-scalable) > #submenu {
                        margin: 0 0 0 2.75em;
                    }
                </style>

                <core-item id="submenuItem" src="{{src}}" label="{{label}}" icon="{{icon}}" class="{{ {'core-selected' : active} | tokenList}}" on-tap="{{activate}}">
                    <content select=".item-content"></content>
                </core-item>

                <core-menu id="submenu" selected="{{selected}}" selecteditem="{{selectedItem}}" valueattr="{{valueattr}}">
                    <content></content>
                </core-menu>

                <core-collapse target="{{$.submenu}}" opened="{{opened}}"></core-collapse>

            </template>
            <script>
                Polymer('core-submenu', {

                    publish: {
                        active: {
                            value: false,
                            reflect: true
                        }
                    },

                    opened: false,

                    get items() {
                        return this.$.submenu.items;
                    },

                    hasItems: function () {
                        return !!this.items.length;
                    },

                    unselectAllItems: function () {
                        this.$.submenu.selected = null;
                        this.$.submenu.clearSelection();
                    },

                    activeChanged: function () {
                        if (this.hasItems()) {
                            this.opened = this.active;
                        }
                        if (!this.active) {
                            this.unselectAllItems();
                        }
                    },

                    toggle: function () {
                        this.opened = !this.opened;
                    },

                    activate: function () {
                        if (this.hasItems() && this.active) {
                            this.toggle();
                            this.unselectAllItems();
                        }
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-menu-button" attributes="icon label src selected opened halign valign valueattr multi inlineMenu" assetpath="bower_components/core-menu-button/">
            <template>
                <style>
                    /*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
                    :host {
                        position: relative;
                        display: inline-block;
                    }
                    #dropdown {
                        margin: 12px;
                        background: #fff;
                        color: #000;
                        border-radius: 3px;
                        border: 1px solid #ccc;
                    }
                </style>
                <core-icon-button id="button" on-tap="{{toggle}}" src="{{src}}" icon="{{icon}}" active="{{opened}}"><span>{{label}}</span>
                </core-icon-button>
                <core-dropdown id="dropdown" relatedtarget="{{$.button}}" opened="{{opened}}" halign="{{halign}}" valign="{{valign}}">
                    <core-menu selected="{{selected}}" valueattr="{{valueattr}}" selectedclass="{{selectedClass}}" selectedproperty="{{selectedProperty}}" selectedattribute="{{selectedAttribute}}" selecteditem="{{selectedItem}}" selectedmodel="{{selectedModel}}" selectedindex="{{selectedIndex}}" excludedlocalnames="{{excludedLocalNames}}" on-core-activate="{{closeAction}}">
                        <content select="*"></content>
                    </core-menu>
                </core-dropdown>
            </template>
            <script>
                Polymer('core-menu-button', {

                    publish: {

                        /**
                         * The icon to display.
                         * @attribute icon
                         * @type string
                         */
                        icon: 'dots',

                        src: '',

                        /**
                         * Set to true to open the menu.
                         * @attribute opened
                         * @type boolean
                         */
                        opened: false,

                        /**
                         * Set to true to cause the menu popup to be displayed inline rather
                         * than in its own layer.
                         * @attribute inlineMenu
                         * @type boolean
                         */
                        inlineMenu: false,

                        /**
                         * Horizontally align the overlay with the button.
                         * @attribute halign
                         * @type string
                         */
                        halign: 'left',

                        /**
                         * Display the overlay on top or below the button.
                         * @attribute valign
                         * @type string
                         */
                        valign: 'top',

                        /**
                         * If true, the selection will persist when the menu is opened
                         * and closed multiple times.
                         *
                         * @attribute stickySelection
                         * @type boolean
                         * @default false
                         */
                        stickySelection: false,

                        /**
                         * The index of the selected menu item.
                         * @attribute selected
                         * @type number
                         */
                        selected: '',

                        /**
                         * Specifies the attribute to be used for "selected" attribute.
                         *
                         * @attribute valueattr
                         * @type string
                         * @default 'name'
                         */
                        valueattr: 'name',

                        /**
                         * Specifies the CSS class to be used to add to the selected element.
                         *
                         * @attribute selectedClass
                         * @type string
                         * @default 'core-selected'
                         */
                        selectedClass: 'core-selected',

                        /**
                         * Specifies the property to be used to set on the selected element
                         * to indicate its active state.
                         *
                         * @attribute selectedProperty
                         * @type string
                         * @default ''
                         */
                        selectedProperty: '',

                        /**
                         * Specifies the attribute to set on the selected element to indicate
                         * its active state.
                         *
                         * @attribute selectedAttribute
                         * @type string
                         * @default 'active'
                         */
                        selectedAttribute: 'active',

                        /**
                         * Returns the currently selected element. In multi-selection this returns
                         * an array of selected elements.
                         * Note that you should not use this to set the selection. Instead use
                         * `selected`.
                         *
                         * @attribute selectedItem
                         * @type Object
                         * @default null
                         */
                        selectedItem: null,

                        /**
                         * In single selection, this returns the model associated with the
                         * selected element.
                         * Note that you should not use this to set the selection. Instead use
                         * `selected`.
                         *
                         * @attribute selectedModel
                         * @type Object
                         * @default null
                         */
                        selectedModel: null,

                        /**
                         * In single selection, this returns the selected index.
                         * Note that you should not use this to set the selection. Instead use
                         * `selected`.
                         *
                         * @attribute selectedIndex
                         * @type number
                         * @default -1
                         */
                        selectedIndex: -1,

                        /**
                         * Nodes with local name that are in the list will not be included
                         * in the selection items.
                         *
                         * @attribute excludedLocalNames
                         * @type string
                         * @default ''
                         */
                        excludedLocalNames: ''

                    },

                    closeAction: function () {
                        this.opened = false;
                    },

                    /**
                     * Toggle the opened state of the dropdown.
                     * @method toggle
                     */
                    toggle: function () {
                        this.opened = !this.opened;
                    },

                    /**
                     * The selected menu item.
                     * @property selection
                     * @type Node
                     */
                    get selection() {
                        return this.$.menu.selection;
                    },

                    openedChanged: function () {
                        if (this.opened && !this.stickySelection) {
                            this.selected = null;
                        }
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-pages" extends="core-selector" selected="0" notap="" assetpath="bower_components/core-pages/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                    }
                    polyfill-next-selector {
                        content: ':host > *';
                    }
                    ::content > * {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        visibility: hidden;
                        z-index: -1000;
                    }
                    polyfill-next-selector {
                        content: ':host > .core-selected';
                    }
                    ::content > .core-selected {
                        visibility: visible;
                        z-index: auto;
                    }
                </style>

                <shadow></shadow>

            </template>
            <script>
                Polymer('core-pages');
            </script>
        </polymer-element>

        <polymer-element name="core-scaffold" assetpath="bower_components/core-scaffold/">
            <template>

                <style>
                    :host {
                        display: block;
                    }
                    [drawer] {
                        background-color: #fff;
                        box-shadow: 1px 0 1px rgba(0, 0, 0, 0.1);
                    }
                    [main] {
                        height: 100%;
                        background-color: #eee;
                    }
                    core-toolbar {
                        background-color: #526E9C;
                        color: #fff;
                    }
                    #drawerPanel:not([narrow]) #menuButton {
                        display: none;
                    }
                </style>

                <core-drawer-panel id="drawerPanel" narrow="{{narrow}}" responsivewidth="{{responsiveWidth}}">

                    <div vertical="" layout="" drawer="">

                        <content select="[navigation], nav"></content>

                    </div>

                    <core-header-panel id="headerPanel" main="" mode="{{mode}}">

                        <core-toolbar>
                            <core-icon-button id="menuButton" icon="menu" on-tap="{{togglePanel}}"></core-icon-button>
                            <content select="[tool]"></content>
                        </core-toolbar>

                        <content select="*"></content>

                    </core-header-panel>

                </core-drawer-panel>

            </template>
            <script>
                Polymer('core-scaffold', {

                    /**
                     * Fired when the main content has been scrolled.  `event.detail.target` returns
                     * the scrollable element which you can use to access scroll info such as
                     * `scrollTop`.
                     *
                     *     <core-scaffold on-scroll="{{scrollHandler}}">
                     *       ...
                     *     </core-scaffold>
                     *
                     *
                     *     scrollHandler: function(event) {
                     *       var scroller = event.detail.target;
                     *       console.log(scroller.scrollTop);
                     *     }
                     *
                     * @event scroll
                     */

                    publish: {
                        /**
                         * When the browser window size is smaller than the `responsiveWidth`,
                         * `core-drawer-panel` changes to a narrow layout. In narrow layout,
                         * the drawer will be stacked on top of the main panel.
                         *
                         * @attribute responsiveWidth
                         * @type string
                         * @default '600px'
                         */
                        responsiveWidth: '600px',

                        /**
                         * Used to control the header and scrolling behaviour of `core-header-panel`
                         *
                         * @attribute mode
                         * @type string
                         * @default 'seamed'
                         */
                        mode: {
                            value: 'seamed',
                            reflect: true
                        }
                    },

                    ready: function () {
                        this._scrollHandler = this.scroll.bind(this);
                        this.$.headerPanel.addEventListener('scroll', this._scrollHandler);
                    },

                    detached: function () {
                        this.$.headerPanel.removeEventListener('scroll', this._scrollHandler);
                    },

                    /**
                     * Toggle the drawer panel
                     * @method togglePanel
                     */
                    togglePanel: function () {
                        this.$.drawerPanel.togglePanel();
                    },

                    /**
                     * Open the drawer panel
                     * @method openDrawer
                     */
                    openDrawer: function () {
                        this.$.drawerPanel.openDrawer();
                    },

                    /**
                     * Close the drawer panel
                     * @method closeDrawer
                     */
                    closeDrawer: function () {
                        this.$.drawerPanel.closeDrawer();
                    },

                    scroll: function (e) {
                        this.fire('scroll', {
                            target: e.detail.target
                        }, this, false);
                    }

                });
            </script>
        </polymer-element>

        <polymer-element name="core-scroll-header-panel" assetpath="bower_components/core-scroll-header-panel/">
            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        position: relative;
                        overflow: hidden;
                    }
                    #mainContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        bottom: 0;
                        left: 0;
                        box-sizing: border-box;
                        -moz-box-sizing: border-box;
                        -webkit-overflow-scrolling: touch;
                        overflow-x: hidden;
                        overflow-y: auto;
                    }
                    #headerContainer {
                        position: absolute;
                        top: 0;
                        right: 0;
                        left: 0;
                    }
                    .bg-container {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        overflow: hidden;
                    }
                    #headerBg,
                    #condensedHeaderBg {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background-repeat: no-repeat;
                        background-size: cover;
                        background-position: center center;
                    }
                    #condensedHeaderBg {
                        opacity: 0;
                    }
                </style>

                <div id="mainContainer">

                    <content id="mainContent" select="[content], .content"></content>

                </div>

                <div id="headerContainer">

                    <div class="bg-container">
                        <div id="condensedHeaderBg"></div>
                        <div id="headerBg"></div>
                    </div>

                    <content id="headerContent" select="core-toolbar, .core-header"></content>

                </div>

            </template>
            <script>
                (function () {

                    Polymer('core-scroll-header-panel', {

                        /**
                         * Fired when the content has been scrolled.
                         *
                         * @event scroll
                         */

                        /**
                         * Fired when the header is transformed.
                         *
                         * @event core-header-transform
                         */

                        publish: {
                            /**
                             * If true, the header's height will condense to `_condensedHeaderHeight`
                             * as the user scrolls down from the top of the content area.
                             *
                             * @attribute condenses
                             * @type boolean
                             * @default false
                             */
                            condenses: false,

                            /**
                             * If true, no cross-fade transition from one background to another.
                             *
                             * @attribute noDissolve
                             * @type boolean
                             * @default false
                             */
                            noDissolve: false,

                            /**
                             * If true, the header doesn't slide back in when scrolling back up.
                             *
                             * @attribute noReveal
                             * @type boolean
                             * @default false
                             */
                            noReveal: false,

                            /**
                             * If true, the header is fixed to the top and never moves away.
                             *
                             * @attribute fixed
                             * @type boolean
                             * @default false
                             */
                            fixed: false,

                            /**
                             * If true, the condensed header is always shown and does not move away.
                             *
                             * @attribute keepCondensedHeader
                             * @type boolean
                             * @default false
                             */
                            keepCondensedHeader: false,

                            /**
                             * The height of the header when it is at its full size.
                             *
                             * By default, the height will be measured when it is ready.  If the height
                             * changes later the user needs to either set this value to reflect the
                             * new height or invoke `measureHeaderHeight()`.
                             *
                             * @attribute headerHeight
                             * @type number
                             * @default 0
                             */
                            headerHeight: 0,

                            /**
                             * The height of the header when it is condensed.
                             *
                             * By default, `_condensedHeaderHeight` is 1/3 of `headerHeight` unless
                             * this is specified.
                             *
                             * @attribute condensedHeaderHeight
                             * @type number
                             * @default 0
                             */
                            condensedHeaderHeight: 0,

                            /**
                             * By default, the top part of the header stays when the header is being
                             * condensed.  Set this to true if you want the top part of the header
                             * to be scrolled away.
                             *
                             * @attribute scrollAwayTopbar
                             * @type boolean
                             * @default false
                             */
                            scrollAwayTopbar: false
                        },

                        prevScrollTop: 0,

                        headerMargin: 0,

                        y: 0,

                        observe: {
                            'headerMargin fixed': 'setup'
                        },

                        ready: function () {
                            this._scrollHandler = this.scroll.bind(this);
                            this.scroller.addEventListener('scroll', this._scrollHandler);
                        },

                        detached: function () {
                            this.scroller.removeEventListener('scroll', this._scrollHandler);
                        },

                        domReady: function () {
                            this.async('measureHeaderHeight');
                        },

                        get header() {
                            return this.$.headerContent.getDistributedNodes()[0];
                        },

                        /**
                         * Returns the scrollable element.
                         *
                         * @property scroller
                         * @type Object
                         */
                        get scroller() {
                            return this.$.mainContainer;
                        },

                        /**
                         * Invoke this to tell `core-scroll-header-panel` to re-measure the header's
                         * height.
                         *
                         * @method measureHeaderHeight
                         */
                        measureHeaderHeight: function () {
                            var header = this.header;
                            if (header && header.offsetHeight) {
                                this.headerHeight = header.offsetHeight;
                            }
                        },

                        headerHeightChanged: function () {
                            if (!this.condensedHeaderHeight) {
                                // assume _condensedHeaderHeight is 1/3 of the headerHeight
                                this._condensedHeaderHeight = this.headerHeight * 1 / 3;
                            }
                            this.condensedHeaderHeightChanged();
                        },

                        condensedHeaderHeightChanged: function () {
                            if (this.condensedHeaderHeight) {
                                this._condensedHeaderHeight = this.condensedHeaderHeight;
                            }
                            if (this.headerHeight) {
                                this.headerMargin = this.headerHeight - this._condensedHeaderHeight;
                            }
                        },

                        condensesChanged: function () {
                            if (this.condenses) {
                                this.scroll();
                            } else {
                                // reset transform/opacity set on the header
                                this.condenseHeader(null);
                            }
                        },

                        setup: function () {
                            var s = this.scroller.style;
                            s.paddingTop = this.fixed ? '' : this.headerHeight + 'px';
                            s.top = this.fixed ? this.headerHeight + 'px' : '';
                            if (this.fixed) {
                                this.transformHeader(null);
                            } else {
                                this.scroll();
                            }
                        },

                        transformHeader: function (y) {
                            var s = this.$.headerContainer.style;
                            this.translateY(s, -y);

                            if (this.condenses) {
                                this.condenseHeader(y);
                            }

                            this.fire('core-header-transform', {
                                y: y,
                                height: this.headerHeight,
                                condensedHeight: this._condensedHeaderHeight
                            });
                        },

                        condenseHeader: function (y) {
                            var reset = y == null;
                            // adjust top bar in core-header so the top bar stays at the top
                            if (!this.scrollAwayTopbar && this.header.$ && this.header.$.topBar) {
                                this.translateY(this.header.$.topBar.style,
                                    reset ? null : Math.min(y, this.headerMargin));
                            }
                            // transition header bg
                            var hbg = this.$.headerBg.style;
                            if (!this.noDissolve) {
                                hbg.opacity = reset ? '' : (this.headerMargin - y) / this.headerMargin;
                            }
                            // adjust header bg so it stays at the center
                            this.translateY(hbg, reset ? null : y / 2);
                            // transition condensed header bg
                            var chbg = this.$.condensedHeaderBg.style;
                            if (!this.noDissolve) {
                                chbg = this.$.condensedHeaderBg.style;
                                chbg.opacity = reset ? '' : y / this.headerMargin;
                                // adjust condensed header bg so it stays at the center
                                this.translateY(chbg, reset ? null : y / 2);
                            }
                        },

                        translateY: function (s, y) {
                            var t = y == null ? '' : 'translate3d(0, ' + y + 'px, 0)';
                            setTransform(s, t);
                        },

                        scroll: function (event) {
                            if (!this.header) {
                                return;
                            }

                            var sTop = this.scroller.scrollTop;

                            var y = Math.min(this.keepCondensedHeader ?
                                this.headerMargin : this.headerHeight, Math.max(0, (this.noReveal ? sTop : this.y + sTop - this.prevScrollTop)));

                            if (this.condenses && this.prevScrollTop >= sTop && sTop > this.headerMargin) {
                                y = Math.max(y, this.headerMargin);
                            }

                            if (!event || !this.fixed && y !== this.y) {
                                this.transformHeader(y);
                            }

                            this.prevScrollTop = Math.max(sTop, 0);
                            this.y = y;

                            if (event) {
                                this.fire('scroll', {
                                    target: this.scroller
                                }, this, false);
                            }
                        }

                    });

                    //determine proper transform mechanizm
                    if (document.documentElement.style.transform !== undefined) {
                        var setTransform = function (style, string) {
                            style.transform = string;
                        }
                    } else {
                        var setTransform = function (style, string) {
                            style.webkitTransform = string;
                        }
                    }

                })();
            </script>
        </polymer-element>

        <polymer-element name="core-shared-lib" attributes="url notifyEvent callbackName" assetpath="bower_components/core-shared-lib/">
            <script>
                (function () {

                    Polymer('core-shared-lib', {

                        notifyEvent: 'core-shared-lib-load',

                        ready: function () {
                            if (!this.url && this.defaultUrl) {
                                this.url = this.defaultUrl;
                            }
                        },

                        urlChanged: function () {
                            require(this.url, this, this.callbackName);
                        },

                        provide: function () {
                            this.async('notify');
                        },

                        notify: function () {
                            this.fire(this.notifyEvent, arguments);
                        }

                    });

                    var apiMap = {};

                    function require(url, notifiee, callbackName) {
                        // make hashable string form url
                        var name = nameFromUrl(url);
                        // lookup existing loader instance
                        var loader = apiMap[name];
                        // create a loader as needed
                        if (!loader) {
                            loader = apiMap[name] = new Loader(name, url, callbackName);
                        }
                        loader.requestNotify(notifiee);
                    }

                    function nameFromUrl(url) {
                        return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
                    }

                    var Loader = function (name, url, callbackName) {
                        this.instances = [];
                        this.callbackName = callbackName;
                        if (this.callbackName) {
                            window[this.callbackName] = this.success.bind(this);
                        } else {
                            if (url.indexOf(this.callbackMacro) >= 0) {
                                this.callbackName = name + '_loaded';
                                window[this.callbackName] = this.success.bind(this);
                                url = url.replace(this.callbackMacro, this.callbackName);
                            } else {
                                // TODO(sjmiles): we should probably fallback to listening to script.load
                                throw 'core-shared-api: a %%callback%% parameter is required in the API url';
                            }
                        }
                        //
                        this.addScript(url);
                    };

                    Loader.prototype = {

                        callbackMacro: '%%callback%%',
                        loaded: false,

                        addScript: function (src) {
                            var script = document.createElement('script');
                            script.src = src;
                            script.onerror = this.error.bind(this);
                            var s = document.querySelector('script');
                            s.parentNode.insertBefore(script, s);
                            this.script = script;
                        },

                        removeScript: function () {
                            if (this.script.parentNode) {
                                this.script.parentNode.removeChild(this.script);
                            }
                            this.script = null;
                        },

                        error: function () {
                            this.cleanup();
                        },

                        success: function () {
                            this.loaded = true;
                            this.cleanup();
                            this.result = Array.prototype.slice.call(arguments);
                            this.instances.forEach(this.provide, this);
                            this.instances = null;
                        },

                        cleanup: function () {
                            delete window[this.callbackName];
                        },

                        provide: function (instance) {
                            instance.notify(instance, this.result);
                        },

                        requestNotify: function (instance) {
                            if (this.loaded) {
                                this.provide(instance);
                            } else {
                                this.instances.push(instance);
                            }
                        }

                    };

                })();
            </script>
        </polymer-element>

        <polymer-element name="core-signals" assetpath="bower_components/core-signals/">
            <script>
                (function () {

                    Polymer('core-signals', {
                        attached: function () {
                            signals.push(this);
                        },
                        removed: function () {
                            var i = signals.indexOf(this);
                            if (i >= 0) {
                                signals.splice(i, 1);
                            }
                        }
                    });

                    // private shared database
                    var signals = [];

                    // signal dispatcher
                    function notify(name, data) {
                        // convert generic-signal event to named-signal event
                        var signal = new CustomEvent('core-signal-' + name, {
                            // if signals bubble, it's easy to get confusing duplicates
                            // (1) listen on a container on behalf of local child
                            // (2) some deep child ignores the event and it bubbles
                            //     up to said container
                            // (3) local child event bubbles up to container
                            // also, for performance, we avoid signals flying up the
                            // tree from all over the place
                            bubbles: false,
                            detail: data
                        });
                        // dispatch named-signal to all 'signals' instances,
                        // only interested listeners will react
                        signals.forEach(function (s) {
                            s.dispatchEvent(signal);
                        });
                    }

                    // signal listener at document
                    document.addEventListener('core-signal', function (e) {
                        notify(e.detail.name, e.detail.data);
                    });

                })();
            </script>
        </polymer-element>

        <polymer-element name="core-splitter" attributes="direction locked minSize allowOverflow" on-trackstart="{{trackStart}}" on-track="{{track}}" on-down="{{preventSelection}}" assetpath="bower_components/core-splitter/">

            <template>

                <style>
                    /*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
                    :host {
                        display: block;
                        width: 12px;
                        background: #efefef url("bower_components/core-splitter/handle.svg") no-repeat center;
                        box-shadow: inset 0 0 2px 1px #ccc;
                        cursor: col-resize;
                    }
                    :host(.horizontal) {
                        width: auto;
                        height: 12px;
                        cursor: row-resize;
                        background-image: url("bower_components/core-splitter/handle-h.svg");
                    }
                    :host(:hover,
                    :active) {
                        background-color: #ddd;
                    }
                </style>

            </template>
            <script>
                Polymer('core-splitter', {

                    /**
                     * Possible values are `left`, `right`, `up` and `down`.
                     *
                     * @attribute direction
                     * @type string
                     * @default 'left'
                     */
                    direction: 'left',

                    /**
                     * Minimum width to which the splitter target can be sized, e.g.
                     * `minSize="100px"`
                     *
                     * @attribute minSize
                     * @type string
                     * @default ''
                     */
                    minSize: '',

                    /**
                     * Locks the split bar so it can't be dragged.
                     *
                     * @attribute locked
                     * @type boolean
                     * @default false
                     */
                    locked: false,

                    /**
                     * By default the parent and siblings of the splitter are set to overflow hidden. This helps
                     * avoid elements bleeding outside the splitter regions. Set this property to true to allow
                     * these elements to overflow.
                     *
                     * @attribute allowOverflow
                     * @type boolean
                     * @default false
                     */
                    allowOverflow: false,

                    ready: function () {
                        this.directionChanged();
                    },

                    domReady: function () {
                        if (!this.allowOverflow) {
                            this.parentNode.style.overflow = this.nextElementSibling.style.overflow =
                                this.previousElementSibling.style.overflow = 'hidden';
                        }
                    },

                    directionChanged: function () {
                        this.isNext = this.direction === 'right' || this.direction === 'down';
                        this.horizontal = this.direction === 'up' || this.direction === 'down';
                        this.update();
                    },

                    update: function () {
                        this.target = this.isNext ? this.nextElementSibling : this.previousElementSibling;
                        this.dimension = this.horizontal ? 'height' : 'width';
                        this.classList.toggle('horizontal', this.horizontal);
                    },

                    targetChanged: function (old) {
                        if (old) {
                            old.style[old.__splitterMinSize] = '';
                        }
                        var min = this.target.__splitterMinSize = this.horizontal ? 'minHeight' : 'minWidth';
                        this.target.style[min] = this.minSize;
                    },

                    trackStart: function () {
                        this.update();
                        this.size = parseInt(getComputedStyle(this.target)[this.dimension]);
                    },

                    track: function (e) {
                        if (this.locked) {
                            return;
                        }
                        var d = e[this.horizontal ? 'dy' : 'dx'];
                        this.target.style[this.dimension] =
                            this.size + (this.isNext ? -d : d) + 'px';
                    },

                    preventSelection: function (e) {
                        e.preventDefault();
                    }
                });
            </script>
        </polymer-element>
        <polymer-element name="core-tooltip" extends="paper-focusable" attributes="noarrow position label show tipAttribute" role="tooltip" assetpath="bower_components/core-tooltip/">
            <template>

                <style>
                    /* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */
                    :host {
                        box-sizing: border-box;
                        position: relative;
                        display: inline-block;
                        outline: none;
                    }
                    :host(:hover:not([disabled])) .core-tooltip {
                        visibility: visible !important;
                    }
                    :host([focused]) .core-tooltip {
                        visibility: visible !important;
                    }
                    .core-tooltip:not(.show) {
                        visibility: hidden;
                    }
                    .core-tooltip {
                        position: absolute;
                        font-size: 10px;
                        font-family: sans-serif;
                        padding: 8px;
                        color: white;
                        background-color: rgba(0, 0, 0, 0.8);
                        box-sizing: border-box;
                        border-radius: 3px;
                        /* TODO: not in spec. */
                        white-space: nowrap;
                        line-height: 6px;
                        z-index: 1002;
                        /* TODO: this is brittle. */
                        -webkit-user-select: none;
                        user-select: none;
                    }
                    :host([large]) .core-tooltip {
                        line-height: 14px;
                        font-size: 14px;
                        padding: 16px;
                    }
                    .core-tooltip.noarrow::after {
                        display: none;
                    }
                    .core-tooltip::after {
                        position: absolute;
                        border: solid transparent;
                        content: '';
                        height: 0;
                        width: 0;
                        border-width: 4px;
                    }
                    .top {
                        margin-bottom: 10px;
                        /* TODO: not specified in spec */
                        bottom: 100%;
                    }
                    .right {
                        margin-left: 10px;
                        /* TODO: not specified in spec */
                        left: 100%;
                    }
                    .bottom {
                        top: 100%;
                        margin-top: 10px;
                        /* TODO: not specified in spec */
                    }
                    .left {
                        margin-right: 10px;
                        /* TODO: not specified in spec */
                        right: 100%;
                    }
                    .core-tooltip.bottom::after {
                        bottom: 100%;
                        left: calc(50% - 4px);
                        border-bottom-color: rgba(0, 0, 0, 0.8);
                    }
                    .core-tooltip.left::after {
                        left: 100%;
                        top: calc(50% - 4px);
                        border-left-color: rgba(0, 0, 0, 0.8);
                    }
                    .core-tooltip.top::after {
                        top: 100%;
                        left: calc(50% - 4px);
                        border-top-color: rgba(0, 0, 0, 0.8);
                    }
                    .core-tooltip.right::after {
                        right: 100%;
                        top: calc(50% - 4px);
                        border-right-color: rgba(0, 0, 0, 0.8);
                    }
                </style>
                <div id="tooltip" hidden?="{{!hasTooltipContent}}" class="core-tooltip {{position}} {{ {noarrow: noarrow, show: show &amp;&amp; !disabled} | tokenList}}">
                    <content id="c" select="[{{tipAttribute}}]">{{label}}</content>
                </div>

                <content></content>

            </template>
            <script>
                Polymer('core-tooltip', {

                    /**
                     * A simple string label for the tooltip to display. To display a rich
                     * HTML tooltip instead, omit `label` and include the `tip` attribute
                     * on a child node of `core-tooltip`.
                     *
                     * @attribute label
                     * @type string
                     * @default null
                     */
                    label: null,

                    computed: {
                        // Indicates whether the tooltip has a set label propety or
                        // an element with the `tip` attribute.
                        hasTooltipContent: 'label || !!tipElement'
                    },

                    publish: {
                        /**
                         * Forces the tooltip to display. If `disabled` is set, this property is ignored.
                         *
                         * @attribute show
                         * @type boolean
                         * @default false
                         */
                        show: {
                            value: false,
                            reflect: true
                        },

                        /**
                         * Positions the tooltip to the top, right, bottom, left of its content.
                         *
                         * @attribute position
                         * @type string
                         * @default 'bottom'
                         */
                        position: {
                            value: 'bottom',
                            reflect: true
                        },

                        /**
                         * If true, the tooltip an arrow pointing towards the content.
                         *
                         * @attribute noarrow
                         * @type boolean
                         * @default false
                         */
                        noarrow: {
                            value: false,
                            reflect: true
                        }
                    },

                    /**
                     * Customizes the attribute used to specify which content
                     * is the rich HTML tooltip.
                     *
                     * @attribute tipAttribute
                     * @type string
                     * @default 'tip'
                     */
                    tipAttribute: 'tip',

                    attached: function () {
                        this.updatedChildren();
                    },

                    updatedChildren: function () {
                        this.tipElement = null;

                        for (var i = 0, el; el = this.$.c.getDistributedNodes()[i]; ++i) {
                            if (el.hasAttribute && el.hasAttribute('tip')) {
                                this.tipElement = el;
                                break;
                            }
                        }

                        // Job ensures we're not double calling setPosition() on DOM attach.
                        this.job('positionJob', this.setPosition);

                        // Monitor children to re-position tooltip when light dom changes.
                        this.onMutation(this, this.updatedChildren);
                    },

                    labelChanged: function (oldVal, newVal) {
                        this.job('positionJob', this.setPosition);
                    },

                    positionChanged: function (oldVal, newVal) {
                        this.job('positionJob', this.setPosition);
                    },

                    setPosition: function () {
                        var controlWidth = this.clientWidth;
                        var controlHeight = this.clientHeight;
                        var toolTipWidth = this.$.tooltip.clientWidth;
                        var toolTipHeight = this.$.tooltip.clientHeight;

                        switch (this.position) {
                        case 'top':
                        case 'bottom':
                            this.$.tooltip.style.left = (controlWidth - toolTipWidth) / 2 + 'px';
                            this.$.tooltip.style.top = null;
                            break;
                        case 'left':
                        case 'right':
                            this.$.tooltip.style.left = null;
                            this.$.tooltip.style.top = (controlHeight - toolTipHeight) / 2 + 'px';
                            break;
                        }
                    }
                });
            </script>
        </polymer-element>

        <polymer-element name="sample-content" attributes="size" assetpath="bower_components/core-scroll-header-panel/demos/">
            <script>
                (function () {

                    var strings = [
      'Lorem ipsum dolor sit amet, per in nusquam nominavi periculis, sit elit oportere ea.',
      'Ut labores minimum atomorum pro. Laudem tibique ut has.',
      'Fugit adolescens vis et, ei graeci forensibus sed.',
      'Convenire definiebas scriptorem eu cum. Sit dolor dicunt consectetuer no.',
      'Ea duis bonorum nec, falli paulo aliquid ei eum.',
      'Usu eu novum principes, vel quodsi aliquip ea.',
      'Has at minim mucius aliquam, est id tempor laoreet.',
      'Pro saepe pertinax ei, ad pri animal labores suscipiantur.',
      'Detracto suavitate repudiandae no eum. Id adhuc minim soluta nam.',
      'Iisque perfecto dissentiet cum et, sit ut quot mandamus, ut vim tibique splendide instructior.',
      'Id nam odio natum malorum, tibique copiosae expetenda mel ea.',
      'Cu mei vide viris gloriatur, at populo eripuit sit.',
      'Modus commodo minimum eum te, vero utinam assueverit per eu.',
      'No nam ipsum lorem aliquip, accumsan quaerendum ei usu.'
    ];

                    function randomString() {
                        return strings[Math.floor(Math.random() * strings.length)];
                    }

                    function randomLetter() {
                        return String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }

                    Polymer('sample-content', {

                        size: 0,

                        sizeChanged: function () {
                            this.innerHTML = '';
                            for (var i = 0; i < this.size; i++) {
                                this.innerHTML +=
                                    '<div style="border: 1px solid #bebebe; padding: 16px; margin: 16px; border-radius: 5px; background-color: #fff; color: #555;">' +
                                    '<div style="display: inline-block; height: 64px; width: 64px; border-radius: 50%; background: #ddd; line-height: 64px; font-size: 30px; color: #666; text-align: center;">' + randomLetter() + '</div>' +
                                    '<div style="font-size: 22px; padding: 8px 0 16px; color: #888;">' + randomString() + '</div>' +
                                    '<div style="font-size: 16px; padding-bottom: 8px;">' + randomString() + '</div>' +
                                    '<div style="font-size: 12px;">' + randomString() + '</div>' +
                                    '<div style="font-size: 12px;">' + randomString() + '</div>' +
                                    '</div>';
                            }
                        }

                    });
                })();
            </script>
        </polymer-element>
    </div>
    <polymer-element name="music-demo" assetpath="">
        <template>

            <style>
                .chip {
                    display: inline-block;
                    border-radius: 3px;
                    margin: 4px;
                    overflow: hidden;
                    text-align: start;
                    background-color: #fff;
                    box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.16);
                }
                .chip-top {
                    width: 200px;
                    height: 200px;
                }
                .chip-bottom {
                    padding: 8px;
                    line-height: 1.5;
                }
                .chip-album-title {
                    font-weight: bold;
                }
                #details {
                    padding: 200px 10% 0;
                }
                .card {
                    height: 400px;
                    border-radius: 3px;
                    text-align: start;
                    overflow: hidden;
                    background: #fff;
                    box-shadow: 0 6px 20px 0 rgba(0, 0, 0, 0.19);
                }
                .card-left {
                    width: 400px;
                }
                .card-right {
                    padding: 24px;
                }
                .card-icon {
                    border-radius: 50%;
                    width: 60px;
                    height: 60px;
                    margin-right: 16px;
                }
                .card-album-title {
                    font-size: 2em;
                }
            </style>

            <core-animated-pages selected="{{page}}" transitions="hero-transition" on-core-animated-pages-transition-end="{{complete}}" class="venue-blocks">

                <section>

                    <div hero-p="" on-tap="{{transition}}">

                        <template repeat="{{items as item}}">

                            <div class="chip" hero-id="{{item.artist}}-{{item.album}}" hero?="{{selectedAlbum === item }}">
                                <div class="chip-top" style="background:{{item.color}};" hero-id="{{item.artist}}-{{item.album}}-art" hero?="{{selectedAlbum === item}}"></div>
                                <div class="chip-bottom">
                                    <div class="chip-album-title">{{item.album}}</div>
                                    <div class="chip-artist">{{item.artist}}</div>
                                </div>
                            </div>

                        </template>

                    </div>
                </section>

                <section id="details">

                    <div class="card" layout="" horizontal="" hero-id="{{selectedAlbum.artist}}-{{selectedAlbum.album}}" hero="" on-tap="{{transition}}">
                        <div class="card-left" style="background:{{selectedAlbum.color}};" hero-id="{{selectedAlbum.artist}}-{{selectedAlbum.album}}-art" hero=""></div>
                        <div class="card-right" flex="">
                            <div layout="" horizontal="" center="">
                                <div>
                                    <div class="card-icon" style="background:{{selectedAlbum.color}};"></div>
                                </div>
                                <div flex="">
                                    <div class="card-album-title">{{selectedAlbum.album}}</div>
                                    <div class="card-album-artist">{{selectedAlbum.artist}}</div>
                                </div>
                            </div>
                        </div>
                    </div>

                </section>


            </core-animated-pages>

        </template>
        <script>
            Polymer('music-demo', {

                page: 0,

                items: [
                    {
                        artist: 'Tycho',
                        album: 'Fragments',
                        color: '#f4db33'
                    },
                    {
                        artist: 'Tycho',
                        album: 'Past Prologue',
                        color: '#972ff8'
                    },
                    {
                        artist: 'Tycho',
                        album: 'Spectre',
                        color: '#7dd6fe'
                    },
                    {
                        artist: 'Tycho',
                        album: 'Awake',
                        color: '#dc3c84'
                    }
      ],

                selectedAlbum: null,

                transition: function (e) {
                    if (this.page === 0 && e.target.templateInstance.model.item) {
                        this.selectedAlbum = e.target.templateInstance.model.item;
                        this.page = 1;
                    } else {
                        this.page = 0;
                    }
                }
            });
        </script>
    </polymer-element>



    <core-scroll-header-panel condenses="">

        <core-toolbar class="tall" flex="" navigation="">


            <paper-tabs selected="0" selectedindex="0" id="paper-tabs" roll="tablist" center-justified="" center="" horizontal="" layout="" class="bottom fit">
                <paper-tab id="paper-tab-1" active="" class="core-selected">MAP</paper-tab>
                <paper-tab id="paper-tab-2">
                    BROWSE</paper-tab>
                <paper-tab id="paper-tab-3">
                    DEALS</paper-tab>
            </paper-tabs>


        </core-toolbar>
        <div content="" class="top-buffer">
            <!-- pages -->

            <core-animated-pages transitions="cross-fade" selected="0" class="onehun">
                <!--map-->
                <section id="paper-tab-1" active="" flex="" class="onehun">
                    <div cross-fade="" class="onehun">
                        <div id="bottom1" flex="" class="onehun">

                            <paper-button raised="" href="#" id="geolocate" class="btn btn-primary ui-button">Show my location</paper-button>
                            <div id="map"></div>
                        </div>
                    </div>
                </section>
                <!--/map-->
                <!-- Browse -->
                <section id="paper-tab-2" flex="" class="onehun">
                    <div layout="" horizontal="" center="" cross-fade="" class="onehun">
                        <div id="bottom1" layout="" horizontal="" center="" class="venue-blocks">


                            <music-demo class="onehun"></music-demo>
                        </div>
                    </div>
                </section>
                <!--/Browse-->
                <!--deals -->
                <section id="paper-tab-3">
                    <div layout="" horizontal="" center="" center-justified="" cross-fade="">
                        <div id="bottom1">
                            <div class="content">
                                <sample-content size="100"></sample-content>
                            </div>
                        </div>
                    </div>
                </section>
                <!--/specials-->
            </core-animated-pages>
        </div>
    </core-scroll-header-panel>
    <!-- scripts -->
    <script type="text/javascript" src="bower_components/platform/platform.js">
    </script>
    <script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>

    <script>
        var tabs = document.querySelector('paper-tabs');
        var pages = document.querySelector('core-animated-pages');
        tabs.addEventListener('core-select', function () {
            console.log("Selected: " + tabs.selected);
            pages.selected = tabs.selected;
        });
    </script>
    <script>
        function toggleDialog(transition) {
            var dialog = document.querySelector('paper-dialog[transition=' + transition + ']');
            dialog.toggle();
        }
    </script>
    <script>
        // custom transformation: scale header's title
        var titleStyle = document.querySelector('.title').style;
        addEventListener('core-header-transform', function (e) {
            var d = e.detail;
            var m = d.height - d.condensedHeight;
            var scale = Math.max(0.75, (m - d.y) / (m / 0.25) + 0.75);
            titleStyle.transform = titleStyle.webkitTransform =
                'scale(' + scale + ') translateZ(0)';
        });
    </script>
    <script>
        addEventListener('template-bound', function (e) {
            var scope = e.target;
            var items = [],
                count = 50;
            for (var i = 0; i < count; i++) {
                items.push(i);
            }

            scope.items = items;

            scope.selectView = function (e) {
                var i = e.target.templateInstance.model.item;
                this.$.pages.selected = i + 1;
            }

            scope.back = function () {
                this.lastSelected = this.$.pages.selected;
                console.log(this.lastSelected);
                this.$.pages.selected = 0;
            }

            scope.transitionend = function () {
                if (this.lastSelected) {
                    this.lastSelected = null;
                }
            }
        })
    </script>










</body>

</html>
